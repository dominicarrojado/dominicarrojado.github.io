<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#2c2c34"/><link rel="icon" href="https://dominicarrojado.com/favicon.ico"/><link rel="manifest" href="https://dominicarrojado.com/manifest.json"/><meta name="twitter:card" content="summary_large_image"/><meta property="og:image" content="https://dominicarrojado.com/images/pages/guides-tips-and-tricks-to-web-development.png"/><meta property="og:image:alt" content="Dominic Arrojado | Guides, Tips and Tricks to Web Development"/><meta property="og:image:type" content="image/png"/><meta property="og:image:width" content="2400"/><meta property="og:image:height" content="1254"/><meta property="og:site_name" content="Dominic Arrojado"/><link rel="preload" href="/fonts/Roboto-Light.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Light.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-LightItalic.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-LightItalic.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Regular.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Italic.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Medium.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-MediumItalic.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-MediumItalic.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Bold.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-BoldItalic.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-BoldItalic.woff" as="font" type="font/woff" crossorigin="anonymous"/><title>How to create your own accordion in React and TypeScript with tests | Dominic Arrojado</title><meta name="robots" content="index,follow"/><meta name="description" content="Learn how to build a collapsible content in a reactive and reusable way"/><meta property="og:title" content="How to create your own accordion in React and TypeScript with tests | Dominic Arrojado"/><meta property="og:description" content="Learn how to build a collapsible content in a reactive and reusable way"/><meta property="og:url" content="https://dominicarrojado.com/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2021-09-27T14:00:00Z"/><meta property="article:modified_time" content="2021-09-27T14:00:00Z"/><meta property="article:author" content="https://dominicarrojado.com/about/"/><link rel="canonical" href="https://dominicarrojado.com/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/"/><meta name="next-head-count" content="39"/><link rel="preload" href="/_next/static/css/903b127ae59964e1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/903b127ae59964e1.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e97a7e86d35d580d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e97a7e86d35d580d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-3288ddac39eb527b.js" defer=""></script><script src="/_next/static/chunks/framework-63d16ff2f5e08230.js" defer=""></script><script src="/_next/static/chunks/main-5534f25096575a94.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f536273277cfd9f5.js" defer=""></script><script src="/_next/static/chunks/451-99d540e7e1cfd160.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-2f5bcd58e7a91041.js" defer=""></script><script src="/_next/static/KGsbdrvK_53-1lZ7PKZnz/_buildManifest.js" defer=""></script><script src="/_next/static/KGsbdrvK_53-1lZ7PKZnz/_ssgManifest.js" defer=""></script></head><body><div id="__next"><noscript>
            <iframe
              src="https://www.googletagmanager.com/ns.html?id=GTM-TSMLTPT"
              height="0"
              width="0"
              style="display: none; visibility: hidden"
            ></iframe>
          </noscript><div tabindex="-1" class="h-full outline-none"><header class="fixed top-0 z-40 flex w-full items-center"><a href="#main" tabindex="0" class="absolute -left-96 -top-96 -z-50 h-px w-px overflow-hidden text-center text-white focus:inset-x-0 focus:top-4 focus:z-50 focus:m-auto focus:h-auto focus:w-44 focus:sm:w-52 focus:xl:w-56">Skip to main content</a><a class="absolute left-3.5 top-3.5 z-50 flex border border-white bg-gray-750 bg-opacity-90 p-1.5 shadow-3xl transform transition duration-500 ease-in-out hover:bg-opacity-100 hover:shadow-md motion-reduce:transition-none sm:left-4 sm:top-4 md:left-5 md:top-5 md:border-2 lg:left-8 lg:top-8 -translate-y-full opacity-0" aria-label="Dominic Arrojado logo" href="/"><svg viewBox="0 0 25750 29700" role="img" class="h-7 w-7 text-white transition-colors duration-300 sm:h-8 sm:w-8 md:h-10 md:w-10 xl:h-11 xl:w-11"><path fill="currentColor" d="M4850 19266H1025V2039l4600-129c2511 0 4500 735 5970 2206 1470 1470 2206 3423 2206 5854 0 6199-2985 9296-8951 9296zM4086 4719v11751c494 48 1025 72 1599 72 1543 0 2752-558 3624-1679s1310-2688 1310-4705c0-3684-1712-5524-5135-5524-329 0-795 28-1398 85zm17656 21711l-1437-3969h-6721l974-2655h4730l-2242-6854 1518-4167 7010 17645zM17826 435h3307L10351 29313H7044l4243-11322c1982-1513 2973-4055 2973-7627 0-171-4-340-11-506l3577-9423z"></path></svg></a><div class="absolute right-3.5 top-3.5 ml-auto flex items-end gap-3 sm:right-4 sm:top-4 sm:gap-4 md:right-5 md:top-5 md:gap-5 lg:right-8 lg:top-8 lg:gap-6" style="padding-right:var(--scrollbar-width, 0)" data-testid="header-buttons"><button data-command="" data-disclosure="" aria-expanded="false" class="group flex min-w-8 flex-col items-center outline-none md:min-w-10 xl:min-w-11" aria-label="Toggle menu"><div class="h-0.5 w-6 rounded bg-gray-400 dark:bg-gray-300 transform transition group-hover:bg-gray-500 group-focus-visible:bg-gray-500 motion-reduce:transition-none dark:group-hover:bg-white dark:group-focus-visible:bg-white md:h-1 md:w-7 xl:w-8 duration-700 opacity-0 translate-x-1/2" style="transition-delay:0ms" data-testid="menu-stack"></div><div class="h-0.5 w-6 rounded bg-gray-400 dark:bg-gray-300 transform transition group-hover:bg-gray-500 group-focus-visible:bg-gray-500 motion-reduce:transition-none dark:group-hover:bg-white dark:group-focus-visible:bg-white md:h-1 md:w-7 xl:w-8 mt-1.5 duration-700 opacity-0 -translate-x-1/2" style="transition-delay:100ms" data-testid="menu-stack"></div><div class="h-0.5 w-6 rounded bg-gray-400 dark:bg-gray-300 transform transition group-hover:bg-gray-500 group-focus-visible:bg-gray-500 motion-reduce:transition-none dark:group-hover:bg-white dark:group-focus-visible:bg-white md:h-1 md:w-7 xl:w-8 mt-1.5 duration-700 opacity-0 translate-x-1/2" style="transition-delay:200ms" data-testid="menu-stack"></div><div class="mt-1.5 select-none text-3xs font-normal uppercase text-gray-400 dark:text-gray-300 transform transition-transform-opacity-color duration-700 group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-gray-100 md:mt-2 md:text-2xs xl:text-xs -translate-y-3 opacity-0">Menu</div></button></div></header><span id=":R366:" style="position:fixed"></span><div id="main"></div><section class="relative flex flex-col items-center justify-center overflow-hidden bg-gray-550 px-6 text-center dark:bg-gray-650 sm:px-20 lg:px-32 min-h-96 py-28"><div class="absolute left-0 top-0 h-full w-full bg-center bg-repeat invert-[.1] dark:invert-0 transition-opacity duration-1250 motion-safe:animate-slide motion-reduce:transition-none opacity-0" style="background-image:url(&#x27;/images/bg/pattern.png&#x27;)"></div><div class="overflow-hidden py-2" style="opacity:1"><h1 class="text-3xl font-bold leading-tight text-white transform transition duration-700 motion-reduce:transition-none sm:text-4xl md:text-5xl lg:text-6xl xl:text-7xl translate-y-full opacity-0">How to create your own accordion in React and TypeScript with tests</h1></div><div class="overflow-hidden" style="opacity:1"><p class="font-light text-white transform transition duration-700 motion-reduce:transition-none xl:text-2xl translate-y-full opacity-0">Learn how to build a collapsible content in a reactive and reusable way</p></div></section><section class="px-6 pb-20 pt-16 sm:px-8 sm:pb-24 sm:pt-20 md:pb-28 md:pt-24 lg:px-10 xl:pb-32 xl:pt-28 transform transition-transform-opacity duration-700 motion-reduce:transition-none opacity-0" data-testid="section"><div class="mx-auto -mt-8 w-11/12 max-w-screen-3xl pb-8 sm:-mt-10 sm:pb-10 md:-mt-12 md:pb-12 lg:w-5/6"><ins class="adsbygoogle mx-auto block max-w-[1200px] adUnit_adunit__uTSk1" data-ad-client="ca-pub-3632473845121107" data-ad-slot="4984498713" data-ad-format="auto" data-full-width-responsive="true" data-testid="ad-unit"></ins></div><div class="mx-auto flex w-11/12 max-w-screen-3xl items-center justify-between lg:w-5/6"><div class="mr-4 text-sm text-gray-400 sm:text-base xl:text-lg">Last Updated: <time dateTime="2021-09-27">September 27, 2021</time></div><div class="rounded bg-gray-200 px-1.5 py-0.5 text-2xs capitalize dark:bg-gray-600 md:px-2 md:py-1 md:text-xs xl:text-sm">technology</div></div><div class="mx-auto mt-4 w-11/12 max-w-screen-3xl lg:w-5/6"><a class="group inline-flex select-none items-center font-normal dark:hover:text-white transition-colors duration-300 hover:text-black group-hover:text-black motion-reduce:transition-none" target="_blank" rel="noopener noreferrer nofollow" href="https://youtu.be/Hn7iDjbPtVY"><svg viewBox="0 0 576 512" role="img" class="mr-2 h-6 w-6 text-gray-400 transition-colors duration-300 group-hover:text-red motion-reduce:transition-none dark:group-hover:text-white sm:mr-3 sm:h-7 sm:w-7 xl:h-8 xl:w-8"><path fill="currentColor" d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z"></path></svg> <!-- -->Watch it on YouTube<svg viewBox="0 0 320 512" role="img" class="ml-2 inline-block h-2 w-2 text-black opacity-30 dark:text-white transform transition duration-300 group-hover:translate-x-1.5 group-hover:opacity-100 motion-reduce:transition-none sm:ml-2.5 sm:h-2.5 sm:w-2.5 md:ml-3 md:h-3 md:w-3 xl:h-3.5 xl:w-3.5"><path fill="currentColor" d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"></path></svg></a></div><article class="prose mx-auto w-11/12 max-w-screen-3xl dark:prose-dark sm:prose-lg lg:w-5/6 xl:prose-xl mt-8 sm:mt-10 xl:mt-14" data-clarity-region="article" data-testid="content"><h2>Introduction</h2>
<p>Accordions (or collapsible content) are useful for when you have a large amount of content to display and allow users to toggle between showing and hiding the content. This can be seen a lot in different websites today. Learn how to build your own accordion in <a target="_blank" rel="noopener noreferrer nofollow" href="https://reactjs.org/">React</a> and <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.typescriptlang.org/">TypeScript</a>. I&#x27;ll also cover how to write tests for it and achieve 100% coverage using <a target="_blank" rel="noopener noreferrer nofollow" href="https://jestjs.io/">Jest</a> and <a target="_blank" rel="noopener noreferrer nofollow" href="https://testing-library.com/">Testing Library</a>, these two libraries are used together to test React components. If you&#x27;re new to TypeScript and Jest/Testing Library, this is a good way to start learning it with simple components like this. Alright, here we go ~</p>
<h2>Prerequisites</h2>
<p>This is the <a target="_blank" href="/react-typescript-accordion/">link</a> to the accordion which we&#x27;ll accomplish by the end of this post, you can see and play around with it or use it as your reference throughout this tutorial.</p>
<p>By the way, upon writing this post, I assume that you have some web development background and basic knowledge regarding <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.npmjs.com/">npm</a>, <a target="_blank" rel="noopener noreferrer nofollow" href="https://classic.yarnpkg.com/lang/en/">yarn</a>, <a target="_blank" rel="noopener noreferrer nofollow" href="https://developer.mozilla.org/en-US/docs/Web/HTML">HTML</a>, <a target="_blank" rel="noopener noreferrer nofollow" href="https://developer.mozilla.org/en-US/docs/Web/CSS">CSS</a>, <a target="_blank" rel="noopener noreferrer nofollow" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">JavaScript</a> and <a target="_blank" rel="noopener noreferrer nofollow" href="https://reactjs.org/">React</a>.</p>
<p>Make sure to install <a target="_blank" rel="noopener noreferrer nofollow" href="https://classic.yarnpkg.com/lang/en/">Yarn</a> in your system if you haven&#x27;t. We use <a target="_blank" rel="noopener noreferrer nofollow" href="https://classic.yarnpkg.com/lang/en/">Yarn</a> as our package manager, it&#x27;s just like <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.npmjs.com/">npm</a> but <em>faster</em>.</p>
<p>I&#x27;ve written a <a href="/posts/local-development-setup-for-react-and-typescript-projects//">separate post</a> about the <a target="_blank" rel="noopener noreferrer nofollow" href="https://en.wikipedia.org/wiki/Integrated_development_environment">IDE</a> and extensions I use to help me save time and energy when writing my code in React. I highly suggest that you check it out if you haven&#x27;t!</p>
<h2>Initialize your project</h2>
<p>Fastest way to get started with React is using the <a target="_blank" rel="noopener noreferrer nofollow" href="https://create-react-app.dev/">Create React App</a>. It is an officially supported way to create single-page React applications. It offers a modern build setup with no configuration so you can focus on code, not build tools.</p>
<p>To create our project with React and TypeScript, run this command in your terminal:</p>
<pre><code class="hljs language-bash">yarn create react-app react-typescript-accordion --template typescript
</code></pre>
<p>Once installed, let&#x27;s run our project to see if everything is working fine by executing the command below:</p>
<pre><code class="hljs language-bash"><span class="hljs-built_in">cd</span> react-typescript-accordion
yarn start
</code></pre>
<p>This command will open your default browser and go to <code>http://localhost:3000/</code>. If it doesn&#x27;t, you can do it yourself too.</p>
<p>This setup comes with live-editing or hot reloading which means when we save file changes, it will automatically update the app and reload on the browser. That&#x27;s great for local development!</p>
<div><ins class="adsbygoogle mx-auto block max-w-[1200px] adUnit_adunit__uTSk1" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<h2>Clean up the project</h2>
<p>Now, let&#x27;s clean up our project which was created by Create React App. We won&#x27;t be needing some of them. Delete or clear the contents of the following below:</p>
<ul>
<li>src/App.css (clear contents)</li>
<li>src/App.test.tsx (delete)</li>
<li>src/logo.svg (delete)</li>
</ul>
<p>Then let&#x27;s update the code of <code>src/App.tsx</code>:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;
</code></pre>
<p>We will use the <code>App</code> component as the container of our accordion. So just a small update on the <code>src/App.css</code>:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.container</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;
  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span> <span class="hljs-number">15px</span>;
}
</code></pre>
<p>And update the <code>src/index.css</code> too:</p>
<pre><code class="hljs language-css">* {
  <span class="hljs-attribute">box-sizing</span>: border-box;
}

<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">font-family</span>: -apple-system, BlinkMacSystemFont, <span class="hljs-string">&#x27;Segoe UI&#x27;</span>, <span class="hljs-string">&#x27;Roboto&#x27;</span>,
    <span class="hljs-string">&#x27;Oxygen&#x27;</span>, <span class="hljs-string">&#x27;Ubuntu&#x27;</span>, <span class="hljs-string">&#x27;Cantarell&#x27;</span>, <span class="hljs-string">&#x27;Fira Sans&#x27;</span>, <span class="hljs-string">&#x27;Droid Sans&#x27;</span>,
    <span class="hljs-string">&#x27;Helvetica Neue&#x27;</span>, sans-serif;
  -webkit-<span class="hljs-attribute">font-smoothing</span>: antialiased;
  -moz-osx-<span class="hljs-attribute">font-smoothing</span>: grayscale;
  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.6</span>;
}
</code></pre>
<div><ins class="adsbygoogle mx-auto block max-w-[1200px] adUnit_adunit__uTSk1" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<h2>Sample data + Accordion component</h2>
<p>Now, let&#x27;s create sample data that we can pass to our accordion component because we would want our accordion to be reusable, so it should accept data as props. We can initialize the data from a parent component so for our case, it would be <code>src/App.tsx</code>. I have a sample data that we can use here, update the code of it:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span>;
<span class="hljs-keyword">import</span> Accordion <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Accordion&#x27;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> accordionItems = [
    {
      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Accordion Item #1&#x27;</span>,
      <span class="hljs-attr">content</span>: (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>This is the first item&#x27;s accordion body.<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> It is hidden
          by default, but shown when the title is clicked. It will also be
          hidden if the title is clicked again or when another item is clicked.
          You can pass HTML tags in the content such as <span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>underline tag<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span>,{&#x27; &#x27;}
          <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>, or even another list like this:
          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bread<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Eggs<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
      ),
    },
    {
      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Accordion Item #2&#x27;</span>,
      <span class="hljs-attr">content</span>: (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>This is the second item&#x27;s accordion body.<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> It is
          hidden by default, but shown when the title is clicked. It will also
          be hidden if the title is clicked again or when another item is
          clicked. You can pass HTML tags in the content such as{&#x27; &#x27;}
          <span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>underline tag<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>, or even another list like this:
          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bread<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Eggs<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
      ),
    },
    {
      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Accordion Item #3&#x27;</span>,
      <span class="hljs-attr">content</span>: (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>This is the third item&#x27;s accordion body.<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> It is hidden
          by default, but shown when the title is clicked. It will also be
          hidden if the title is clicked again or when another item is clicked.
          You can pass HTML tags in the content such as <span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>underline tag<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span>,{&#x27; &#x27;}
          <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>, or even another list like this:
          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bread<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Eggs<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
      ),
    },
  ];

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Accordion</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{accordionItems}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;
</code></pre>
<p>If you save the changes we would get errors in the meantime as we would still need to create the <code>Accordion</code> component. So create a folder under <code>src</code> and name it <code>components</code>. We can put our reusable components in this folder. After that, create a file named <code>Accordion.tsx</code> inside the <code>components</code> folder.</p>
<div><ins class="adsbygoogle mx-auto block max-w-[1200px] adUnit_adunit__uTSk1" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<p>Then, let&#x27;s add the code for <code>src/components/Accordion.tsx</code>:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> { AccordionData } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../types&#x27;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Accordion</span>(<span class="hljs-params">{ items }: { items: <span class="hljs-built_in">Array</span>&lt;AccordionData&gt; }</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;accordion&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Accordion;
</code></pre>
<p>If you&#x27;re new to TypeScript, the object besides the props will look foreign to you. It would be explained better once we do the remaining change. For now, create a new file <code>types.ts</code> inside the <code>src</code> folder and add the following code to it:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { ReactNode } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> AccordionData = {
  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;
  content: ReactNode;
};
</code></pre>
<p>Now comes the explanation part for those of you who are new to TypeScript, feel free to skip this if you are already familiar with it. So we are defining the type for the <code>items</code> props that our <code>Accordion</code> component will accept. So we declared a <code>type AccordionData</code> which is an <code>object</code> that contains <code>title</code> that should only be a <code>string</code>, one of the <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html">primitive types</a> in TypeScript, and <code>content</code> that should only be a <code>ReactNode</code>, a type defined by <code>React</code> library, same thing we did when we defined our type <code>AccordionData</code>. We can hover to a non-primitive type and it will show a tooltip with more information about the type like this:</p>
<img src="/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/hovering-type-in-visual-studio-code.png" alt="Screenshot of hovering a type in Visual Studio Code" loading="lazy"/>
<p>You can also <code>Cmd</code> + <code>click</code> (<code>Ctrl</code> + <code>click</code> on Windows) to view the type with even more information.</p>
<img src="/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/checking-type-in-visual-studio-code.png" alt="Screenshot of checking a type in Visual Studio Code" loading="lazy"/>
<p>So we created <code>src/types.ts</code> so that it can be exported and imported across different components which you will see in a bit. Since the <code>Accordion</code> component accepts an array of <code>AccordionData</code>, we wrapped it in type <code>Array</code> like this - <code>Array&lt;AccordionData&gt;</code>. You can also wrap it like this - <code>AccordionData[]</code>, I just prefer the former as I can read it as an &quot;array of accordion data&quot;.</p>
<p>Now if we didn&#x27;t pass the expected data or type for <code>items</code> props to our accordion component, our IDE would display an inline error and hovering it would show something like this:</p>
<img src="/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/inline-error-by-typescript-in-visual-studio-code.png" alt="Screenshot of inline error by TypeScript in Visual Studio Code" loading="lazy"/>
<p>This is why TypeScript is really helpful for catching errors early while you&#x27;re still writing the code.</p>
<div><ins class="adsbygoogle mx-auto block max-w-[1200px] adUnit_adunit__uTSk1" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<h2>Accordion Item component</h2>
<p>Alright, let&#x27;s create a new component under <code>components</code> and name it <code>AccordionItem.tsx</code>. This will be the component used by each item in our accordion. Add the following code below to display both the title and content of each item:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> { AccordionData } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../types&#x27;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AccordionItem</span>(<span class="hljs-params">{ data }: { data: AccordionData }</span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;accordion-item&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;accordion-item-title&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;accordion-item-btn&quot;</span>&gt;</span>{data.title}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;accordion-item-container&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;accordion-item-content&quot;</span>&gt;</span>{data.content}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> AccordionItem;
</code></pre>
<p>As you can see here, we&#x27;ve also added a type for <code>data</code> which should only be <code>AccordionData</code>, this is where we reused the type we declared and exported earlier in <code>src/types.ts</code>.</p>
<p>Now let&#x27;s go back to <code>src/components/Accordion.tsx</code> and update the code to loop through the items and pass the data to the imported <code>AccordionItem</code> component:</p>
<pre><code class="hljs language-tsx">...
<span class="hljs-keyword">import</span> AccordionItem <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./AccordionItem&#x27;</span>;
...
    &lt;ul className=<span class="hljs-string">&quot;accordion&quot;</span>&gt;
      {items.map(<span class="hljs-function">(<span class="hljs-params">item, idx</span>) =&gt;</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AccordionItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{idx}</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{item}</span> /&gt;</span></span>
      ))}
    &lt;/ul&gt;
...
</code></pre>
<p>Once you save the changes, our web app should be working fine now without any errors and display something like this:</p>
<img src="/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-partial-unstyled.png" alt="Screenshot of accordion partially built in React and TypeScript" loading="lazy"/>
<div><ins class="adsbygoogle mx-auto block max-w-[1200px] adUnit_adunit__uTSk1" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<h2>Accordion styles</h2>
<p>Yes, it doesn&#x27;t look like an accordion yet. So let&#x27;s create the styles and import them to their respective components. Create <code>Accordion.css</code> under <code>components</code> folder and add the following code below:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.accordion</span> {
  <span class="hljs-attribute">list-style</span>: none;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
}
</code></pre>
<p>Then import it in <code>Accordion.tsx</code>:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> { AccordionData } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../types&#x27;</span>;
<span class="hljs-keyword">import</span> AccordionItem <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./AccordionItem&#x27;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./Accordion.css&#x27;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Accordion</span>(<span class="hljs-params">{ items }: { items: <span class="hljs-built_in">Array</span>&lt;AccordionData&gt; }</span>) </span>{
...
</code></pre>
<p>Next, create <code>AccordionItem.css</code> under <code>components</code> folder and add the following code below:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.accordion-item</span> {
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;
}

<span class="hljs-selector-class">.accordion-item</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-pseudo">:first</span>-of-type) {
  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">0</span>;
}

<span class="hljs-selector-class">.accordion-item-title</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
}

<span class="hljs-selector-class">.accordion-item-btn</span> {
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">align-items</span>: center;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span> <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;
  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">400</span>;
  <span class="hljs-attribute">cursor</span>: pointer;
  user-select: none;
}

<span class="hljs-selector-class">.accordion-item-btn</span><span class="hljs-selector-pseudo">::after</span> {
  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;
  <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">18px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">18px</span>;
  <span class="hljs-attribute">margin-left</span>: auto;
  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;data:image/svg+xml,%3csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 16 16&#x27; fill=&#x27;%23212529&#x27;%3e%3cpath fill-rule=&#x27;evenodd&#x27; d=&#x27;M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z&#x27;/%3e%3c/svg%3e&quot;</span>);
  <span class="hljs-attribute">background-repeat</span>: no-repeat;
  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">18px</span>;
  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.2s</span> ease-in-out;
}

<span class="hljs-selector-class">.accordion-item</span><span class="hljs-selector-class">.active</span> <span class="hljs-selector-class">.accordion-item-btn</span><span class="hljs-selector-pseudo">::after</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(-<span class="hljs-number">180deg</span>);
}

<span class="hljs-selector-class">.accordion-item-container</span> {
  <span class="hljs-attribute">transition</span>: height <span class="hljs-number">0.2s</span> ease-in-out;
  <span class="hljs-attribute">overflow</span>: hidden;
}

<span class="hljs-selector-class">.accordion-item-content</span> {
  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#cccccc</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span> <span class="hljs-number">20px</span>;
}
</code></pre>
<p>And import it in <code>AccordionItem.tsx</code>:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> { AccordionData } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../types&#x27;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./AccordionItem.css&#x27;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AccordionItem</span>(<span class="hljs-params">{ data }: { data: AccordionData }</span>) </span>{
...
</code></pre>
<p>Once you saved the changes, our component should look like this now:</p>
<img src="/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-partial-styled.png" alt="Screenshot of accordion partially built in React and TypeScript" loading="lazy"/>
<div><ins class="adsbygoogle mx-auto block max-w-[1200px] adUnit_adunit__uTSk1" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<h2>Accordion Item props</h2>
<p>That&#x27;s looking like an accordion now. We just need to make it collapsible. Let&#x27;s start with the logic for <code>AccordionItem.tsx</code>. It should accept a prop <code>isOpen</code> to determine whether to display the content or not. We can simply use a conditional statement like this:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> { AccordionData } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../types&#x27;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./AccordionItem.css&#x27;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AccordionItem</span>(<span class="hljs-params">{
  data,
  isOpen,
}: {
  data: AccordionData;
  isOpen: <span class="hljs-built_in">boolean</span>;
}</span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;accordion-item&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;accordion-item-title&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;accordion-item-btn&quot;</span>&gt;</span>{data.title}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;accordion-item-container&quot;</span>&gt;</span>
        {isOpen &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;accordion-item-content&quot;</span>&gt;</span>{data.content}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> AccordionItem;
</code></pre>
<p>And we would be done with this component but because we want it to have a transition, then we need to be more creative here. What can we use then? Yes, you&#x27;ve guessed it! We can control the height of the content&#x27;s container. If <code>isOpen</code> is <code>false</code>, then we set the height of the container to <code>0</code>, and if it&#x27;s <code>true</code>, then we set the height using the content&#x27;s height. Since <code>isOpen</code> can change at any point of time, we can use one of the React hooks, <code>useEffect</code>, to help us with this accordion logic. Let&#x27;s update the code of <code>AccordionItem.tsx</code>:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> { useEffect, useRef, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> { AccordionData } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../types&#x27;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./AccordionItem.css&#x27;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AccordionItem</span>(<span class="hljs-params">{
  data,
  isOpen,
  btnOnClick,
}: {
  data: AccordionData;
  isOpen: <span class="hljs-built_in">boolean</span>;
  btnOnClick: () =&gt; <span class="hljs-built_in">void</span>;
}</span>) </span>{
  <span class="hljs-keyword">const</span> contentRef = useRef&lt;HTMLDivElement&gt;(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [height, setHeight] = useState(<span class="hljs-number">0</span>);

  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (isOpen) {
      <span class="hljs-keyword">const</span> contentEl = contentRef.current <span class="hljs-keyword">as</span> HTMLDivElement;

      setHeight(contentEl.scrollHeight);
    } <span class="hljs-keyword">else</span> {
      setHeight(<span class="hljs-number">0</span>);
    }
  }, [isOpen]);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">accordion-item</span> ${<span class="hljs-attr">isOpen</span> ? &#x27;<span class="hljs-attr">active</span>&#x27; <span class="hljs-attr">:</span> &#x27;&#x27;}`}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;accordion-item-title&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;accordion-item-btn&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{btnOnClick}</span>&gt;</span>
          {data.title}
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;accordion-item-container&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">height</span> }}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{contentRef}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;accordion-item-content&quot;</span>&gt;</span>
          {data.content}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> AccordionItem;
</code></pre>
<p>And if you&#x27;re new to TypeScript, you&#x27;ll notice I used <code>as HTMLDivElement</code> here. This is called a <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions">type assertion</a>. If we remove the type assertion, the type of <code>contentEl.current</code> would be <code>HTMLDivElement | null</code>, but we know in this case it will always have a value of <code>HTMLDivElement</code> when <code>useEffect</code> is executed. That&#x27;s why type assertions are done when you have information about the type of a value that TypeScript can&#x27;t know about.</p>
<p>When <code>isOpen</code> is true, we should also add an <code>active</code> class so that the icon would rotate, it&#x27;s a common transition effect whenever you toggle an accordion.</p>
<p>I&#x27;ve also added a new prop <code>btnOnClick</code> which accepts a callback when the button is clicked. We&#x27;ll use this later to control when to display or hide our content from the parent component.</p>
<div><ins class="adsbygoogle mx-auto block max-w-[1200px] adUnit_adunit__uTSk1" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<h2>Accordion logic (open one at a time)</h2>
<p>Moving on to the <code>Accordion.tsx</code>, this is where we&#x27;ll be adding the logic for each accordion item. When an accordion button is clicked, then we should show the contents. We could store a state of which item is displayed, it should be something unique to that item, since our items don&#x27;t have an identifier (or ID) in their data, we could use the <code>index</code> of each item. I could think of two ways an accordion behaves, the one that we&#x27;ll do in this post (which is my favorite by the way!) is opening an accordion one at a time, meaning when there&#x27;s an accordion that&#x27;s currently opened, when I click another one, it will close or hide the previous one and display the content of what I last clicked upon. To do that logic, update the <code>Accordion</code> component with the following code below:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> { AccordionData } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../types&#x27;</span>;
<span class="hljs-keyword">import</span> AccordionItem <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./AccordionItem&#x27;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./Accordion.css&#x27;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Accordion</span>(<span class="hljs-params">{ items }: { items: <span class="hljs-built_in">Array</span>&lt;AccordionData&gt; }</span>) </span>{
  <span class="hljs-keyword">const</span> [currentIdx, setCurrentIdx] = useState(-<span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> btnOnClick = <span class="hljs-function">(<span class="hljs-params">idx: <span class="hljs-built_in">number</span></span>) =&gt;</span> {
    setCurrentIdx(idx);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;accordion&quot;</span>&gt;</span>
      {items.map((item, idx) =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">AccordionItem</span>
          <span class="hljs-attr">key</span>=<span class="hljs-string">{idx}</span>
          <span class="hljs-attr">data</span>=<span class="hljs-string">{item}</span>
          <span class="hljs-attr">isOpen</span>=<span class="hljs-string">{idx</span> === <span class="hljs-string">currentIdx}</span>
          <span class="hljs-attr">btnOnClick</span>=<span class="hljs-string">{()</span> =&gt;</span> btnOnClick(idx)}
        /&gt;
      ))}
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Accordion;
</code></pre>
<p>The initial state value of <code>currentIdx</code> (current index) would be <code>-1</code>, which means no accordion would be open at the start. When an accordion button is clicked, we would set the <code>currentIdx</code> to that accordion&#x27;s index. This makes the <code>isOpen</code> become true since <code>idx</code> and <code>currentIdx</code> values are equal.</p>
<p>Once you save the changes, you now have yourself an accordion!</p>
<img src="/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-open-one-at-a-time.png" alt="Screenshot of accordion with one opened in React and TypeScript" loading="lazy"/>
<p>But wait there&#x27;s one last thing you need to do. If we click on the same accordion again, it still remains open, ideally it should close. So let&#x27;s do a small update to the code:</p>
<pre><code class="hljs language-tsx">...
  <span class="hljs-keyword">const</span> btnOnClick = <span class="hljs-function">(<span class="hljs-params">idx: <span class="hljs-built_in">number</span></span>) =&gt;</span> {
    setCurrentIdx(<span class="hljs-function">(<span class="hljs-params">currentValue</span>) =&gt;</span> (currentValue !== idx ? idx : -<span class="hljs-number">1</span>));
  };
...
</code></pre>
<p>And there you go, you&#x27;ve just built your own accordion in React and TypeScript!</p>
<div><ins class="adsbygoogle mx-auto block max-w-[1200px] adUnit_adunit__uTSk1" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<h2>Write tests for Accordion.tsx</h2>
<p>Alright, time to write tests for the components we&#x27;ve built. Tests are really great as it helps us cover all the logics in our code and whenever we update the codebase, they help us determine whether we broke anything before the changes get pushed to our repository.</p>
<p>Before we start, let&#x27;s install a library called <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/Marak/faker.js">faker</a> which gives us random data. Why do we want random data? It makes our tests more reliable as opposed to hardcoding the data we use in testing. Run the command below on your terminal to install it along with its type:</p>
<pre><code class="hljs language-bash">yarn add faker@5.5.3 @types/faker@5.5.9
</code></pre>
<p>Since our project uses TypeScript, when installing libraries, we would have to install their types as well, because if not TypeScript would display an error that it couldn&#x27;t find the library&#x27;s type declarations.</p>
<p>That&#x27;s all we need to install because the Create React App already set up and installed the necessary libraries for our testing environment such as Jest and Testing Library.</p>
<p>For test files, I like to separate them in a folder so that it&#x27;s less cluttered when viewing main files. Now, create a new folder named <code>__tests__</code> under the <code>src/components</code>. This is where we will put the test files for components under <code>src/components</code>.</p>
<p>Alright, the first component we would be writing tests for is <code>Accordion.tsx</code>. Create a file under <code>src/components/__tests__</code> and name it <code>Accordion.test.tsx</code>.</p>
<p>Then let&#x27;s add in the structure of the test:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> Accordion <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../Accordion&#x27;</span>;

describe(<span class="hljs-string">&#x27;&lt;Accordion /&gt;&#x27;</span>, <span class="hljs-function">() =&gt;</span> {});
</code></pre>
<p><code>describe</code> creates a block that groups together several related tests. So ideally the description should be describing what we are testing, for this case I used the component name. Feel free to rename it according to your preference. <code>describe</code> is one of Jest&#x27;s global functions, so with the setup of Create React App, we don&#x27;t need to specifically import these global functions in our code, we can just directly use them.</p>
<p>Next we can add a test case inside the <code>describe</code> block:</p>
<pre><code class="hljs language-tsx">describe(<span class="hljs-string">&#x27;&lt;Accordion /&gt;&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  it(<span class="hljs-string">&#x27;should render items&#x27;</span>, <span class="hljs-function">() =&gt;</span> {});
});
</code></pre>
<p>Another global function by Jest, <code>it</code> (or <code>test</code>) method runs a test. This is where we can have different test cases. Let&#x27;s write our first test case:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> { render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span>;
<span class="hljs-keyword">import</span> faker <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;faker&#x27;</span>;
<span class="hljs-keyword">import</span> Accordion <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../Accordion&#x27;</span>;

describe(<span class="hljs-string">&#x27;&lt;Accordion /&gt;&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  it(<span class="hljs-string">&#x27;should render items&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> items = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
      items.push({
        <span class="hljs-attr">title</span>: faker.lorem.sentence(),
        <span class="hljs-attr">content</span>: faker.lorem.sentences(),
      });
    }

    render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Accordion</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span> /&gt;</span></span>);

    items.forEach(<span class="hljs-function">(<span class="hljs-params">{ title, content }</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> titleEl = screen.queryByText(title);
      <span class="hljs-keyword">const</span> contentEl = screen.queryByText(content);

      expect(titleEl).toBeInTheDocument();
      expect(contentEl).toBeInTheDocument();
    });
  });
});
</code></pre>
<p>That&#x27;s a lot of new code! Don&#x27;t worry, let me go through it one by one and explain it to you. So first, we created an <code>items</code> array which would contain an object of <code>AccordionData</code>. We are using <code>faker</code> library to help us generate random titles and content. You can check out their API <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/marak/faker.js#api">here</a> to know all the other data it can randomly generate. We&#x27;ve added three items which should be enough but you can increase or decrease it if you want, but do note that it should have at least two items in order to test our accordion logic. We then pass this array as a props to our <code>Accordion</code> component. Using one of the Testing Library&#x27;s methods, <code>render</code>, helps to render our component in a test environment, do note this environment is not a browser, so there are some limitations and mockings we would have to do which you&#x27;ll see later on. To learn more about the <code>render</code> method, you can go <a target="_blank" rel="noopener noreferrer nofollow" href="https://testing-library.com/docs/react-testing-library/api/#render">here</a>. After that, we can do our checks to validate that our items are rendered. To do that, we looped through the items and did a query by text using another method of Testing Library which is <code>screen.queryByText</code>. To know all the possible queries you can do with the <code>screen</code> object, you can go <a target="_blank" rel="noopener noreferrer nofollow" href="https://testing-library.com/docs/queries/about">here</a>. Then finally using one of Jest&#x27;s global functions, we can call <code>expect</code> method and pass the elements returned by the query, and run what we call a matcher method <code>toBeInTheDocument()</code>. This is one of many custom matcher methods provided by the library called <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/testing-library/jest-dom#custom-matchers">jest-dom</a> which are specific to the <a target="_blank" rel="noopener noreferrer nofollow" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction">DOM</a>. While you can check this <a target="_blank" rel="noopener noreferrer nofollow" href="https://jestjs.io/docs/expect">documentation</a> for the more generic matcher methods.</p>
<p>Alright, I hoped that explained it.</p>
<div><ins class="adsbygoogle mx-auto block max-w-[1200px] adUnit_adunit__uTSk1" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<p>Now let&#x27;s check if our component passed the test by running the command below in your terminal:</p>
<pre><code class="hljs language-bash">yarn <span class="hljs-built_in">test</span> --coverage
</code></pre>
<p>The parameter <code>--coverage</code> helps to display the coverage of the tests in which you&#x27;ll see in your terminal:</p>
<img src="/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-test-coverage-incomplete-1.png" alt="Screenshot of incomplete Accordion test coverage" loading="lazy"/>
<p>Our first test case passed! We also managed to cover 66.67% of lines of <code>Accordion.tsx</code>. With the <code>--coverage</code> parameter, it gives us hints of which lines are uncovered as well, that is line 9 and 19. If we check those lines in our <code>Accordion.tsx</code> file, these are related to the logic of opening an accordion item. So let&#x27;s create the second test case:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> { fireEvent, render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span>;
...
  it(<span class="hljs-string">&#x27;should open one at a time&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> items = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
      items.push({
        <span class="hljs-attr">title</span>: faker.lorem.sentence(),
        <span class="hljs-attr">content</span>: faker.lorem.sentences(),
      });
    }

    render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Accordion</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span> /&gt;</span></span>);

    items.forEach(<span class="hljs-function">(<span class="hljs-params">{ title }</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> titleEl = screen.queryByText(title) <span class="hljs-keyword">as</span> HTMLButtonElement;

      fireEvent.click(titleEl);

      <span class="hljs-keyword">const</span> currentListEl = titleEl.closest(<span class="hljs-string">&#x27;li&#x27;</span>);
      <span class="hljs-keyword">const</span> activeListEls = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;li.active&#x27;</span>);
      <span class="hljs-keyword">const</span> activeListEl = activeListEls[<span class="hljs-number">0</span>];

      expect(activeListEls.length).toBe(<span class="hljs-number">1</span>);
      expect(activeListEl).toEqual(currentListEl);
    });
  });
});
</code></pre>
<p>Here we did the same for generating random data for the props but inside the loop we&#x27;re doing the checks differently. So first we query the element of the title and fire a click event on it using <code>fireEvent</code> which is imported from the Testing Library. To fire other DOM events, you can check out the documentation <a target="_blank" rel="noopener noreferrer nofollow" href="https://testing-library.com/docs/dom-testing-library/api-events/">here</a>. Any query of an element may result as <code>null</code> so we added a type assertion (<code>as HTMLButtonElement</code>) because <code>fireEvent</code> method doesn&#x27;t accept <code>null</code> values, it is safe to use type assertion here because we are certain that the element is or should be in the DOM. Then we queried the list element with an <code>active</code> class and checked whether it is the same element as the current item&#x27;s list element, this verifies that our current item is opened. We also did an additional check to make sure that there&#x27;s only one accordion that is opened at a time (or per loop) by checking that the length of all list items that has an <code>active</code> class should only be <code>1</code>.</p>
<p>Currently if you didn&#x27;t stop the test script server, it will listen for file save changes and automatically run the tests again. This makes writing tests faster as we don&#x27;t have to re-run the test script again on every change. Our test coverage should look like this now:</p>
<img src="/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-test-coverage-incomplete-2.png" alt="Screenshot of incomplete Accordion test coverage" loading="lazy"/>
<p>Awesome, our second test case passed as well! But line 9 is still uncovered though. If we check that line in our file, it is the logic for closing an opened accordion if the title is clicked again. So for the last test case, we can achieve the full coverage for <code>Accordion.tsx</code> by writing the code below:</p>
<pre><code class="hljs language-tsx">...
  it(<span class="hljs-string">&#x27;should close if already opened&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> items = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
      items.push({
        <span class="hljs-attr">title</span>: faker.lorem.sentence(),
        <span class="hljs-attr">content</span>: faker.lorem.sentences(),
      });
    }

    render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Accordion</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span> /&gt;</span></span>);

    items.forEach(<span class="hljs-function">(<span class="hljs-params">{ title }</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> titleEl = screen.queryByText(title) <span class="hljs-keyword">as</span> HTMLButtonElement;

      fireEvent.click(titleEl);
      fireEvent.click(titleEl);

      <span class="hljs-keyword">const</span> currentListEl = titleEl.closest(<span class="hljs-string">&#x27;li&#x27;</span>);

      expect(currentListEl).not.toHaveClass(<span class="hljs-string">&#x27;active&#x27;</span>);
    });
  });
});
</code></pre>
<p>Here we fire two click events and check that the current item&#x27;s list element does not contain an <code>active</code> class which is a determinator that the accordion is opened.</p>
<p>Now once we save the changes, our coverage should look like this:</p>
<img src="/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-test-coverage-complete.png" alt="Screenshot of complete Accordion test coverage" loading="lazy"/>
<p>Cool! If you look at <code>AccordionItem.tsx</code> it already has <code>100%</code> coverage as well. That&#x27;s because it is also used in <code>Accordion.tsx</code> test cases. But it&#x27;s always good to have each component or function to have its own test cases as well, because that will make our code more robust.</p>
<div><ins class="adsbygoogle mx-auto block max-w-[1200px] adUnit_adunit__uTSk1" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<h2>Write tests for AccordionItem.tsx</h2>
<p>Create a file under <code>src/components/__tests__</code> and name it <code>AccordionItem.test.tsx</code>. If we want to see how much is covered in <code>AccordionItem.tsx</code> while we write tests for it and ignore <code>Accordion.test.tsx</code> test cases from running, we can do so by running the test script like this:</p>
<pre><code class="hljs language-bash">yarn <span class="hljs-built_in">test</span> --coverage src/components/__tests__/AccordionItem.test.tsx
</code></pre>
<p>This instructs Jest to only run the tests under <code>src/components/__tests__/AccordionItem.test.tsx</code>. For now it would fail because it must contain at least one test. So let&#x27;s write the first test case:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> { render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span>;
<span class="hljs-keyword">import</span> faker <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;faker&#x27;</span>;
<span class="hljs-keyword">import</span> AccordionItem <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../AccordionItem&#x27;</span>;

describe(<span class="hljs-string">&#x27;&lt;AccordionItem /&gt;&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  it(<span class="hljs-string">&#x27;should render content&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> title = faker.lorem.sentence();
    <span class="hljs-keyword">const</span> content = faker.lorem.sentences();

    render(
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AccordionItem</span>
        <span class="hljs-attr">data</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">title</span>, <span class="hljs-attr">content</span> }}
        <span class="hljs-attr">isOpen</span>=<span class="hljs-string">{faker.datatype.boolean()}</span>
        <span class="hljs-attr">btnOnClick</span>=<span class="hljs-string">{jest.fn()}</span>
      /&gt;</span></span>
    );

    <span class="hljs-keyword">const</span> titleEl = screen.queryByText(title);
    <span class="hljs-keyword">const</span> contentEl = screen.queryByText(content);

    expect(titleEl).toBeInTheDocument();
    expect(contentEl).toBeInTheDocument();
  });
});
</code></pre>
<p>These should look familiar to you as we did the same for our first test case in <code>Accordion.test.tsx</code> but here we didn&#x27;t have to create an array of data and loop through the items to do the checks.</p>
<p>After saving the changes, the terminal should display this:</p>
<img src="/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-item-test-coverage-incomplete.png" alt="Screenshot of incomplete Accordion Item test coverage" loading="lazy"/>
<div><ins class="adsbygoogle mx-auto block max-w-[1200px] adUnit_adunit__uTSk1" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<p>Here, the uncovered lines for <code>AccordionItem.tsx</code> is 19-21, but it could be line 23 on your side because we are passing a random <code>boolean</code> for <code>isOpen</code> props in our first test case. So let&#x27;s create two new test cases, one for when <code>isOpen</code> is <code>false</code> and one for when <code>isOpen</code> is <code>true</code> and we can validate whether the accordion is open or not by checking if there is an <code>active</code> class in the list element or not. Write the following code below:</p>
<pre><code class="hljs language-tsx">...
  it(<span class="hljs-string">&#x27;should not display content if isOpen is false&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> title = faker.lorem.sentence();
    <span class="hljs-keyword">const</span> content = faker.lorem.sentences();

    render(
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AccordionItem</span>
        <span class="hljs-attr">data</span>=<span class="hljs-string">{{</span>
          <span class="hljs-attr">title</span>,
          <span class="hljs-attr">content</span>,
        }}
        <span class="hljs-attr">isOpen</span>=<span class="hljs-string">{false}</span>
        <span class="hljs-attr">btnOnClick</span>=<span class="hljs-string">{jest.fn()}</span>
      /&gt;</span></span>
    );

    <span class="hljs-keyword">const</span> titleEl = screen.queryByText(title);
    <span class="hljs-keyword">const</span> listEl = titleEl?.closest(<span class="hljs-string">&#x27;li&#x27;</span>);

    expect(listEl).not.toHaveClass(<span class="hljs-string">&#x27;active&#x27;</span>);
  });

  it(<span class="hljs-string">&#x27;should display content if isOpen is true&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> title = faker.lorem.sentence();
    <span class="hljs-keyword">const</span> content = faker.lorem.sentences();

    render(
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AccordionItem</span>
        <span class="hljs-attr">data</span>=<span class="hljs-string">{{</span>
          <span class="hljs-attr">title</span>,
          <span class="hljs-attr">content</span>,
        }}
        <span class="hljs-attr">isOpen</span>=<span class="hljs-string">{true}</span>
        <span class="hljs-attr">btnOnClick</span>=<span class="hljs-string">{jest.fn()}</span>
      /&gt;</span></span>
    );

    <span class="hljs-keyword">const</span> titleEl = screen.queryByText(title);
    <span class="hljs-keyword">const</span> listEl = titleEl?.closest(<span class="hljs-string">&#x27;li&#x27;</span>);

    expect(listEl).toHaveClass(<span class="hljs-string">&#x27;active&#x27;</span>);
  });
});
</code></pre>
<p>Once changes are saved, we would achieve <code>100%</code> test coverage for <code>AccordionItem.test.tsx</code>:</p>
<img src="/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-item-test-coverage-complete-1.png" alt="Screenshot of complete Accordion Item test coverage" loading="lazy"/>
<p>You may be wondering, <code>active</code> class just adds the style to rotate the arrow icon but is not really responsible for displaying or hiding the content. That is actually based on the <code>height</code> of the container. Can we test that too? Yes, but we will need to update our existing code in <code>AccordionItem.tsx</code> because in a test environment, values like <code>scrollHeight</code> is always <code>0</code> because it does not update measurements like a browser, this is the limitation that I&#x27;ve mentioned earlier. If that&#x27;s the case, our test case for checking that the height is more than <code>0</code> when <code>isOpen</code> is <code>true</code> would fail. So what should we do?</p>
<p>First, create a folder named <code>lib</code> under the <code>src</code> folder. Then create a file under <code>src/lib</code> and name it <code>hooks.ts</code>. Add the following code inside the newly created file:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { RefObject } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRefValue</span>&lt;<span class="hljs-title">C</span>&gt;(<span class="hljs-params">ref: RefObject&lt;C&gt;</span>) </span>{
  <span class="hljs-keyword">return</span> ref.current <span class="hljs-keyword">as</span> C;
}
</code></pre>
<p>This is a utility for getting the value of a <code>RefObject</code>. I use this a lot in my projects and it is extremely helpful when writing tests to achieve <code>100%</code> coverage, especially those components that use <code>RefObject</code> for elements. If you&#x27;re new to TypeScript, you might be wondering what is this <code>C</code> around the code? It can be any letter by the way or word if you would like, and it is called <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.typescriptlang.org/docs/handbook/2/generics.html">Generics</a>, it makes our utility function here accept the type defined when the <code>RefObject</code> is passed because it can have any type. Using Generics, our function here would be able to return the same type.</p>
<div><ins class="adsbygoogle mx-auto block max-w-[1200px] adUnit_adunit__uTSk1" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<p>Then let&#x27;s update our <code>AccordionItem.tsx</code>:</p>
<pre><code class="hljs language-tsx">...
<span class="hljs-keyword">import</span> { getRefValue } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../lib/hooks&#x27;</span>;
...
      <span class="hljs-keyword">const</span> contentEl = getRefValue(contentRef);
</code></pre>
<p>Now back to our test file <code>src/components/__tests__/AccordionItem.test.tsx</code>, let&#x27;s update our two test cases and add the additional checks:</p>
<pre><code class="hljs language-tsx">...
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> hooks <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../lib/hooks&#x27;</span>;
...
describe(<span class="hljs-string">&#x27;&lt;AccordionItem /&gt;&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  beforeEach(<span class="hljs-function">() =&gt;</span> {
    jest.restoreAllMocks();
  });
  ...
  it(<span class="hljs-string">&#x27;should not display content if isOpen is false&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> contentScrollHeight = faker.datatype.number({ <span class="hljs-attr">min</span>: <span class="hljs-number">1</span> });

    jest.spyOn(hooks, <span class="hljs-string">&#x27;getRefValue&#x27;</span>).mockReturnValue({
      <span class="hljs-attr">scrollHeight</span>: contentScrollHeight,
    });

    <span class="hljs-keyword">const</span> title = faker.lorem.sentence();
    <span class="hljs-keyword">const</span> content = faker.lorem.sentences();

    render(
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AccordionItem</span>
        <span class="hljs-attr">data</span>=<span class="hljs-string">{{</span>
          <span class="hljs-attr">title</span>,
          <span class="hljs-attr">content</span>,
        }}
        <span class="hljs-attr">isOpen</span>=<span class="hljs-string">{false}</span>
        <span class="hljs-attr">btnOnClick</span>=<span class="hljs-string">{jest.fn()}</span>
      /&gt;</span></span>
    );

    <span class="hljs-keyword">const</span> titleEl = screen.queryByText(title);
    <span class="hljs-keyword">const</span> listEl = titleEl?.closest(<span class="hljs-string">&#x27;li&#x27;</span>);
    <span class="hljs-keyword">const</span> contentEl = screen.queryByText(content);
    <span class="hljs-keyword">const</span> contentContainerEl = contentEl?.parentElement;

    expect(listEl).not.toHaveClass(<span class="hljs-string">&#x27;active&#x27;</span>);
    expect(contentContainerEl).toHaveStyle({ <span class="hljs-attr">height</span>: <span class="hljs-string">&#x27;0px&#x27;</span> });
  });

  it(<span class="hljs-string">&#x27;should display content if isOpen is true&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> contentScrollHeight = faker.datatype.number({ <span class="hljs-attr">min</span>: <span class="hljs-number">1</span> });

    jest.spyOn(hooks, <span class="hljs-string">&#x27;getRefValue&#x27;</span>).mockReturnValue({
      <span class="hljs-attr">scrollHeight</span>: contentScrollHeight,
    });

    <span class="hljs-keyword">const</span> title = faker.lorem.sentence();
    <span class="hljs-keyword">const</span> content = faker.lorem.sentences();

    render(
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AccordionItem</span>
        <span class="hljs-attr">data</span>=<span class="hljs-string">{{</span>
          <span class="hljs-attr">title</span>,
          <span class="hljs-attr">content</span>,
        }}
        <span class="hljs-attr">isOpen</span>=<span class="hljs-string">{true}</span>
        <span class="hljs-attr">btnOnClick</span>=<span class="hljs-string">{jest.fn()}</span>
      /&gt;</span></span>
    );

    <span class="hljs-keyword">const</span> titleEl = screen.queryByText(title);
    <span class="hljs-keyword">const</span> listEl = titleEl?.closest(<span class="hljs-string">&#x27;li&#x27;</span>);
    <span class="hljs-keyword">const</span> contentEl = screen.queryByText(content);
    <span class="hljs-keyword">const</span> contentContainerEl = contentEl?.parentElement;

    expect(listEl).toHaveClass(<span class="hljs-string">&#x27;active&#x27;</span>);
    expect(contentContainerEl).toHaveStyle({
      <span class="hljs-attr">height</span>: <span class="hljs-string">`<span class="hljs-subst">${contentScrollHeight}</span>px`</span>,
    });
  });
});
</code></pre>
<p>Let&#x27;s analyze the updated code. First, we imported our <code>hooks</code> file using <code>* as hooks</code> in order to get an object of methods from <code>src/lib/hooks.ts</code>. We then use one of Jest&#x27;s methods called <code>jest.spyOn</code> which tracks the calls to <code>object[methodName]</code> that you passed to it. It returns a Jest mock function which we can mock to return a different value using <code>.mockReturnValue()</code>. To see all the mock functions you could do, check them out <a target="_blank" rel="noopener noreferrer nofollow" href="https://jestjs.io/docs/mock-functions">here</a>. When we do mocks in our test cases, it does not get restored back to their original value in the next test case, this might cause potential issues with the next test cases so it&#x27;s good to call <code>jest.restoreAllMocks()</code> to prevent that. Instead of calling this function in the beginning of every test case, we can put the call inside one of Jest&#x27;s methods <code>beforeEach</code>, it accepts a callback which will be called before each test case, and put it inside the <code>describe</code> call back right at the beginning before any test cases.</p>
<p>So we mocked the scroll height of the content element with a random generated number (minimum should be <code>1</code> because <code>0</code> means the content is hidden) and did the checks based on our accordion item logic. If the accordion item is opened, the content element&#x27;s container should have the same height as the scroll height of the content element. If it&#x27;s closed, then the height should be <code>0px</code>.</p>
<p>Now if we check our test results, it should be like this:</p>
<img src="/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-item-test-coverage-complete-2.png" alt="Screenshot of complete Accordion Item test coverage" loading="lazy"/>
<p>Great! Even though it already has <code>100%</code> test coverage, let&#x27;s not forget to test the <code>btnOnClick</code> props, same reason for having each component or function having their own tests, each props you introduce, if logical, should also have their own tests. Similar to what we did in <code>Accordion.test.tsx</code>, we can fire a click event to the title of the accordion item, but in this case our verification would be to check if the function passed in the props was called. To validate that, add the following code below:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> { fireEvent, render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span>;
...
  it(<span class="hljs-string">&#x27;should call btnOnClick on title click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> btnOnClickMock = jest.fn();

    <span class="hljs-keyword">const</span> title = faker.lorem.sentence();
    <span class="hljs-keyword">const</span> content = faker.lorem.sentences();

    render(
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AccordionItem</span>
        <span class="hljs-attr">data</span>=<span class="hljs-string">{{</span>
          <span class="hljs-attr">title</span>,
          <span class="hljs-attr">content</span>,
        }}
        <span class="hljs-attr">isOpen</span>=<span class="hljs-string">{faker.datatype.boolean()}</span>
        <span class="hljs-attr">btnOnClick</span>=<span class="hljs-string">{btnOnClickMock}</span>
      /&gt;</span></span>
    );

    <span class="hljs-keyword">const</span> titleEl = screen.queryByText(title) <span class="hljs-keyword">as</span> HTMLButtonElement;

    fireEvent.click(titleEl);

    expect(btnOnClickMock).toBeCalledTimes(<span class="hljs-number">1</span>);
  });
});
</code></pre>
<div><ins class="adsbygoogle mx-auto block max-w-[1200px] adUnit_adunit__uTSk1" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<h2>Write tests for hooks.ts</h2>
<p>I&#x27;ve mentioned earlier that each component or function we create should have their own tests. So as a bonus, here&#x27;s the test case for the hooks utility we created earlier, the code below should be added inside <code>src/lib/__tests__/hooks.test.ts</code>:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> faker <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;faker&#x27;</span>;
<span class="hljs-keyword">import</span> { getRefValue } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../hooks&#x27;</span>;

describe(<span class="hljs-string">&#x27;hooks utilities&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  describe(<span class="hljs-string">&#x27;getRefValue()&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    it(<span class="hljs-string">&#x27;should return the value&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> refValue = faker.lorem.sentence();
      <span class="hljs-keyword">const</span> refObject = { <span class="hljs-attr">current</span>: refValue };
      <span class="hljs-keyword">const</span> res = getRefValue(refObject);

      expect(res).toBe(refValue);
    });
  });
  a;
});
</code></pre>
<h2>Write tests for App.tsx</h2>
<p>And then here&#x27;s the code for testing our <code>App</code> component under <code>src/__tests__/App.test.tsx</code>:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> { render } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span>;
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App&#x27;</span>;

describe(<span class="hljs-string">&#x27;&lt;App /&gt;&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  it(<span class="hljs-string">&#x27;should render without errors&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> { container } = render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);

    expect(container).toBeInTheDocument();
  });
});
</code></pre>
<div><ins class="adsbygoogle mx-auto block max-w-[1200px] adUnit_adunit__uTSk1" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<p>When you run the all the tests again via <code>yarn test --coverage</code>, it will look very satisfying as the terminal would display all green and all 100% covered:</p>
<img src="/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/test-coverage-complete.png" alt="Screenshot of complete test coverage" loading="lazy"/>
<p>And there you have it! You&#x27;ve just built your own accordion in React and TypeScript with tests! I hope you&#x27;ve learned a lot from this post, especially those who are new to TypeScript and Jest.</p>
<p>In case you need the final code of the accordion as a reference, this is the <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/dominicarrojado/react-typescript-accordion">link</a> to the GitHub repository.</p>
<p>Please don&#x27;t forget to share this post and just a heads up, I&#x27;ll be writing more of these &quot;building your own components in React and TypeScript with tests&quot; so if you&#x27;re interested, you can come back to my blog to check it out once they&#x27;re published.</p></article><div class="mx-auto w-11/12 max-w-screen-3xl lg:w-5/6"><p class="mt-16 text-gray-400">Found an issue with this post?<!-- --> <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/dominicarrojado/dominicarrojado.github.io/issues">Report it here</a>.</p><div class="mt-24 flex items-center justify-between"><a class="group relative pr-2" href="/posts/local-development-setup-for-react-and-typescript-projects/"><div class=""><div class="font-normal transition-colors duration-300 group-hover:text-black motion-reduce:transition-none dark:group-hover:text-white">Local development setup for React and TypeScript projects</div><small class="text-gray-400 transition-colors duration-300 group-hover:text-black motion-reduce:transition-none dark:group-hover:text-white">Previous Post</small></div><svg viewBox="0 0 320 512" role="img" class="absolute bottom-0 top-0 m-auto h-2 w-2 shrink-0 text-black opacity-30 dark:text-white transform transition-transform-opacity duration-300 group-hover:opacity-100 motion-reduce:transition-none sm:h-2.5 sm:w-2.5 md:h-3 md:w-3 xl:h-3.5 xl:w-3.5 -left-5 group-hover:-translate-x-1.5 sm:-left-7 xl:-left-8"><path fill="currentColor" d="M34.52 239.03L228.87 44.69c9.37-9.37 24.57-9.37 33.94 0l22.67 22.67c9.36 9.36 9.37 24.52.04 33.9L131.49 256l154.02 154.75c9.34 9.38 9.32 24.54-.04 33.9l-22.67 22.67c-9.37 9.37-24.57 9.37-33.94 0L34.52 272.97c-9.37-9.37-9.37-24.57 0-33.94z"></path></svg></a><div></div><a class="group relative pl-2" href="/posts/the-turning-point/"><div class="text-right"><div class="font-normal transition-colors duration-300 group-hover:text-black motion-reduce:transition-none dark:group-hover:text-white">The Turning Point</div><small class="text-gray-400 transition-colors duration-300 group-hover:text-black motion-reduce:transition-none dark:group-hover:text-white">Next Post</small></div><svg viewBox="0 0 320 512" role="img" class="absolute bottom-0 top-0 m-auto h-2 w-2 shrink-0 text-black opacity-30 dark:text-white transform transition-transform-opacity duration-300 group-hover:opacity-100 motion-reduce:transition-none sm:h-2.5 sm:w-2.5 md:h-3 md:w-3 xl:h-3.5 xl:w-3.5 -right-5 group-hover:translate-x-1.5 sm:-right-7 xl:-right-8"><path fill="currentColor" d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"></path></svg></a></div><div class="mt-16 text-center"><a class="group inline-flex select-none items-center font-normal dark:hover:text-white transition-colors duration-300 hover:text-black group-hover:text-black motion-reduce:transition-none" href="/posts/">See Latest Posts<svg viewBox="0 0 320 512" role="img" class="ml-2 inline-block h-2 w-2 text-black opacity-30 dark:text-white transform transition duration-300 group-hover:translate-x-1.5 group-hover:opacity-100 motion-reduce:transition-none sm:ml-2.5 sm:h-2.5 sm:w-2.5 md:ml-3 md:h-3 md:w-3 xl:h-3.5 xl:w-3.5"><path fill="currentColor" d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"></path></svg></a></div></div><div class="mx-auto -mb-8 w-11/12 max-w-screen-3xl pt-8 sm:-mb-10 sm:pt-10 md:-mb-12 md:pt-12 lg:w-5/6"><ins class="adsbygoogle mx-auto block max-w-[1200px] adUnit_adunit__uTSk1" data-ad-client="ca-pub-3632473845121107" data-ad-slot="6892691691" data-ad-format="auto" data-full-width-responsive="true" data-testid="ad-unit"></ins></div></section><footer class="overflow-hidden bg-gray-100 px-6 py-20 dark:bg-gray-850 lg:overflow-auto" data-testid="footer"><ul class="relative overflow-hidden text-center motion-reduce:transition-none sm:text-lg xl:text-xl" style="height:0"><li class="absolute left-0 top-0 w-full transition-opacity duration-1000 motion-reduce:transition-none"><blockquote>“<!-- -->If there is no struggle, there is no progress.<!-- -->”</blockquote><p class="mt-1 sm:mt-2">— <!-- -->Frederick Douglass</p></li><li class="absolute left-0 top-0 w-full transition-opacity duration-1000 motion-reduce:transition-none pointer-events-none opacity-0"><blockquote>“<!-- -->It&#x27;s okay to figure out murder mysteries, but you shouldn&#x27;t need to figure out code. You should be able to read it.<!-- -->”</blockquote><p class="mt-1 sm:mt-2">— <!-- -->Steve McConnell</p></li><li class="absolute left-0 top-0 w-full transition-opacity duration-1000 motion-reduce:transition-none pointer-events-none opacity-0"><blockquote>“<!-- -->If you can&#x27;t explain it simply, you don&#x27;t understand it well enough.<!-- -->”</blockquote><p class="mt-1 sm:mt-2">— <!-- -->Albert Einstein</p></li><li class="absolute left-0 top-0 w-full transition-opacity duration-1000 motion-reduce:transition-none pointer-events-none opacity-0"><blockquote>“<!-- -->The secret of getting ahead is getting started.<!-- -->”</blockquote><p class="mt-1 sm:mt-2">— <!-- -->Mark Twain</p></li></ul><ul class="mt-10 flex max-w-full flex-wrap justify-center"><li><a target="_blank" rel="noopener noreferrer nofollow" tabindex="0" href="/donate/" class="group inline-flex cursor-pointer p-3 sm:p-4" aria-label="Show your support and donate!"><svg viewBox="0 0 512 512" role="img" class="w-7 h-7 text-gray-400 dark:text-gray-300 transition-colors group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-white sm:w-8 sm:h-8 xl:w-9 xl:h-9"><path fill="currentColor" d="M256 416c114.9 0 208-93.1 208-208S370.9 0 256 0 48 93.1 48 208s93.1 208 208 208zM233.8 97.4V80.6c0-9.2 7.4-16.6 16.6-16.6h11.1c9.2 0 16.6 7.4 16.6 16.6v17c15.5.8 30.5 6.1 43 15.4 5.6 4.1 6.2 12.3 1.2 17.1L306 145.6c-3.8 3.7-9.5 3.8-14 1-5.4-3.4-11.4-5.1-17.8-5.1h-38.9c-9 0-16.3 8.2-16.3 18.3 0 8.2 5 15.5 12.1 17.6l62.3 18.7c25.7 7.7 43.7 32.4 43.7 60.1 0 34-26.4 61.5-59.1 62.4v16.8c0 9.2-7.4 16.6-16.6 16.6h-11.1c-9.2 0-16.6-7.4-16.6-16.6v-17c-15.5-.8-30.5-6.1-43-15.4-5.6-4.1-6.2-12.3-1.2-17.1l16.3-15.5c3.8-3.7 9.5-3.8 14-1 5.4 3.4 11.4 5.1 17.8 5.1h38.9c9 0 16.3-8.2 16.3-18.3 0-8.2-5-15.5-12.1-17.6l-62.3-18.7c-25.7-7.7-43.7-32.4-43.7-60.1.1-34 26.4-61.5 59.1-62.4zM480 352h-32.5c-19.6 26-44.6 47.7-73 64h63.8c5.3 0 9.6 3.6 9.6 8v16c0 4.4-4.3 8-9.6 8H73.6c-5.3 0-9.6-3.6-9.6-8v-16c0-4.4 4.3-8 9.6-8h63.8c-28.4-16.3-53.3-38-73-64H32c-17.7 0-32 14.3-32 32v96c0 17.7 14.3 32 32 32h448c17.7 0 32-14.3 32-32v-96c0-17.7-14.3-32-32-32z"></path></svg><span id=":R26i6:" style="position:fixed"></span></a></li><li><a target="_blank" rel="noopener noreferrer nofollow" tabindex="0" href="https://www.youtube.com/channel/UCWwV__qrzg5BYCSwO91Xhxg/videos?view=0&amp;sort=dd" class="group inline-flex cursor-pointer p-3 sm:p-4" aria-label="Watch my tech videos!"><svg viewBox="0 0 576 512" role="img" class="w-7 h-7 text-gray-400 dark:text-gray-300 transition-colors group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-white sm:w-8 sm:h-8 xl:w-9 xl:h-9"><path fill="currentColor" d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z"></path></svg><span id=":R2ai6:" style="position:fixed"></span></a></li><li><a target="_blank" rel="noopener noreferrer nofollow" tabindex="0" href="https://www.linkedin.com/in/dominic-arrojado-75ba03a9/" class="group inline-flex cursor-pointer p-3 sm:p-4" aria-label="Let&#x27;s connect on LinkedIn!"><svg viewBox="0 0 448 512" role="img" class="w-7 h-7 text-gray-400 dark:text-gray-300 transition-colors group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-white sm:w-8 sm:h-8 xl:w-9 xl:h-9"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg><span id=":R2ei6:" style="position:fixed"></span></a></li><li><a target="_blank" rel="noopener noreferrer nofollow" tabindex="0" href="https://github.com/dominicarrojado/" class="group inline-flex cursor-pointer p-3 sm:p-4" aria-label="Follow me on GitHub!"><svg viewBox="0 0 496 512" role="img" class="w-7 h-7 text-gray-400 dark:text-gray-300 transition-colors group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-white sm:w-8 sm:h-8 xl:w-9 xl:h-9"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg><span id=":R2ii6:" style="position:fixed"></span></a></li><li><a target="_blank" rel="noopener noreferrer nofollow" tabindex="0" href="mailto:dominicarrojado@gmail.com" class="group inline-flex cursor-pointer p-3 sm:p-4" aria-label="Email me!"><svg viewBox="0 0 512 512" role="img" class="w-7 h-7 text-gray-400 dark:text-gray-300 transition-colors group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-white sm:w-8 sm:h-8 xl:w-9 xl:h-9"><path fill="currentColor" d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path></svg><span id=":R2mi6:" style="position:fixed"></span></a></li></ul><p class="mt-4 text-center text-sm text-gray-400 sm:text-base lg:mt-10 xl:text-lg"><span class="font-normal">©<!-- -->2024<!-- --> <!-- -->Dominic Arrojado</span> <span class="mt-1 block sm:hidden"></span><span class="hidden sm:inline">·</span> <a href="/privacy-policy/">Privacy Policy</a> <!-- -->·<!-- --> <a href="/disclaimer/">Disclaimer</a></p></footer><footer class="fixed bottom-0 z-40 flex w-full items-center justify-end"><div class="absolute bottom-3.5 right-3.5 ml-auto flex items-end gap-3 sm:bottom-4 sm:right-4 md:bottom-5 md:right-5 lg:bottom-8 lg:right-8" style="padding-right:var(--scrollbar-width, 0)"><button data-command="" data-disclosure="" aria-expanded="false" class="group text-gray-400 outline-none dark:text-gray-300 hover:text-gray-500 focus-visible:text-gray-500 dark:hover:text-white dark:focus-visible:text-white" aria-label="Subscribe"><div class="flex flex-col items-center"><div class="relative h-5 w-5 transform transition-transform-opacity-color motion-reduce:transition-none md:h-7 md:w-7 duration-700 -translate-y-2 opacity-0"><svg viewBox="0 0 448 512" role="img" class="absolute inset-0 m-auto"><path fill="currentColor" d="M224 0c-17.7 0-32 14.3-32 32V51.2C119 66 64 130.6 64 208v18.8c0 47-17.3 92.4-48.5 127.6l-7.4 8.3c-8.4 9.4-10.4 22.9-5.3 34.4S19.4 416 32 416H416c12.6 0 24-7.4 29.2-18.9s3.1-25-5.3-34.4l-7.4-8.3C401.3 319.2 384 273.9 384 226.8V208c0-77.4-55-142-128-156.8V32c0-17.7-14.3-32-32-32zm45.3 493.3c12-12 18.7-28.3 18.7-45.3H224 160c0 17 6.7 33.3 18.7 45.3s28.3 18.7 45.3 18.7s33.3-6.7 45.3-18.7z"></path></svg></div><div class="mt-2 select-none text-3xs font-normal uppercase transform transition-transform-opacity-color motion-reduce:transition-none md:text-2xs xl:text-xs duration-700 translate-y-3 opacity-0">Subscribe</div></div></button></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"how-to-create-your-own-accordion-in-react-and-typescript-with-tests","content":"\n## Introduction\n\nAccordions (or collapsible content) are useful for when you have a large amount of content to display and allow users to toggle between showing and hiding the content. This can be seen a lot in different websites today. Learn how to build your own accordion in [React](https://reactjs.org/) and [TypeScript](https://www.typescriptlang.org/). I'll also cover how to write tests for it and achieve 100% coverage using [Jest](https://jestjs.io/) and [Testing Library](https://testing-library.com/), these two libraries are used together to test React components. If you're new to TypeScript and Jest/Testing Library, this is a good way to start learning it with simple components like this. Alright, here we go ~\n\n## Prerequisites\n\nThis is the [link](/react-typescript-accordion/) to the accordion which we'll accomplish by the end of this post, you can see and play around with it or use it as your reference throughout this tutorial.\n\nBy the way, upon writing this post, I assume that you have some web development background and basic knowledge regarding [npm](https://www.npmjs.com/), [yarn](https://classic.yarnpkg.com/lang/en/), [HTML](https://developer.mozilla.org/en-US/docs/Web/HTML), [CSS](https://developer.mozilla.org/en-US/docs/Web/CSS), [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript) and [React](https://reactjs.org/).\n\nMake sure to install [Yarn](https://classic.yarnpkg.com/lang/en/) in your system if you haven't. We use [Yarn](https://classic.yarnpkg.com/lang/en/) as our package manager, it's just like [npm](https://www.npmjs.com/) but _faster_.\n\nI've written a [separate post](/posts/local-development-setup-for-react-and-typescript-projects/) about the [IDE](https://en.wikipedia.org/wiki/Integrated_development_environment) and extensions I use to help me save time and energy when writing my code in React. I highly suggest that you check it out if you haven't!\n\n## Initialize your project\n\nFastest way to get started with React is using the [Create React App](https://create-react-app.dev/). It is an officially supported way to create single-page React applications. It offers a modern build setup with no configuration so you can focus on code, not build tools.\n\nTo create our project with React and TypeScript, run this command in your terminal:\n\n```bash\nyarn create react-app react-typescript-accordion --template typescript\n```\n\nOnce installed, let's run our project to see if everything is working fine by executing the command below:\n\n```bash\ncd react-typescript-accordion\nyarn start\n```\n\nThis command will open your default browser and go to `http://localhost:3000/`. If it doesn't, you can do it yourself too.\n\nThis setup comes with live-editing or hot reloading which means when we save file changes, it will automatically update the app and reload on the browser. That's great for local development!\n\n---\n\n## Clean up the project\n\nNow, let's clean up our project which was created by Create React App. We won't be needing some of them. Delete or clear the contents of the following below:\n\n- src/App.css (clear contents)\n- src/App.test.tsx (delete)\n- src/logo.svg (delete)\n\nThen let's update the code of `src/App.tsx`:\n\n```tsx\nimport './App.css';\n\nfunction App() {\n  return \u003cdiv className=\"container\"\u003e\u003c/div\u003e;\n}\n\nexport default App;\n```\n\nWe will use the `App` component as the container of our accordion. So just a small update on the `src/App.css`:\n\n```css\n.container {\n  width: 600px;\n  max-width: 100%;\n  margin: 0 auto;\n  padding: 20px 15px;\n}\n```\n\nAnd update the `src/index.css` too:\n\n```css\n* {\n  box-sizing: border-box;\n}\n\nbody {\n  margin: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto',\n    'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans',\n    'Helvetica Neue', sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  line-height: 1.6;\n}\n```\n\n---\n\n## Sample data + Accordion component\n\nNow, let's create sample data that we can pass to our accordion component because we would want our accordion to be reusable, so it should accept data as props. We can initialize the data from a parent component so for our case, it would be `src/App.tsx`. I have a sample data that we can use here, update the code of it:\n\n```tsx\nimport './App.css';\nimport Accordion from './components/Accordion';\n\nfunction App() {\n  const accordionItems = [\n    {\n      title: 'Accordion Item #1',\n      content: (\n        \u003cdiv\u003e\n          \u003cstrong\u003eThis is the first item's accordion body.\u003c/strong\u003e It is hidden\n          by default, but shown when the title is clicked. It will also be\n          hidden if the title is clicked again or when another item is clicked.\n          You can pass HTML tags in the content such as \u003cu\u003eunderline tag\u003c/u\u003e,{' '}\n          \u003ci\u003eitalic\u003c/i\u003e, or even another list like this:\n          \u003cul\u003e\n            \u003cli\u003eBread\u003c/li\u003e\n            \u003cli\u003eEggs\u003c/li\u003e\n            \u003cli\u003eMilk\u003c/li\u003e\n          \u003c/ul\u003e\n        \u003c/div\u003e\n      ),\n    },\n    {\n      title: 'Accordion Item #2',\n      content: (\n        \u003cdiv\u003e\n          \u003cstrong\u003eThis is the second item's accordion body.\u003c/strong\u003e It is\n          hidden by default, but shown when the title is clicked. It will also\n          be hidden if the title is clicked again or when another item is\n          clicked. You can pass HTML tags in the content such as{' '}\n          \u003cu\u003eunderline tag\u003c/u\u003e, \u003ci\u003eitalic\u003c/i\u003e, or even another list like this:\n          \u003cul\u003e\n            \u003cli\u003eBread\u003c/li\u003e\n            \u003cli\u003eEggs\u003c/li\u003e\n            \u003cli\u003eMilk\u003c/li\u003e\n          \u003c/ul\u003e\n        \u003c/div\u003e\n      ),\n    },\n    {\n      title: 'Accordion Item #3',\n      content: (\n        \u003cdiv\u003e\n          \u003cstrong\u003eThis is the third item's accordion body.\u003c/strong\u003e It is hidden\n          by default, but shown when the title is clicked. It will also be\n          hidden if the title is clicked again or when another item is clicked.\n          You can pass HTML tags in the content such as \u003cu\u003eunderline tag\u003c/u\u003e,{' '}\n          \u003ci\u003eitalic\u003c/i\u003e, or even another list like this:\n          \u003cul\u003e\n            \u003cli\u003eBread\u003c/li\u003e\n            \u003cli\u003eEggs\u003c/li\u003e\n            \u003cli\u003eMilk\u003c/li\u003e\n          \u003c/ul\u003e\n        \u003c/div\u003e\n      ),\n    },\n  ];\n\n  return (\n    \u003cdiv className=\"container\"\u003e\n      \u003cAccordion items={accordionItems} /\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\nIf you save the changes we would get errors in the meantime as we would still need to create the `Accordion` component. So create a folder under `src` and name it `components`. We can put our reusable components in this folder. After that, create a file named `Accordion.tsx` inside the `components` folder.\n\n---\n\nThen, let's add the code for `src/components/Accordion.tsx`:\n\n```tsx\nimport { AccordionData } from '../types';\n\nfunction Accordion({ items }: { items: Array\u003cAccordionData\u003e }) {\n  return \u003cul className=\"accordion\"\u003e\u003c/ul\u003e;\n}\n\nexport default Accordion;\n```\n\nIf you're new to TypeScript, the object besides the props will look foreign to you. It would be explained better once we do the remaining change. For now, create a new file `types.ts` inside the `src` folder and add the following code to it:\n\n```ts\nimport { ReactNode } from 'react';\n\nexport type AccordionData = {\n  title: string;\n  content: ReactNode;\n};\n```\n\nNow comes the explanation part for those of you who are new to TypeScript, feel free to skip this if you are already familiar with it. So we are defining the type for the `items` props that our `Accordion` component will accept. So we declared a `type AccordionData` which is an `object` that contains `title` that should only be a `string`, one of the [primitive types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html) in TypeScript, and `content` that should only be a `ReactNode`, a type defined by `React` library, same thing we did when we defined our type `AccordionData`. We can hover to a non-primitive type and it will show a tooltip with more information about the type like this:\n\n![Screenshot of hovering a type in Visual Studio Code](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/hovering-type-in-visual-studio-code.png)\n\nYou can also `Cmd` + `click` (`Ctrl` + `click` on Windows) to view the type with even more information.\n\n![Screenshot of checking a type in Visual Studio Code](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/checking-type-in-visual-studio-code.png)\n\nSo we created `src/types.ts` so that it can be exported and imported across different components which you will see in a bit. Since the `Accordion` component accepts an array of `AccordionData`, we wrapped it in type `Array` like this - `Array\u003cAccordionData\u003e`. You can also wrap it like this - `AccordionData[]`, I just prefer the former as I can read it as an \"array of accordion data\".\n\nNow if we didn't pass the expected data or type for `items` props to our accordion component, our IDE would display an inline error and hovering it would show something like this:\n\n![Screenshot of inline error by TypeScript in Visual Studio Code](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/inline-error-by-typescript-in-visual-studio-code.png)\n\nThis is why TypeScript is really helpful for catching errors early while you're still writing the code.\n\n---\n\n## Accordion Item component\n\nAlright, let's create a new component under `components` and name it `AccordionItem.tsx`. This will be the component used by each item in our accordion. Add the following code below to display both the title and content of each item:\n\n```tsx\nimport { AccordionData } from '../types';\n\nfunction AccordionItem({ data }: { data: AccordionData }) {\n  return (\n    \u003cli className=\"accordion-item\"\u003e\n      \u003ch2 className=\"accordion-item-title\"\u003e\n        \u003cbutton className=\"accordion-item-btn\"\u003e{data.title}\u003c/button\u003e\n      \u003c/h2\u003e\n      \u003cdiv className=\"accordion-item-container\"\u003e\n        \u003cdiv className=\"accordion-item-content\"\u003e{data.content}\u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/li\u003e\n  );\n}\n\nexport default AccordionItem;\n```\n\nAs you can see here, we've also added a type for `data` which should only be `AccordionData`, this is where we reused the type we declared and exported earlier in `src/types.ts`.\n\nNow let's go back to `src/components/Accordion.tsx` and update the code to loop through the items and pass the data to the imported `AccordionItem` component:\n\n```tsx\n...\nimport AccordionItem from './AccordionItem';\n...\n    \u003cul className=\"accordion\"\u003e\n      {items.map((item, idx) =\u003e (\n        \u003cAccordionItem key={idx} data={item} /\u003e\n      ))}\n    \u003c/ul\u003e\n...\n```\n\nOnce you save the changes, our web app should be working fine now without any errors and display something like this:\n\n![Screenshot of accordion partially built in React and TypeScript](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-partial-unstyled.png)\n\n---\n\n## Accordion styles\n\nYes, it doesn't look like an accordion yet. So let's create the styles and import them to their respective components. Create `Accordion.css` under `components` folder and add the following code below:\n\n```css\n.accordion {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n```\n\nThen import it in `Accordion.tsx`:\n\n```tsx\nimport { AccordionData } from '../types';\nimport AccordionItem from './AccordionItem';\nimport './Accordion.css';\n\nfunction Accordion({ items }: { items: Array\u003cAccordionData\u003e }) {\n...\n```\n\nNext, create `AccordionItem.css` under `components` folder and add the following code below:\n\n```css\n.accordion-item {\n  border: 1px solid #ccc;\n}\n\n.accordion-item:not(:first-of-type) {\n  border-top: 0;\n}\n\n.accordion-item-title {\n  width: 100%;\n  margin: 0;\n}\n\n.accordion-item-btn {\n  display: flex;\n  align-items: center;\n  width: 100%;\n  background-color: #fff;\n  border: 0;\n  padding: 15px 20px;\n  font-size: 18px;\n  font-weight: 400;\n  cursor: pointer;\n  user-select: none;\n}\n\n.accordion-item-btn::after {\n  content: '';\n  flex-shrink: 0;\n  width: 18px;\n  height: 18px;\n  margin-left: auto;\n  background-image: url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23212529'%3e%3cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z'/%3e%3c/svg%3e\");\n  background-repeat: no-repeat;\n  background-size: 18px;\n  transition: transform 0.2s ease-in-out;\n}\n\n.accordion-item.active .accordion-item-btn::after {\n  transform: rotate(-180deg);\n}\n\n.accordion-item-container {\n  transition: height 0.2s ease-in-out;\n  overflow: hidden;\n}\n\n.accordion-item-content {\n  border-top: 1px solid #cccccc;\n  padding: 15px 20px;\n}\n```\n\nAnd import it in `AccordionItem.tsx`:\n\n```tsx\nimport { AccordionData } from '../types';\nimport './AccordionItem.css';\n\nfunction AccordionItem({ data }: { data: AccordionData }) {\n...\n```\n\nOnce you saved the changes, our component should look like this now:\n\n![Screenshot of accordion partially built in React and TypeScript](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-partial-styled.png)\n\n---\n\n## Accordion Item props\n\nThat's looking like an accordion now. We just need to make it collapsible. Let's start with the logic for `AccordionItem.tsx`. It should accept a prop `isOpen` to determine whether to display the content or not. We can simply use a conditional statement like this:\n\n```tsx\nimport { AccordionData } from '../types';\nimport './AccordionItem.css';\n\nfunction AccordionItem({\n  data,\n  isOpen,\n}: {\n  data: AccordionData;\n  isOpen: boolean;\n}) {\n  return (\n    \u003cli className=\"accordion-item\"\u003e\n      \u003ch2 className=\"accordion-item-title\"\u003e\n        \u003cbutton className=\"accordion-item-btn\"\u003e{data.title}\u003c/button\u003e\n      \u003c/h2\u003e\n      \u003cdiv className=\"accordion-item-container\"\u003e\n        {isOpen \u0026\u0026 \u003cdiv className=\"accordion-item-content\"\u003e{data.content}\u003c/div\u003e}\n      \u003c/div\u003e\n    \u003c/li\u003e\n  );\n}\n\nexport default AccordionItem;\n```\n\nAnd we would be done with this component but because we want it to have a transition, then we need to be more creative here. What can we use then? Yes, you've guessed it! We can control the height of the content's container. If `isOpen` is `false`, then we set the height of the container to `0`, and if it's `true`, then we set the height using the content's height. Since `isOpen` can change at any point of time, we can use one of the React hooks, `useEffect`, to help us with this accordion logic. Let's update the code of `AccordionItem.tsx`:\n\n```tsx\nimport { useEffect, useRef, useState } from 'react';\nimport { AccordionData } from '../types';\nimport './AccordionItem.css';\n\nfunction AccordionItem({\n  data,\n  isOpen,\n  btnOnClick,\n}: {\n  data: AccordionData;\n  isOpen: boolean;\n  btnOnClick: () =\u003e void;\n}) {\n  const contentRef = useRef\u003cHTMLDivElement\u003e(null);\n  const [height, setHeight] = useState(0);\n\n  useEffect(() =\u003e {\n    if (isOpen) {\n      const contentEl = contentRef.current as HTMLDivElement;\n\n      setHeight(contentEl.scrollHeight);\n    } else {\n      setHeight(0);\n    }\n  }, [isOpen]);\n\n  return (\n    \u003cli className={`accordion-item ${isOpen ? 'active' : ''}`}\u003e\n      \u003ch2 className=\"accordion-item-title\"\u003e\n        \u003cbutton className=\"accordion-item-btn\" onClick={btnOnClick}\u003e\n          {data.title}\n        \u003c/button\u003e\n      \u003c/h2\u003e\n      \u003cdiv className=\"accordion-item-container\" style={{ height }}\u003e\n        \u003cdiv ref={contentRef} className=\"accordion-item-content\"\u003e\n          {data.content}\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/li\u003e\n  );\n}\n\nexport default AccordionItem;\n```\n\nAnd if you're new to TypeScript, you'll notice I used `as HTMLDivElement` here. This is called a [type assertion](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions). If we remove the type assertion, the type of `contentEl.current` would be `HTMLDivElement | null`, but we know in this case it will always have a value of `HTMLDivElement` when `useEffect` is executed. That's why type assertions are done when you have information about the type of a value that TypeScript can't know about.\n\nWhen `isOpen` is true, we should also add an `active` class so that the icon would rotate, it's a common transition effect whenever you toggle an accordion.\n\nI've also added a new prop `btnOnClick` which accepts a callback when the button is clicked. We'll use this later to control when to display or hide our content from the parent component.\n\n---\n\n## Accordion logic (open one at a time)\n\nMoving on to the `Accordion.tsx`, this is where we'll be adding the logic for each accordion item. When an accordion button is clicked, then we should show the contents. We could store a state of which item is displayed, it should be something unique to that item, since our items don't have an identifier (or ID) in their data, we could use the `index` of each item. I could think of two ways an accordion behaves, the one that we'll do in this post (which is my favorite by the way!) is opening an accordion one at a time, meaning when there's an accordion that's currently opened, when I click another one, it will close or hide the previous one and display the content of what I last clicked upon. To do that logic, update the `Accordion` component with the following code below:\n\n```tsx\nimport { useState } from 'react';\nimport { AccordionData } from '../types';\nimport AccordionItem from './AccordionItem';\nimport './Accordion.css';\n\nfunction Accordion({ items }: { items: Array\u003cAccordionData\u003e }) {\n  const [currentIdx, setCurrentIdx] = useState(-1);\n  const btnOnClick = (idx: number) =\u003e {\n    setCurrentIdx(idx);\n  };\n\n  return (\n    \u003cul className=\"accordion\"\u003e\n      {items.map((item, idx) =\u003e (\n        \u003cAccordionItem\n          key={idx}\n          data={item}\n          isOpen={idx === currentIdx}\n          btnOnClick={() =\u003e btnOnClick(idx)}\n        /\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n\nexport default Accordion;\n```\n\nThe initial state value of `currentIdx` (current index) would be `-1`, which means no accordion would be open at the start. When an accordion button is clicked, we would set the `currentIdx` to that accordion's index. This makes the `isOpen` become true since `idx` and `currentIdx` values are equal.\n\nOnce you save the changes, you now have yourself an accordion!\n\n![Screenshot of accordion with one opened in React and TypeScript](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-open-one-at-a-time.png)\n\nBut wait there's one last thing you need to do. If we click on the same accordion again, it still remains open, ideally it should close. So let's do a small update to the code:\n\n```tsx\n...\n  const btnOnClick = (idx: number) =\u003e {\n    setCurrentIdx((currentValue) =\u003e (currentValue !== idx ? idx : -1));\n  };\n...\n```\n\nAnd there you go, you've just built your own accordion in React and TypeScript!\n\n---\n\n## Write tests for Accordion.tsx\n\nAlright, time to write tests for the components we've built. Tests are really great as it helps us cover all the logics in our code and whenever we update the codebase, they help us determine whether we broke anything before the changes get pushed to our repository.\n\nBefore we start, let's install a library called [faker](https://github.com/Marak/faker.js) which gives us random data. Why do we want random data? It makes our tests more reliable as opposed to hardcoding the data we use in testing. Run the command below on your terminal to install it along with its type:\n\n```bash\nyarn add faker@5.5.3 @types/faker@5.5.9\n```\n\nSince our project uses TypeScript, when installing libraries, we would have to install their types as well, because if not TypeScript would display an error that it couldn't find the library's type declarations.\n\nThat's all we need to install because the Create React App already set up and installed the necessary libraries for our testing environment such as Jest and Testing Library.\n\nFor test files, I like to separate them in a folder so that it's less cluttered when viewing main files. Now, create a new folder named `__tests__` under the `src/components`. This is where we will put the test files for components under `src/components`.\n\nAlright, the first component we would be writing tests for is `Accordion.tsx`. Create a file under `src/components/__tests__` and name it `Accordion.test.tsx`.\n\nThen let's add in the structure of the test:\n\n```tsx\nimport Accordion from '../Accordion';\n\ndescribe('\u003cAccordion /\u003e', () =\u003e {});\n```\n\n`describe` creates a block that groups together several related tests. So ideally the description should be describing what we are testing, for this case I used the component name. Feel free to rename it according to your preference. `describe` is one of Jest's global functions, so with the setup of Create React App, we don't need to specifically import these global functions in our code, we can just directly use them.\n\nNext we can add a test case inside the `describe` block:\n\n```tsx\ndescribe('\u003cAccordion /\u003e', () =\u003e {\n  it('should render items', () =\u003e {});\n});\n```\n\nAnother global function by Jest, `it` (or `test`) method runs a test. This is where we can have different test cases. Let's write our first test case:\n\n```tsx\nimport { render, screen } from '@testing-library/react';\nimport faker from 'faker';\nimport Accordion from '../Accordion';\n\ndescribe('\u003cAccordion /\u003e', () =\u003e {\n  it('should render items', () =\u003e {\n    const items = [];\n\n    for (let i = 0; i \u003c 3; i++) {\n      items.push({\n        title: faker.lorem.sentence(),\n        content: faker.lorem.sentences(),\n      });\n    }\n\n    render(\u003cAccordion items={items} /\u003e);\n\n    items.forEach(({ title, content }) =\u003e {\n      const titleEl = screen.queryByText(title);\n      const contentEl = screen.queryByText(content);\n\n      expect(titleEl).toBeInTheDocument();\n      expect(contentEl).toBeInTheDocument();\n    });\n  });\n});\n```\n\nThat's a lot of new code! Don't worry, let me go through it one by one and explain it to you. So first, we created an `items` array which would contain an object of `AccordionData`. We are using `faker` library to help us generate random titles and content. You can check out their API [here](https://github.com/marak/faker.js#api) to know all the other data it can randomly generate. We've added three items which should be enough but you can increase or decrease it if you want, but do note that it should have at least two items in order to test our accordion logic. We then pass this array as a props to our `Accordion` component. Using one of the Testing Library's methods, `render`, helps to render our component in a test environment, do note this environment is not a browser, so there are some limitations and mockings we would have to do which you'll see later on. To learn more about the `render` method, you can go [here](https://testing-library.com/docs/react-testing-library/api/#render). After that, we can do our checks to validate that our items are rendered. To do that, we looped through the items and did a query by text using another method of Testing Library which is `screen.queryByText`. To know all the possible queries you can do with the `screen` object, you can go [here](https://testing-library.com/docs/queries/about). Then finally using one of Jest's global functions, we can call `expect` method and pass the elements returned by the query, and run what we call a matcher method `toBeInTheDocument()`. This is one of many custom matcher methods provided by the library called [jest-dom](https://github.com/testing-library/jest-dom#custom-matchers) which are specific to the [DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction). While you can check this [documentation](https://jestjs.io/docs/expect) for the more generic matcher methods.\n\nAlright, I hoped that explained it.\n\n---\n\nNow let's check if our component passed the test by running the command below in your terminal:\n\n```bash\nyarn test --coverage\n```\n\nThe parameter `--coverage` helps to display the coverage of the tests in which you'll see in your terminal:\n\n![Screenshot of incomplete Accordion test coverage](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-test-coverage-incomplete-1.png)\n\nOur first test case passed! We also managed to cover 66.67% of lines of `Accordion.tsx`. With the `--coverage` parameter, it gives us hints of which lines are uncovered as well, that is line 9 and 19. If we check those lines in our `Accordion.tsx` file, these are related to the logic of opening an accordion item. So let's create the second test case:\n\n```tsx\nimport { fireEvent, render, screen } from '@testing-library/react';\n...\n  it('should open one at a time', () =\u003e {\n    const items = [];\n\n    for (let i = 0; i \u003c 3; i++) {\n      items.push({\n        title: faker.lorem.sentence(),\n        content: faker.lorem.sentences(),\n      });\n    }\n\n    render(\u003cAccordion items={items} /\u003e);\n\n    items.forEach(({ title }) =\u003e {\n      const titleEl = screen.queryByText(title) as HTMLButtonElement;\n\n      fireEvent.click(titleEl);\n\n      const currentListEl = titleEl.closest('li');\n      const activeListEls = document.querySelectorAll('li.active');\n      const activeListEl = activeListEls[0];\n\n      expect(activeListEls.length).toBe(1);\n      expect(activeListEl).toEqual(currentListEl);\n    });\n  });\n});\n```\n\nHere we did the same for generating random data for the props but inside the loop we're doing the checks differently. So first we query the element of the title and fire a click event on it using `fireEvent` which is imported from the Testing Library. To fire other DOM events, you can check out the documentation [here](https://testing-library.com/docs/dom-testing-library/api-events/). Any query of an element may result as `null` so we added a type assertion (`as HTMLButtonElement`) because `fireEvent` method doesn't accept `null` values, it is safe to use type assertion here because we are certain that the element is or should be in the DOM. Then we queried the list element with an `active` class and checked whether it is the same element as the current item's list element, this verifies that our current item is opened. We also did an additional check to make sure that there's only one accordion that is opened at a time (or per loop) by checking that the length of all list items that has an `active` class should only be `1`.\n\nCurrently if you didn't stop the test script server, it will listen for file save changes and automatically run the tests again. This makes writing tests faster as we don't have to re-run the test script again on every change. Our test coverage should look like this now:\n\n![Screenshot of incomplete Accordion test coverage](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-test-coverage-incomplete-2.png)\n\nAwesome, our second test case passed as well! But line 9 is still uncovered though. If we check that line in our file, it is the logic for closing an opened accordion if the title is clicked again. So for the last test case, we can achieve the full coverage for `Accordion.tsx` by writing the code below:\n\n```tsx\n...\n  it('should close if already opened', () =\u003e {\n    const items = [];\n\n    for (let i = 0; i \u003c 3; i++) {\n      items.push({\n        title: faker.lorem.sentence(),\n        content: faker.lorem.sentences(),\n      });\n    }\n\n    render(\u003cAccordion items={items} /\u003e);\n\n    items.forEach(({ title }) =\u003e {\n      const titleEl = screen.queryByText(title) as HTMLButtonElement;\n\n      fireEvent.click(titleEl);\n      fireEvent.click(titleEl);\n\n      const currentListEl = titleEl.closest('li');\n\n      expect(currentListEl).not.toHaveClass('active');\n    });\n  });\n});\n```\n\nHere we fire two click events and check that the current item's list element does not contain an `active` class which is a determinator that the accordion is opened.\n\nNow once we save the changes, our coverage should look like this:\n\n![Screenshot of complete Accordion test coverage](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-test-coverage-complete.png)\n\nCool! If you look at `AccordionItem.tsx` it already has `100%` coverage as well. That's because it is also used in `Accordion.tsx` test cases. But it's always good to have each component or function to have its own test cases as well, because that will make our code more robust.\n\n---\n\n## Write tests for AccordionItem.tsx\n\nCreate a file under `src/components/__tests__` and name it `AccordionItem.test.tsx`. If we want to see how much is covered in `AccordionItem.tsx` while we write tests for it and ignore `Accordion.test.tsx` test cases from running, we can do so by running the test script like this:\n\n```bash\nyarn test --coverage src/components/__tests__/AccordionItem.test.tsx\n```\n\nThis instructs Jest to only run the tests under `src/components/__tests__/AccordionItem.test.tsx`. For now it would fail because it must contain at least one test. So let's write the first test case:\n\n```tsx\nimport { render, screen } from '@testing-library/react';\nimport faker from 'faker';\nimport AccordionItem from '../AccordionItem';\n\ndescribe('\u003cAccordionItem /\u003e', () =\u003e {\n  it('should render content', () =\u003e {\n    const title = faker.lorem.sentence();\n    const content = faker.lorem.sentences();\n\n    render(\n      \u003cAccordionItem\n        data={{ title, content }}\n        isOpen={faker.datatype.boolean()}\n        btnOnClick={jest.fn()}\n      /\u003e\n    );\n\n    const titleEl = screen.queryByText(title);\n    const contentEl = screen.queryByText(content);\n\n    expect(titleEl).toBeInTheDocument();\n    expect(contentEl).toBeInTheDocument();\n  });\n});\n```\n\nThese should look familiar to you as we did the same for our first test case in `Accordion.test.tsx` but here we didn't have to create an array of data and loop through the items to do the checks.\n\nAfter saving the changes, the terminal should display this:\n\n![Screenshot of incomplete Accordion Item test coverage](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-item-test-coverage-incomplete.png)\n\n---\n\nHere, the uncovered lines for `AccordionItem.tsx` is 19-21, but it could be line 23 on your side because we are passing a random `boolean` for `isOpen` props in our first test case. So let's create two new test cases, one for when `isOpen` is `false` and one for when `isOpen` is `true` and we can validate whether the accordion is open or not by checking if there is an `active` class in the list element or not. Write the following code below:\n\n```tsx\n...\n  it('should not display content if isOpen is false', () =\u003e {\n    const title = faker.lorem.sentence();\n    const content = faker.lorem.sentences();\n\n    render(\n      \u003cAccordionItem\n        data={{\n          title,\n          content,\n        }}\n        isOpen={false}\n        btnOnClick={jest.fn()}\n      /\u003e\n    );\n\n    const titleEl = screen.queryByText(title);\n    const listEl = titleEl?.closest('li');\n\n    expect(listEl).not.toHaveClass('active');\n  });\n\n  it('should display content if isOpen is true', () =\u003e {\n    const title = faker.lorem.sentence();\n    const content = faker.lorem.sentences();\n\n    render(\n      \u003cAccordionItem\n        data={{\n          title,\n          content,\n        }}\n        isOpen={true}\n        btnOnClick={jest.fn()}\n      /\u003e\n    );\n\n    const titleEl = screen.queryByText(title);\n    const listEl = titleEl?.closest('li');\n\n    expect(listEl).toHaveClass('active');\n  });\n});\n```\n\nOnce changes are saved, we would achieve `100%` test coverage for `AccordionItem.test.tsx`:\n\n![Screenshot of complete Accordion Item test coverage](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-item-test-coverage-complete-1.png)\n\nYou may be wondering, `active` class just adds the style to rotate the arrow icon but is not really responsible for displaying or hiding the content. That is actually based on the `height` of the container. Can we test that too? Yes, but we will need to update our existing code in `AccordionItem.tsx` because in a test environment, values like `scrollHeight` is always `0` because it does not update measurements like a browser, this is the limitation that I've mentioned earlier. If that's the case, our test case for checking that the height is more than `0` when `isOpen` is `true` would fail. So what should we do?\n\nFirst, create a folder named `lib` under the `src` folder. Then create a file under `src/lib` and name it `hooks.ts`. Add the following code inside the newly created file:\n\n```ts\nimport { RefObject } from 'react';\n\nexport function getRefValue\u003cC\u003e(ref: RefObject\u003cC\u003e) {\n  return ref.current as C;\n}\n```\n\nThis is a utility for getting the value of a `RefObject`. I use this a lot in my projects and it is extremely helpful when writing tests to achieve `100%` coverage, especially those components that use `RefObject` for elements. If you're new to TypeScript, you might be wondering what is this `C` around the code? It can be any letter by the way or word if you would like, and it is called [Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html), it makes our utility function here accept the type defined when the `RefObject` is passed because it can have any type. Using Generics, our function here would be able to return the same type.\n\n---\n\nThen let's update our `AccordionItem.tsx`:\n\n```tsx\n...\nimport { getRefValue } from '../lib/hooks';\n...\n      const contentEl = getRefValue(contentRef);\n```\n\nNow back to our test file `src/components/__tests__/AccordionItem.test.tsx`, let's update our two test cases and add the additional checks:\n\n```tsx\n...\nimport * as hooks from '../../lib/hooks';\n...\ndescribe('\u003cAccordionItem /\u003e', () =\u003e {\n  beforeEach(() =\u003e {\n    jest.restoreAllMocks();\n  });\n  ...\n  it('should not display content if isOpen is false', () =\u003e {\n    const contentScrollHeight = faker.datatype.number({ min: 1 });\n\n    jest.spyOn(hooks, 'getRefValue').mockReturnValue({\n      scrollHeight: contentScrollHeight,\n    });\n\n    const title = faker.lorem.sentence();\n    const content = faker.lorem.sentences();\n\n    render(\n      \u003cAccordionItem\n        data={{\n          title,\n          content,\n        }}\n        isOpen={false}\n        btnOnClick={jest.fn()}\n      /\u003e\n    );\n\n    const titleEl = screen.queryByText(title);\n    const listEl = titleEl?.closest('li');\n    const contentEl = screen.queryByText(content);\n    const contentContainerEl = contentEl?.parentElement;\n\n    expect(listEl).not.toHaveClass('active');\n    expect(contentContainerEl).toHaveStyle({ height: '0px' });\n  });\n\n  it('should display content if isOpen is true', () =\u003e {\n    const contentScrollHeight = faker.datatype.number({ min: 1 });\n\n    jest.spyOn(hooks, 'getRefValue').mockReturnValue({\n      scrollHeight: contentScrollHeight,\n    });\n\n    const title = faker.lorem.sentence();\n    const content = faker.lorem.sentences();\n\n    render(\n      \u003cAccordionItem\n        data={{\n          title,\n          content,\n        }}\n        isOpen={true}\n        btnOnClick={jest.fn()}\n      /\u003e\n    );\n\n    const titleEl = screen.queryByText(title);\n    const listEl = titleEl?.closest('li');\n    const contentEl = screen.queryByText(content);\n    const contentContainerEl = contentEl?.parentElement;\n\n    expect(listEl).toHaveClass('active');\n    expect(contentContainerEl).toHaveStyle({\n      height: `${contentScrollHeight}px`,\n    });\n  });\n});\n```\n\nLet's analyze the updated code. First, we imported our `hooks` file using `* as hooks` in order to get an object of methods from `src/lib/hooks.ts`. We then use one of Jest's methods called `jest.spyOn` which tracks the calls to `object[methodName]` that you passed to it. It returns a Jest mock function which we can mock to return a different value using `.mockReturnValue()`. To see all the mock functions you could do, check them out [here](https://jestjs.io/docs/mock-functions). When we do mocks in our test cases, it does not get restored back to their original value in the next test case, this might cause potential issues with the next test cases so it's good to call `jest.restoreAllMocks()` to prevent that. Instead of calling this function in the beginning of every test case, we can put the call inside one of Jest's methods `beforeEach`, it accepts a callback which will be called before each test case, and put it inside the `describe` call back right at the beginning before any test cases.\n\nSo we mocked the scroll height of the content element with a random generated number (minimum should be `1` because `0` means the content is hidden) and did the checks based on our accordion item logic. If the accordion item is opened, the content element's container should have the same height as the scroll height of the content element. If it's closed, then the height should be `0px`.\n\nNow if we check our test results, it should be like this:\n\n![Screenshot of complete Accordion Item test coverage](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-item-test-coverage-complete-2.png)\n\nGreat! Even though it already has `100%` test coverage, let's not forget to test the `btnOnClick` props, same reason for having each component or function having their own tests, each props you introduce, if logical, should also have their own tests. Similar to what we did in `Accordion.test.tsx`, we can fire a click event to the title of the accordion item, but in this case our verification would be to check if the function passed in the props was called. To validate that, add the following code below:\n\n```tsx\nimport { fireEvent, render, screen } from '@testing-library/react';\n...\n  it('should call btnOnClick on title click', () =\u003e {\n    const btnOnClickMock = jest.fn();\n\n    const title = faker.lorem.sentence();\n    const content = faker.lorem.sentences();\n\n    render(\n      \u003cAccordionItem\n        data={{\n          title,\n          content,\n        }}\n        isOpen={faker.datatype.boolean()}\n        btnOnClick={btnOnClickMock}\n      /\u003e\n    );\n\n    const titleEl = screen.queryByText(title) as HTMLButtonElement;\n\n    fireEvent.click(titleEl);\n\n    expect(btnOnClickMock).toBeCalledTimes(1);\n  });\n});\n```\n\n---\n\n## Write tests for hooks.ts\n\nI've mentioned earlier that each component or function we create should have their own tests. So as a bonus, here's the test case for the hooks utility we created earlier, the code below should be added inside `src/lib/__tests__/hooks.test.ts`:\n\n```ts\nimport faker from 'faker';\nimport { getRefValue } from '../hooks';\n\ndescribe('hooks utilities', () =\u003e {\n  describe('getRefValue()', () =\u003e {\n    it('should return the value', () =\u003e {\n      const refValue = faker.lorem.sentence();\n      const refObject = { current: refValue };\n      const res = getRefValue(refObject);\n\n      expect(res).toBe(refValue);\n    });\n  });\n  a;\n});\n```\n\n## Write tests for App.tsx\n\nAnd then here's the code for testing our `App` component under `src/__tests__/App.test.tsx`:\n\n```tsx\nimport { render } from '@testing-library/react';\nimport App from '../App';\n\ndescribe('\u003cApp /\u003e', () =\u003e {\n  it('should render without errors', () =\u003e {\n    const { container } = render(\u003cApp /\u003e);\n\n    expect(container).toBeInTheDocument();\n  });\n});\n```\n\n---\n\nWhen you run the all the tests again via `yarn test --coverage`, it will look very satisfying as the terminal would display all green and all 100% covered:\n\n![Screenshot of complete test coverage](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/test-coverage-complete.png)\n\nAnd there you have it! You've just built your own accordion in React and TypeScript with tests! I hope you've learned a lot from this post, especially those who are new to TypeScript and Jest.\n\nIn case you need the final code of the accordion as a reference, this is the [link](https://github.com/dominicarrojado/react-typescript-accordion) to the GitHub repository.\n\nPlease don't forget to share this post and just a heads up, I'll be writing more of these \"building your own components in React and TypeScript with tests\" so if you're interested, you can come back to my blog to check it out once they're published.\n","previousPost":{"id":"local-development-setup-for-react-and-typescript-projects","title":"Local development setup for React and TypeScript projects","date":"2021-09-26","excerpt":"A quick way to get started with React and TypeScript","category":"technology","videoUrl":""},"nextPost":{"id":"the-turning-point","title":"The Turning Point","date":"2021-10-17","excerpt":"A critical time in your life where big decisions could lead to big change, both at work and in life","category":"personal","videoUrl":""},"title":"How to create your own accordion in React and TypeScript with tests","date":"2021-09-27","excerpt":"Learn how to build a collapsible content in a reactive and reusable way","category":"technology","videoUrl":"https://youtu.be/Hn7iDjbPtVY"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"how-to-create-your-own-accordion-in-react-and-typescript-with-tests"},"buildId":"KGsbdrvK_53-1lZ7PKZnz","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>