<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#2c2c34"/><link rel="icon" href="https://dominicarrojado.com/favicon.ico"/><link rel="manifest" href="https://dominicarrojado.com/manifest.json"/><meta name="twitter:card" content="summary_large_image"/><meta property="og:image" content="https://dominicarrojado.com/images/pages/guides-tips-and-tricks-to-web-development.png"/><meta property="og:image:alt" content="Dominic Arrojado | Guides, Tips and Tricks to Web Development"/><meta property="og:image:type" content="image/png"/><meta property="og:image:width" content="2400"/><meta property="og:image:height" content="1254"/><meta property="og:site_name" content="Dominic Arrojado"/><link rel="preload" href="/fonts/Roboto-Light.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Light.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-LightItalic.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-LightItalic.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Regular.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Italic.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Medium.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-MediumItalic.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-MediumItalic.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Bold.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-BoldItalic.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-BoldItalic.woff" as="font" type="font/woff" crossorigin="anonymous"/><title>How to create your own swiper, carousel or slider in React and TypeScript with tests (Part 2) | Dominic Arrojado</title><meta name="robots" content="index,follow"/><meta name="description" content="Learn how to build a modern mobile touch swiper in a reactive and reusable way"/><meta property="og:title" content="How to create your own swiper, carousel or slider in React and TypeScript with tests (Part 2) | Dominic Arrojado"/><meta property="og:description" content="Learn how to build a modern mobile touch swiper in a reactive and reusable way"/><meta property="og:url" content="https://dominicarrojado.com/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests-part-2/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2022-02-11T14:00:00Z"/><meta property="article:modified_time" content="2022-02-11T14:00:00Z"/><meta property="article:author" content="https://dominicarrojado.com/about/"/><link rel="canonical" href="https://dominicarrojado.com/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests-part-2/"/><meta name="next-head-count" content="39"/><link rel="preload" href="/_next/static/css/672b9c18f2cf5d8b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/672b9c18f2cf5d8b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/82d01f71dc75279c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/82d01f71dc75279c.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-7ddcf04b2bd1e96a.js" defer=""></script><script src="/_next/static/chunks/framework-73b8966a3c579ab0.js" defer=""></script><script src="/_next/static/chunks/main-f0c986bda8fad686.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f8b9ccaf5904b773.js" defer=""></script><script src="/_next/static/chunks/374-b35b83a20fdd9d5b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-3eaaed6cc51dd36d.js" defer=""></script><script src="/_next/static/t3qDNQ3q0ssjJDc3XqCZC/_buildManifest.js" defer=""></script><script src="/_next/static/t3qDNQ3q0ssjJDc3XqCZC/_ssgManifest.js" defer=""></script></head><body><div id="__next"><noscript>
            <iframe
              src="https://www.googletagmanager.com/ns.html?id=GTM-TSMLTPT"
              height="0"
              width="0"
              style="display: none; visibility: hidden"
            ></iframe>
          </noscript><div tabindex="-1" class="h-full outline-none"><header class="fixed flex items-center top-0 w-full z-40"><a href="#main" tabindex="0" class="absolute -top-96 -left-96 w-px h-px text-center text-white overflow-hidden -z-50 focus:top-4 focus:inset-x-0 focus:m-auto focus:w-44 focus:h-auto focus:z-50 focus:sm:w-52 focus:xl:w-56">Skip to main content</a><a class="absolute top-3.5 left-3.5 flex shadow-3xl border border-white bg-gray-750 bg-opacity-90 p-1.5 z-50 transform transition ease-in-out duration-500 hover:shadow-md hover:bg-opacity-100 motion-reduce:transition-none sm:top-4 sm:left-4 md:top-5 md:left-5 md:border-2 lg:top-8 lg:left-8 opacity-0 -translate-y-full" aria-label="Dominic Arrojado logo" href="/"><svg viewBox="0 0 25750 29700" role="img" class="w-7 h-7 text-white transition-colors duration-300 sm:w-8 sm:h-8 md:w-10 md:h-10 xl:w-11 xl:h-11"><path fill="currentColor" d="M4850 19266H1025V2039l4600-129c2511 0 4500 735 5970 2206 1470 1470 2206 3423 2206 5854 0 6199-2985 9296-8951 9296zM4086 4719v11751c494 48 1025 72 1599 72 1543 0 2752-558 3624-1679s1310-2688 1310-4705c0-3684-1712-5524-5135-5524-329 0-795 28-1398 85zm17656 21711l-1437-3969h-6721l974-2655h4730l-2242-6854 1518-4167 7010 17645zM17826 435h3307L10351 29313H7044l4243-11322c1982-1513 2973-4055 2973-7627 0-171-4-340-11-506l3577-9423z"></path></svg></a><div class="absolute top-3.5 right-3.5 flex items-end gap-3 ml-auto sm:top-4 sm:right-4 sm:gap-4 md:top-5 md:right-5 md:gap-5 lg:top-8 lg:right-8 lg:gap-6" style="padding-right:var(--scrollbar-width, 0)" data-testid="header-buttons"><button data-command="" data-disclosure="" aria-expanded="false" class="group flex items-center flex-col min-w-8 outline-none md:min-w-10 xl:min-w-11" aria-label="Toggle menu"><div class="w-6 h-0.5 bg-gray-400 rounded dark:bg-gray-300 transform transition group-hover:bg-gray-500 group-focus-visible:bg-gray-500 motion-reduce:transition-none dark:group-hover:bg-white dark:group-focus-visible:bg-white md:w-7 md:h-1 xl:w-8 duration-700 opacity-0 translate-x-1/2" style="transition-delay:0ms" data-testid="menu-stack"></div><div class="w-6 h-0.5 bg-gray-400 rounded dark:bg-gray-300 transform transition group-hover:bg-gray-500 group-focus-visible:bg-gray-500 motion-reduce:transition-none dark:group-hover:bg-white dark:group-focus-visible:bg-white md:w-7 md:h-1 xl:w-8 mt-1.5 duration-700 opacity-0 -translate-x-1/2" style="transition-delay:100ms" data-testid="menu-stack"></div><div class="w-6 h-0.5 bg-gray-400 rounded dark:bg-gray-300 transform transition group-hover:bg-gray-500 group-focus-visible:bg-gray-500 motion-reduce:transition-none dark:group-hover:bg-white dark:group-focus-visible:bg-white md:w-7 md:h-1 xl:w-8 mt-1.5 duration-700 opacity-0 translate-x-1/2" style="transition-delay:200ms" data-testid="menu-stack"></div><div class="mt-1.5 text-gray-400 text-3xs font-normal uppercase select-none dark:text-gray-300 transform transition-transform-opacity-color duration-700 group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-gray-100 md:mt-2 md:text-2xs xl:text-xs opacity-0 -translate-y-3">Menu</div></button></div></header><span id=":R366:" style="position:fixed"></span><div id="main"></div><section class="relative flex flex-col bg-gray-550 items-center justify-center px-6 text-center overflow-hidden dark:bg-gray-650 sm:px-20 lg:px-32 min-h-96 py-28"><div class="absolute top-0 left-0 w-full h-full bg-repeat bg-center invert-[.1] dark:invert-0 motion-safe:animate-slide transition-opacity duration-1250 motion-reduce:transition-none opacity-0" style="background-image:url(&#x27;/images/bg/pattern.png&#x27;)"></div><div class="overflow-hidden py-2" style="opacity:1"><h1 class="text-3xl font-bold text-white leading-tight transform transition duration-700 motion-reduce:transition-none sm:text-4xl md:text-5xl lg:text-6xl xl:text-7xl opacity-0 translate-y-full">How to create your own swiper, carousel or slider in React and TypeScript with tests (Part 2)</h1></div><div class="overflow-hidden" style="opacity:1"><p class="font-light text-white transform transition duration-700 motion-reduce:transition-none xl:text-2xl opacity-0 translate-y-full">Learn how to build a modern mobile touch swiper in a reactive and reusable way</p></div></section><section class="pt-16 pb-20 px-6 sm:pt-20 sm:pb-24 sm:px-8 md:pt-24 md:pb-28 lg:px-10 xl:pt-28 xl:pb-32 transform transition-transform-opacity duration-700 motion-reduce:transition-none opacity-0" data-testid="section"><div class="w-11/12 max-w-screen-3xl -mt-8 mx-auto pb-8 sm:-mt-10 sm:pb-10 md:-mt-12 md:pb-12 lg:w-5/6"><ins class="adsbygoogle block max-w-[1200px] mx-auto adUnit_adunit__Qsm4B" data-ad-client="ca-pub-3632473845121107" data-ad-slot="4984498713" data-ad-format="auto" data-full-width-responsive="true" data-testid="ad-unit"></ins></div><div class="flex justify-between items-center w-11/12 max-w-screen-3xl mx-auto lg:w-5/6"><div class="mr-4 text-sm text-gray-400 sm:text-base xl:text-lg">Last Updated: <time dateTime="2022-02-11">February 11, 2022</time></div><div class="rounded py-0.5 px-1.5 bg-gray-200 text-2xs capitalize dark:bg-gray-600 md:py-1 md:px-2 md:text-xs xl:text-sm">technology</div></div><div class="w-11/12 max-w-screen-3xl mt-4 mx-auto lg:w-5/6"><a class="group inline-flex items-center font-normal select-none dark:hover:text-white transition-colors duration-300 hover:text-black group-hover:text-black motion-reduce:transition-none" target="_blank" rel="noopener noreferrer nofollow" href="https://youtu.be/V0dfhBc2lj8"><svg viewBox="0 0 576 512" role="img" class="w-6 h-6 mr-2 text-gray-400 transition-colors duration-300 group-hover:text-red motion-reduce:transition-none dark:group-hover:text-white sm:w-7 sm:h-7 sm:mr-3 xl:w-8 xl:h-8"><path fill="currentColor" d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z"></path></svg> <!-- -->Watch it on YouTube<svg viewBox="0 0 320 512" role="img" class="inline-block w-2 h-2 ml-2 text-black opacity-30 dark:text-white transform transition duration-300 group-hover:translate-x-1.5 group-hover:opacity-100 motion-reduce:transition-none sm:w-2.5 sm:h-2.5 sm:ml-2.5 md:w-3 md:h-3 md:ml-3 xl:w-3.5 xl:h-3.5"><path fill="currentColor" d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"></path></svg></a></div><article class="w-11/12 max-w-screen-3xl mx-auto prose dark:prose-dark sm:prose-lg lg:w-5/6 xl:prose-xl mt-8 sm:mt-10 xl:mt-14" data-clarity-region="article" data-testid="content"><h2>Introduction</h2>
<p>This is a continuation from <a href="/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests-part-1">Part 1</a>.</p>
<h2>Prerequisites</h2>
<p>To get started with testing, first install the following package:</p>
<pre><code class="hljs language-bash">yarn add @testing-library/react-hooks faker@5.5.3 @types/faker@5.5.9
</code></pre>
<p>So <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/testing-library/react-hooks-testing-library"><code>@testing-library/react-hooks</code></a> allows us to create a simple test harness for React hooks that handles running them within the body of a function component, as well as providing various useful utility functions for updating the inputs and retrieving the outputs of our custom hook. This library aims to provide a testing experience as close as possible to natively using your hook from within a real component. While <code>faker</code> helps us generate massive amounts of fake (but realistic) data for testing.</p>
<h2>Write tests for SwiperItem.tsx</h2>
<p>For test files, I like to separate them in a folder so that it&#x27;s less cluttered when viewing the main files. Now, create a new folder named <code>__tests__</code> under the <code>src/components</code>. This is where we will put the test files for the components under <code>src/components</code>.</p>
<p>Alright, the first component we would be writing test for is <code>SwiperItem.tsx</code>. Create a file under <code>src/components/__tests__</code> and name it <code>SwiperItem.test.tsx</code>.</p>
<p>Then let&#x27;s add in the structure of the test:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> SwiperItem, { Props } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../SwiperItem&#x27;</span>;

describe(<span class="hljs-string">&#x27;&lt;SwiperItem /&gt;&#x27;</span>, <span class="hljs-function">() =&gt;</span> {});
</code></pre>
<p>Aside from importing the component that we will test, we also imported the type <code>Props</code>. You&#x27;ll get to see later why.</p>
<p><code>describe</code> is one of Jest&#x27;s global functions, so with the setup of Create React App, we don&#x27;t need to specifically import these global functions in our code, we can just directly use them. <code>describe</code> creates a block that groups together several related tests. So ideally the description should be describing what we are testing, for this case I used the component name. Feel free to rename it according to your preference.</p>
<p>Next we can add a test case inside the <code>describe</code> block:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> SwiperItem, { Props } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../SwiperItem&#x27;</span>;

describe(<span class="hljs-string">&#x27;&lt;SwiperItem /&gt;&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  it(<span class="hljs-string">&#x27;should accept imageSrc and imageAlt props&#x27;</span>, <span class="hljs-function">() =&gt;</span> {});
});
</code></pre>
<p>Another global function by Jest, <code>it</code> (or <code>test</code>) method runs a test. This is where we can have different test cases. Let&#x27;s write our first test case:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> { render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span>;
<span class="hljs-keyword">import</span> faker <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;faker&#x27;</span>;
<span class="hljs-keyword">import</span> SwiperItem, { Props } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../SwiperItem&#x27;</span>;

describe(<span class="hljs-string">&#x27;&lt;SwiperItem /&gt;&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> renderComponent = <span class="hljs-function">(<span class="hljs-params">props: Props</span>) =&gt;</span> render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SwiperItem</span> {<span class="hljs-attr">...props</span>} /&gt;</span></span>);

  it(<span class="hljs-string">&#x27;should accept imageSrc and imageAlt props&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> imageSrc = faker.image.imageUrl();
    <span class="hljs-keyword">const</span> imageAlt = faker.lorem.sentence();

    renderComponent({ imageSrc, imageAlt });

    <span class="hljs-keyword">const</span> imageEl = screen.queryByAltText(imageAlt);

    expect(imageEl).toHaveAttribute(<span class="hljs-string">&#x27;src&#x27;</span>, imageSrc);
  });
});
</code></pre>
<p>Okay don&#x27;t panic! I&#x27;ll explain the added code one by one. So first, I created a reusable function <code>renderComponent</code> inside the <code>describe</code> block, it accepts the props of our component as an argument and calls the <code>render()</code> method from Testing Library to render our component with the passed props in a test environment. Since our test files are also in TypeScript, we still need to define the type it, that&#x27;s why we imported the type <code>Props</code> here too. To learn more about the <code>render()</code> method, you can go <a target="_blank" rel="noopener noreferrer nofollow" href="https://testing-library.com/docs/react-testing-library/api/#render">here</a>. Then inside the <code>it</code> block, we generated a random image source and alternative text using <code>faker</code> library which we installed earlier. We then pass these as props to our <code>SwiperItem</code> component. After that, we can do our checks to validate that the image is rendered. To do that, we did a query by its alternative text using another method of Testing Library which is <code>screen.queryByAltText()</code>. To know all the possible queries you can do with <code>screen</code>, you can go <a target="_blank" rel="noopener noreferrer nofollow" href="https://testing-library.com/docs/queries/about">here</a>. Then finally using one of Jest&#x27;s global functions, we can call the <code>expect()</code> method and pass the element returned by the query, and run what we call a matcher method <code>.toHaveAttribute()</code>, it can accept two arguments, first argument being the element attribute that you want to check and second argument is what the attribute value should match. This is one of the many custom matcher methods provided by the library called <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/testing-library/jest-dom#custom-matchers">jest-dom</a> which are specific to the <a target="_blank" rel="noopener noreferrer nofollow" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction">DOM</a>. While you can check this <a target="_blank" rel="noopener noreferrer nofollow" href="https://jestjs.io/docs/expect">documentation</a> for the more generic matcher methods.</p>
<p>Alright, I hoped that explained it.</p>
<p>To verify if this test case did pass or not, in your terminal, run the following command:</p>
<pre><code class="hljs language-bash">yarn <span class="hljs-built_in">test</span> --coverage
</code></pre>
<p>The <code>--coverage</code> parameter will show you which how many percentage you have covered in each files of your project and/or if you have missed any line to test. Once the changes are saved and the command ran successfully, the terminal should display something like this:</p>
<img src="/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/test-coverage-incomplete-1.png" alt="Screenshot of complete React Swiper Item test coverage" loading="lazy"/>
<p>Cool, first test and we immediately hit 100% for <code>SwiperItem.tsx</code>! I can&#x27;t promise the same for <code>Swiper.tsx</code> though, that will have many test cases but would be good for our learning. Alright, let&#x27;s move on.</p>
<div><ins class="adsbygoogle block max-w-[1200px] mx-auto adUnit_adunit__Qsm4B" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<h2>Write tests for Swiper.tsx</h2>
<p>Before we start writing test for <code>Swiper.tsx</code>, please make sure the contents of your <code>Swiper.tsx</code> is the same as mine, since we added quite a bit of code over there, there&#x27;s a high possibility we have some difference. To ensure we are looking at the same lines of code when dealing with uncovered lines upon writing tests, please copy the code below:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> React, { useState, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> { getRefValue, useStateRef } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../lib/hooks&#x27;</span>;
<span class="hljs-keyword">import</span> { getTouchEventData } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../lib/dom&#x27;</span>;
<span class="hljs-keyword">import</span> { SwiperItemType } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../types&#x27;</span>;
<span class="hljs-keyword">import</span> SwiperItem <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./SwiperItem&#x27;</span>;

<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./Swiper.css&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> Props = {
  <span class="hljs-attr">items</span>: <span class="hljs-built_in">Array</span>&lt;SwiperItemType&gt;;
};

<span class="hljs-keyword">const</span> MIN_SWIPE_REQUIRED = <span class="hljs-number">40</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Swiper</span>(<span class="hljs-params">{ items }: Props</span>) </span>{
  <span class="hljs-keyword">const</span> containerRef = useRef&lt;HTMLUListElement&gt;(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> containerWidthRef = useRef(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> minOffsetXRef = useRef(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> currentOffsetXRef = useRef(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> startXRef = useRef(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> [offsetX, setOffsetX, offsetXRef] = useStateRef(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> [isSwiping, setIsSwiping] = useState(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [currentIdx, setCurrentIdx] = useState(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">const</span> onTouchMove = <span class="hljs-function">(<span class="hljs-params">e: TouchEvent | MouseEvent</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> currentX = getTouchEventData(e).clientX;
    <span class="hljs-keyword">const</span> diff = getRefValue(startXRef) - currentX;
    <span class="hljs-keyword">let</span> newOffsetX = getRefValue(currentOffsetXRef) - diff;

    <span class="hljs-keyword">const</span> maxOffsetX = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> minOffsetX = getRefValue(minOffsetXRef);

    <span class="hljs-keyword">if</span> (newOffsetX &gt; maxOffsetX) {
      newOffsetX = maxOffsetX;
    }

    <span class="hljs-keyword">if</span> (newOffsetX &lt; minOffsetX) {
      newOffsetX = minOffsetX;
    }

    setOffsetX(newOffsetX);
  };
  <span class="hljs-keyword">const</span> onTouchEnd = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> currentOffsetX = getRefValue(currentOffsetXRef);
    <span class="hljs-keyword">const</span> containerWidth = getRefValue(containerWidthRef);
    <span class="hljs-keyword">let</span> newOffsetX = getRefValue(offsetXRef);

    <span class="hljs-keyword">const</span> diff = currentOffsetX - newOffsetX;

    <span class="hljs-comment">// we need to check difference in absolute/positive value (if diff is more than 40px)</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(diff) &gt; MIN_SWIPE_REQUIRED) {
      <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// swipe to the right if diff is positive</span>
        newOffsetX = <span class="hljs-built_in">Math</span>.floor(newOffsetX / containerWidth) * containerWidth;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// swipe to the left if diff is negative</span>
        newOffsetX = <span class="hljs-built_in">Math</span>.ceil(newOffsetX / containerWidth) * containerWidth;
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// remain in the current image</span>
      newOffsetX = <span class="hljs-built_in">Math</span>.round(newOffsetX / containerWidth) * containerWidth;
    }

    setIsSwiping(<span class="hljs-literal">false</span>);
    setOffsetX(newOffsetX);
    setCurrentIdx(<span class="hljs-built_in">Math</span>.abs(newOffsetX / containerWidth));

    <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;touchend&#x27;</span>, onTouchEnd);
    <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;touchmove&#x27;</span>, onTouchMove);
    <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;mouseup&#x27;</span>, onTouchEnd);
    <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, onTouchMove);
  };
  <span class="hljs-keyword">const</span> onTouchStart = <span class="hljs-function">(<span class="hljs-params">
    e: React.TouchEvent&lt;HTMLDivElement&gt; | React.MouseEvent&lt;HTMLDivElement&gt;
  </span>) =&gt;</span> {
    setIsSwiping(<span class="hljs-literal">true</span>);

    currentOffsetXRef.current = getRefValue(offsetXRef);
    startXRef.current = getTouchEventData(e).clientX;

    <span class="hljs-keyword">const</span> containerEl = getRefValue(containerRef);
    <span class="hljs-keyword">const</span> containerWidth = containerEl.offsetWidth;

    containerWidthRef.current = containerWidth;
    minOffsetXRef.current = containerWidth - containerEl.scrollWidth;

    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;touchmove&#x27;</span>, onTouchMove);
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;touchend&#x27;</span>, onTouchEnd);
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, onTouchMove);
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;mouseup&#x27;</span>, onTouchEnd);
  };
  <span class="hljs-keyword">const</span> indicatorOnClick = <span class="hljs-function">(<span class="hljs-params">idx: <span class="hljs-built_in">number</span></span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> containerEl = getRefValue(containerRef);
    <span class="hljs-keyword">const</span> containerWidth = containerEl.offsetWidth;

    setCurrentIdx(idx);
    setOffsetX(-(containerWidth * idx));
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>
      <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;swiper-container&quot;</span>
      <span class="hljs-attr">onTouchStart</span>=<span class="hljs-string">{onTouchStart}</span>
      <span class="hljs-attr">onMouseDown</span>=<span class="hljs-string">{onTouchStart}</span>
    &gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>
        <span class="hljs-attr">ref</span>=<span class="hljs-string">{containerRef}</span>
        <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">swiper-list</span> ${<span class="hljs-attr">isSwiping</span> ? &#x27;<span class="hljs-attr">is-swiping</span>&#x27; <span class="hljs-attr">:</span> &#x27;&#x27;}`}
        <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">transform:</span> `<span class="hljs-attr">translate3d</span>(${<span class="hljs-attr">offsetX</span>}<span class="hljs-attr">px</span>, <span class="hljs-attr">0</span>, <span class="hljs-attr">0</span>)` }}
      &gt;</span>
        {items.map((item, idx) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">SwiperItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{idx}</span> {<span class="hljs-attr">...item</span>} /&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;swiper-indicator&quot;</span>&gt;</span>
        {items.map((_item, idx) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">li</span>
            <span class="hljs-attr">key</span>=<span class="hljs-string">{idx}</span>
            <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">swiper-indicator-item</span> ${
              <span class="hljs-attr">currentIdx</span> === <span class="hljs-string">idx</span> ? &#x27;<span class="hljs-attr">active</span>&#x27; <span class="hljs-attr">:</span> &#x27;&#x27;
            }`}
            <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> indicatorOnClick(idx)}
            data-testid=&quot;indicator&quot;
          /&gt;
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Swiper;
</code></pre>
<p>Alright, don&#x27;t forget to save the changes!</p>
<div><ins class="adsbygoogle block max-w-[1200px] mx-auto adUnit_adunit__Qsm4B" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<p>Create the file - <code>src/components/__tests__/Swiper.test.tsx</code> and let&#x27;s add the first test case for it which just checks whether the images are rendered:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> { render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span>;
<span class="hljs-keyword">import</span> faker <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;faker&#x27;</span>;
<span class="hljs-keyword">import</span> Swiper, { Props } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../Swiper&#x27;</span>;

describe(<span class="hljs-string">&#x27;&lt;Swiper /&gt;&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> renderComponent = <span class="hljs-function">(<span class="hljs-params">props: Props</span>) =&gt;</span> render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Swiper</span> {<span class="hljs-attr">...props</span>} /&gt;</span></span>);
  <span class="hljs-keyword">const</span> createRandomItems = <span class="hljs-function">(<span class="hljs-params">count = <span class="hljs-number">3</span></span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> items = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
      items.push({
        <span class="hljs-attr">imageSrc</span>: faker.image.imageUrl(),
        <span class="hljs-attr">imageAlt</span>: faker.lorem.sentence(),
      });
    }

    <span class="hljs-keyword">return</span> items;
  };

  it(<span class="hljs-string">&#x27;should display the images&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> items = createRandomItems();

    renderComponent({ items });

    items.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> imageEl = screen.queryByAltText(item.imageAlt);

      expect(imageEl).toHaveAttribute(<span class="hljs-string">&#x27;src&#x27;</span>, item.imageSrc);
    });
  });
});
</code></pre>
<p>Most of the code here should be familiar to you based from our test case for <code>SwiperItem</code> component. The main difference is that I created a reusable function to produce 3 image items to pass as props for our <code>Swiper</code> component. I think 3 is enough but feel free to adjust the number of items if you like. After rendering the component, I then loop through the items and query them one by one using <code>screen.queryByAltText()</code> with their alternative text, then call the <code>expect()</code> method to check whether the image is rendered with the correct image source using <code>.toHaveAttribute()</code>, similar to what we did in <code>SwiperItem</code> component.</p>
<p>Alright, save the changes above and check your terminal, it should look something like this:</p>
<img src="/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/test-coverage-incomplete-2.png" alt="Screenshot of incomplete React Swiper test coverage" loading="lazy"/>
<p>From the screenshot, there&#x27;s still a few lines uncovered in our <code>Swiper</code> component, lines <code>26</code> - <code>41</code>, <code>44</code> - <code>71</code>, <code>76</code> - <code>90</code>, <code>93</code> - <code>97</code> and <code>122</code>. If you go and check these lines in <code>Swiper.tsx</code> file, majority of these are from the swipe logic. Let&#x27;s cover that in our next test case. It would be slightly more complicated, we need to verify that our swipe logic works when we fire mouse or touch events.</p>
<p>Before we move into writing the code for the test case. We need to create a helper function for this test case. Let me explain why we need so. In a test environment, when you try to access an element property values such as <code>offsetWidth</code> and <code>scrollHeight</code> it will return you <code>0</code>. That&#x27;s because these values are computed in a browser environment with a dependency on the CSS styles. Our test case in verifying the swipe logic would fail because it depends on these values. We need to change the value of these properties from <code>0</code> to any number we would want or expect. It could have been easy though if we can just do something like this <code>element.offsetWidth = 123</code> but because these values are <em>read-only</em>, we cannot simply do that. So here&#x27;s where my helper function comes in to the rescue, create a file <code>src/lib/test-helpers.ts</code> and add the following code:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setReadOnlyProperty</span>&lt;
  <span class="hljs-title">O</span> <span class="hljs-title">extends</span> <span class="hljs-title">Record</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">any</span>&gt;,
  <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">O</span>,
  <span class="hljs-title">V</span> <span class="hljs-title">extends</span> <span class="hljs-title">any</span>
&gt;(<span class="hljs-params"><span class="hljs-built_in">object</span>: O, property: K, value: V</span>) </span>{
  <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">object</span>, property, {
    value,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
  });
}
</code></pre>
<div><ins class="adsbygoogle block max-w-[1200px] mx-auto adUnit_adunit__Qsm4B" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<p>If you&#x27;re new to TypeScript, you already know Generics from when we created the <code>getRefValue</code> but you might be new to <code>extends</code> and <code>keyof</code>. Just like a <a target="_blank" rel="noopener noreferrer nofollow" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">Classes</a> in JavaScript, you can also <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.typescriptlang.org/docs/handbook/2/objects.html#extending-types">extend types</a>. While <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.typescriptlang.org/docs/handbook/2/keyof-types.html"><code>keyof</code></a> type operator takes an object type and produces a string or numeric literal union of its keys. In combination with Generics, I can then extend <code>O</code> and expect it to be an object (<code>Record&lt;string, any</code>&gt;), then extend <code>K</code> to be a key (or property) of <code>O</code>, while <code>V</code> could be <code>any</code> which literally means it could be anything. With this type definition, when you use the function pass an object and a key, the key you have given must exist in the object, otherwise TypeScript would complain.</p>
<p>Alright. Then let&#x27;s write the code for our next test case, render the component and override the list element that contains the images:</p>
<pre><code class="hljs language-tsx">...
<span class="hljs-keyword">import</span> { setReadOnlyProperty } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../lib/test-helpers&#x27;</span>;

  ...

  it(<span class="hljs-string">&#x27;should swipe items on mouse move&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> items = createRandomItems();

    renderComponent({ items });

    <span class="hljs-keyword">const</span> containerWidth = faker.datatype.number({ <span class="hljs-attr">min</span>: <span class="hljs-number">1</span> });
    <span class="hljs-keyword">const</span> containerScrollWidth = containerWidth * items.length;

    <span class="hljs-keyword">const</span> listEl = screen.queryAllByRole(<span class="hljs-string">&#x27;list&#x27;</span>)[<span class="hljs-number">0</span>];

    <span class="hljs-comment">// override list element&#x27;s read-only properties</span>
    setReadOnlyProperty(listEl, <span class="hljs-string">&#x27;offsetWidth&#x27;</span>, containerWidth);
    setReadOnlyProperty(listEl, <span class="hljs-string">&#x27;scrollWidth&#x27;</span>, containerScrollWidth);
  });
...
</code></pre>
<p>Here, we generated a random number using <code>faker</code> for the <code>containerWidth</code> (note that it should be minimum of <code>1</code> to make our test case reliable) then multiplied it by the number of images we have for the <code>containerScrollWidth</code>.</p>
<p>Then, we used <code>screen.queryAllByRole()</code> to query an array of elements that has a role of <code>list</code>, elements declared as <code>&lt;ul&gt;</code> automatically gets an role of <code>list</code>. We couldn&#x27;t use <code>screen.queryByRole()</code> because we have another <code>&lt;ul&gt;</code> which is the list element that contains our indicators. In case you need it, you can check ther <a target="_blank" rel="noopener noreferrer nofollow" href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques#roles">list of roles</a> you could use for this query other than <code>list</code> for your future test cases.</p>
<p>After getting the list element, we then override its <code>offsetWidth</code> and <code>containerScrollWidth</code>.</p>
<p>We can now call some <code>expect()</code> method to verify a few things:</p>
<ul>
<li>It should display first image by default (<code>offsetX</code> == <code>0</code>)</li>
<li>Then do a mouse drag (fire events, <code>difference</code> of <code>x</code> &gt; <code>40</code>)</li>
<li>It should display second image (<code>offsetX</code> == <code>(negative) containerWidth</code>)</li>
</ul>
<p>To write that in code, see below:</p>
<pre><code class="hljs language-tsx">...
<span class="hljs-keyword">import</span> { fireEvent, render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span>;

  ...

  it(<span class="hljs-string">&#x27;should swipe items on mouse move&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    ...

    <span class="hljs-comment">// verify start position is 0</span>
    expect(listEl).toHaveStyle({
      <span class="hljs-attr">transform</span>: <span class="hljs-string">&#x27;translate3d(0px, 0, 0)&#x27;</span>,
    });

    <span class="hljs-keyword">let</span> startX = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> endX = -<span class="hljs-number">41</span>;

    fireEvent.mouseDown(listEl, { <span class="hljs-attr">clientX</span>: startX });
    fireEvent.mouseMove(listEl, { <span class="hljs-attr">clientX</span>: endX });
    fireEvent.mouseUp(listEl);

    <span class="hljs-comment">// verify should move to the left</span>
    expect(listEl).toHaveStyle({
      <span class="hljs-attr">transform</span>: <span class="hljs-string">`translate3d(<span class="hljs-subst">${-containerWidth}</span>px, 0, 0)`</span>,
    });
  });
...
</code></pre>
<p>We verify that the starting <code>offsetX</code> position should be <code>0</code>. We can use <code>.toHaveStyle()</code> matcher method which accepts an object that contains the style property and value we want to expect or verify.</p>
<p>We trigger the mouse events in the correct chronological order, we defined the starting <code>x</code> position, for simplicity, we can just define it as <code>0</code> and set the ending <code>x</code> position which should be negative (since we&#x27;re moving from right to left) and difference should be more than <code>40</code> (based from <code>MIN_SWIPE_REQUIRED</code>) in order for it to auto-swipe to the next image. To fire mouse events in a test environment, we can use <code>fireEvent</code> which is also from Testing Library. To fire other DOM events, you can check out the <a target="_blank" rel="noopener noreferrer nofollow" href="https://testing-library.com/docs/dom-testing-library/api-events/">documentation</a>. First argument it accepts is the element you want the event to get fired to while optionally, you can pass a second argument to provide event data or details related to the event such as <code>clientX</code> which what I did above. After the <code>mouseUp</code> event is fired, we then verify that the the list element containing our images is displaying the second image.</p>
<p>Save the changes above and let&#x27;s check our terminal to see if it passed:</p>
<img src="/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/test-coverage-incomplete-3.png" alt="Screenshot of incomplete React Swiper test coverage" loading="lazy"/>
<p>And yes it did, it also reduced the uncovered lines. We still have a few uncovered lines to cover. Let&#x27;s cover line <code>57</code> which is swiping from left to right.</p>
<p>Okay. Normally I would create another test case for this because we should try not to have a lot of <code>expect</code> functions called in a single test case, that reduces the complexity of a test case, but I think this is a reasonable special case since after we move from right to the left, we should be able to go back from left to the right without duplicating too much code in our test files.</p>
<p>So just right below the previous code we worked on, add the following code:</p>
<pre><code class="hljs language-tsx">...

  it(<span class="hljs-string">&#x27;should swipe items on mouse move&#x27;</span>, <span class="hljs-function">() =&gt;</span> {

    ...

    <span class="hljs-comment">// verify should move to the right</span>
    startX = <span class="hljs-number">0</span>;
    endX = <span class="hljs-number">41</span>;

    fireEvent.mouseDown(listEl, { <span class="hljs-attr">clientX</span>: startX });
    fireEvent.mouseMove(listEl, { <span class="hljs-attr">clientX</span>: endX });
    fireEvent.mouseUp(listEl);

    expect(listEl).toHaveStyle({
      <span class="hljs-attr">transform</span>: <span class="hljs-string">`translate3d(0px, 0, 0)`</span>,
    });
  });
...
</code></pre>
<p>The current test case should still pass once we save the changes and if we check our terminal, our uncovered lines further reduces:</p>
<img src="/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/test-coverage-incomplete-4.png" alt="Screenshot of incomplete React Swiper test coverage" loading="lazy"/>
<div><ins class="adsbygoogle block max-w-[1200px] mx-auto adUnit_adunit__Qsm4B" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<p>Alright. Let&#x27;s move on to cover line <code>61</code> which is not to auto-swipe to the next or previous image if the <code>x</code> offset difference is less than or equal to <code>40</code>. Add the following code below in the same test case:</p>
<pre><code class="hljs language-tsx">...

  it(<span class="hljs-string">&#x27;should swipe items on mouse move&#x27;</span>, <span class="hljs-function">() =&gt;</span> {

    ...

    <span class="hljs-comment">// verify should stay in position if less than minimum move</span>
    startX = <span class="hljs-number">0</span>;
    endX = -faker.datatype.number({ <span class="hljs-attr">min</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">max</span>: <span class="hljs-number">40</span> });

    fireEvent.mouseDown(listEl, { <span class="hljs-attr">clientX</span>: startX });
    fireEvent.mouseMove(listEl, { <span class="hljs-attr">clientX</span>: endX });
    fireEvent.mouseUp(listEl);

    expect(listEl).toHaveStyle({
      <span class="hljs-attr">transform</span>: <span class="hljs-string">`translate3d(0px, 0, 0)`</span>,
    });
  });
...
</code></pre>
<p>Here I used <code>faker</code> to generate a random number from <code>0</code> to <code>40</code> for the ending <code>x</code> position. The current <code>offsetX</code> of our list element is at <code>0</code> and after firing the mouse events that will drag less than <code>40</code> in difference, we will expect that the <code>offsetX</code> should still be at <code>0</code>. In case you might missed it, I added a negative sign (<code>-</code>) before the random number it as we&#x27;re trying to move the images to the left so it should be of negative value.</p>
<p>Once you saved the changes, your terminal should display something like this:</p>
<img src="/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/test-coverage-incomplete-5.png" alt="Screenshot of incomplete React Swiper test coverage" loading="lazy"/>
<p>Pass again! We&#x27;re almost there. Let&#x27;s try to cover two lines this time, which is <code>34</code> and <code>38</code>. These two lines cover the logic of preventing our <code>Swiper</code> component from swiping if it&#x27;s already at both ends. Currently the position of the list element is displaying the first image, it should not allow to swipe from left to the right since there&#x27;s already no image to display before our first image. Respectively, if we swipe from right all the way to the left, it will stop at the last image. Here&#x27;s the following code for that:</p>
<pre><code class="hljs language-tsx">...

  it(<span class="hljs-string">&#x27;should swipe items on mouse move&#x27;</span>, <span class="hljs-function">() =&gt;</span> {

    ...

    <span class="hljs-comment">// verify shouldn&#x27;t move further right if already at the start</span>
    startX = <span class="hljs-number">0</span>;
    endX = <span class="hljs-number">1</span>;

    fireEvent.mouseDown(listEl, { <span class="hljs-attr">clientX</span>: startX });
    fireEvent.mouseMove(listEl, { <span class="hljs-attr">clientX</span>: endX });
    fireEvent.mouseUp(listEl);

    expect(listEl).toHaveStyle({
      <span class="hljs-attr">transform</span>: <span class="hljs-string">`translate3d(0px, 0, 0)`</span>,
    });

    <span class="hljs-comment">// calculate the offset needed to show the last image</span>
    <span class="hljs-keyword">const</span> minOffsetX = containerScrollWidth - containerWidth;

    <span class="hljs-comment">// verify shouldn&#x27;t move further left if already at the end</span>
    startX = <span class="hljs-number">0</span>;
    endX = -(minOffsetX + <span class="hljs-number">1</span>);

    fireEvent.mouseDown(listEl, { <span class="hljs-attr">clientX</span>: startX });
    fireEvent.mouseMove(listEl, { <span class="hljs-attr">clientX</span>: endX });
    fireEvent.mouseUp(listEl);

    expect(listEl).toHaveStyle({
      <span class="hljs-attr">transform</span>: <span class="hljs-string">`translate3d(<span class="hljs-subst">${-minOffsetX}</span>px, 0, 0)`</span>,
    });
  });
});
...
</code></pre>
<p>Save the changes and let&#x27;s look at our current test coverage:</p>
<img src="/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/test-coverage-incomplete-6.png" alt="Screenshot of incomplete React Swiper test coverage" loading="lazy"/>
<div><ins class="adsbygoogle block max-w-[1200px] mx-auto adUnit_adunit__Qsm4B" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<p>We&#x27;re left with lines <code>93</code> - <code>97</code> and <code>122</code> which are the logic when clicking one of the indicators. Before that, I just want to remind you we only covered mouse events, but I still have the touch events. I&#x27;m not sure why <code>Jest</code> is not displaying line <code>103</code> as uncovered though. Anyway, they work very similarly hence, we can just copy the codes from our second test case - <code>should swipe items on mouse move</code>, create a new test case - <code>should swipe items on touch move</code>, paste the copied codes and simply replace the fired events like this:</p>
<pre><code class="hljs language-tsx">  ...

  it(<span class="hljs-string">&#x27;should swipe items on touch move&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> items = createRandomItems();

    renderComponent({ items });

    <span class="hljs-keyword">const</span> containerWidth = faker.datatype.number({ <span class="hljs-attr">min</span>: <span class="hljs-number">1</span> });
    <span class="hljs-keyword">const</span> containerScrollWidth = containerWidth * items.length;

    <span class="hljs-keyword">const</span> listEl = screen.queryAllByRole(<span class="hljs-string">&#x27;list&#x27;</span>)[<span class="hljs-number">0</span>];

    <span class="hljs-comment">// override list element&#x27;s read-only properties</span>
    setReadOnlyProperty(listEl, <span class="hljs-string">&#x27;offsetWidth&#x27;</span>, containerWidth);
    setReadOnlyProperty(listEl, <span class="hljs-string">&#x27;scrollWidth&#x27;</span>, containerScrollWidth);

    <span class="hljs-comment">// verify start position is 0</span>
    expect(listEl).toHaveStyle({
      <span class="hljs-attr">transform</span>: <span class="hljs-string">&#x27;translate3d(0px, 0, 0)&#x27;</span>,
    });

    <span class="hljs-comment">// verify should move to the left</span>
    <span class="hljs-keyword">let</span> startX = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> endX = -<span class="hljs-number">41</span>;

    fireEvent.touchStart(listEl, { <span class="hljs-attr">changedTouches</span>: [{ <span class="hljs-attr">clientX</span>: startX }] });
    fireEvent.touchMove(listEl, { <span class="hljs-attr">changedTouches</span>: [{ <span class="hljs-attr">clientX</span>: endX }] });
    fireEvent.touchEnd(listEl);

    expect(listEl).toHaveStyle({
      <span class="hljs-attr">transform</span>: <span class="hljs-string">`translate3d(<span class="hljs-subst">${-containerWidth}</span>px, 0, 0)`</span>,
    });

    <span class="hljs-comment">// verify should move to the right</span>
    startX = <span class="hljs-number">0</span>;
    endX = <span class="hljs-number">41</span>;

    fireEvent.touchStart(listEl, { <span class="hljs-attr">changedTouches</span>: [{ <span class="hljs-attr">clientX</span>: startX }] });
    fireEvent.touchMove(listEl, { <span class="hljs-attr">changedTouches</span>: [{ <span class="hljs-attr">clientX</span>: endX }] });
    fireEvent.touchEnd(listEl);

    expect(listEl).toHaveStyle({
      <span class="hljs-attr">transform</span>: <span class="hljs-string">`translate3d(0px, 0, 0)`</span>,
    });

    <span class="hljs-comment">// verify should stay in position if less than minimum move</span>
    startX = <span class="hljs-number">0</span>;
    endX = faker.datatype.number({ <span class="hljs-attr">min</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">max</span>: <span class="hljs-number">40</span> });

    fireEvent.touchStart(listEl, { <span class="hljs-attr">changedTouches</span>: [{ <span class="hljs-attr">clientX</span>: startX }] });
    fireEvent.touchMove(listEl, { <span class="hljs-attr">changedTouches</span>: [{ <span class="hljs-attr">clientX</span>: endX }] });
    fireEvent.touchEnd(listEl);

    expect(listEl).toHaveStyle({
      <span class="hljs-attr">transform</span>: <span class="hljs-string">`translate3d(0px, 0, 0)`</span>,
    });

    <span class="hljs-comment">// verify shouldn&#x27;t move further right if already at the start</span>
    startX = <span class="hljs-number">0</span>;
    endX = <span class="hljs-number">1</span>;

    fireEvent.touchStart(listEl, { <span class="hljs-attr">changedTouches</span>: [{ <span class="hljs-attr">clientX</span>: startX }] });
    fireEvent.touchMove(listEl, { <span class="hljs-attr">changedTouches</span>: [{ <span class="hljs-attr">clientX</span>: endX }] });
    fireEvent.touchEnd(listEl);

    expect(listEl).toHaveStyle({
      <span class="hljs-attr">transform</span>: <span class="hljs-string">`translate3d(0px, 0, 0)`</span>,
    });

    <span class="hljs-comment">// verify shouldn&#x27;t move further left if already at the end</span>
    <span class="hljs-keyword">const</span> minOffsetX = containerScrollWidth - containerWidth;

    startX = <span class="hljs-number">0</span>;
    endX = -(minOffsetX + <span class="hljs-number">1</span>);

    fireEvent.touchStart(listEl, { <span class="hljs-attr">changedTouches</span>: [{ <span class="hljs-attr">clientX</span>: startX }] });
    fireEvent.touchMove(listEl, { <span class="hljs-attr">changedTouches</span>: [{ <span class="hljs-attr">clientX</span>: endX }] });
    fireEvent.touchEnd(listEl);

    expect(listEl).toHaveStyle({
      <span class="hljs-attr">transform</span>: <span class="hljs-string">`translate3d(<span class="hljs-subst">${-minOffsetX}</span>px, 0, 0)`</span>,
    });
  });
...
</code></pre>
<p>And once you save the changes, our new test case would also pass.</p>
<p>Cool! We&#x27;re at our last test case for our <code>Swiper</code> component, let&#x27;s start by copying the top part of our previous test case since we can reuse that:</p>
<pre><code class="hljs language-tsx">
  ...

  it(<span class="hljs-string">&#x27;should swipe items on indicator click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> items = createRandomItems();

    renderComponent({ items });

    <span class="hljs-keyword">const</span> containerWidth = faker.datatype.number({ <span class="hljs-attr">min</span>: <span class="hljs-number">1</span> });
    <span class="hljs-keyword">const</span> containerScrollWidth = containerWidth * items.length;

    <span class="hljs-keyword">const</span> listEl = screen.queryAllByRole(<span class="hljs-string">&#x27;list&#x27;</span>)[<span class="hljs-number">0</span>];

    <span class="hljs-comment">// override list element&#x27;s read-only properties</span>
    setReadOnlyProperty(listEl, <span class="hljs-string">&#x27;offsetWidth&#x27;</span>, containerWidth);
    setReadOnlyProperty(listEl, <span class="hljs-string">&#x27;scrollWidth&#x27;</span>, containerScrollWidth);

    <span class="hljs-comment">// verify start position is 0</span>
    expect(listEl).toHaveStyle({
      <span class="hljs-attr">transform</span>: <span class="hljs-string">&#x27;translate3d(0px, 0, 0)&#x27;</span>,
    });
  });
...
</code></pre>
<div><ins class="adsbygoogle block max-w-[1200px] mx-auto adUnit_adunit__Qsm4B" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<p>Next, let&#x27;s verify that the current &quot;active&quot; indicator is the first indicator since we are initially displaying the first image. We determine an indicator is active by adding an <code>active</code> class into it. To do that, we can use another matcher function <code>.toHaveClass()</code> from the Testing Library. But first, how do we query for the first indicator? We can&#x27;t simply use <code>screen.queryAllByRole(&#x27;listitem&#x27;)</code> because it would return the images with it. Remember we added an attribute to our indicator, this one <code>data-testid=&quot;indicator&quot;</code>? Yes, with that attribute, we can use the query <code>screen.queryAllByTestId(&#x27;indicator&#x27;)</code> and that would return an array of the indicator list items. To write it in code, it would be like this:</p>
<pre><code class="hljs language-tsx">
  ...

  it(<span class="hljs-string">&#x27;should swipe items on indicator click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    ...

    <span class="hljs-keyword">const</span> firstIndicatorEl = screen.queryAllByTestId(<span class="hljs-string">&#x27;indicator&#x27;</span>)[<span class="hljs-number">0</span>];

    <span class="hljs-comment">// verify first indicator item has an &quot;active&quot; class</span>
    expect(firstIndicatorEl).toHaveClass(<span class="hljs-string">&#x27;active&#x27;</span>);
  });
...
</code></pre>
<p>Yes, that&#x27;s how simple it is!</p>
<p>Now, we need to verify that once we click on the second indicator, it should display the second image. But before that, let&#x27;s first verify the second indicator is not &quot;active&quot; with the following code:</p>
<pre><code class="hljs language-tsx">
  ...

  it(<span class="hljs-string">&#x27;should swipe items on indicator click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {

    ...

    <span class="hljs-keyword">const</span> secondIndicatorEl = screen.queryAllByTestId(<span class="hljs-string">&#x27;indicator&#x27;</span>)[<span class="hljs-number">1</span>];

    expect(secondIndicatorEl).not.toHaveClass(<span class="hljs-string">&#x27;active&#x27;</span>);
  });
...
</code></pre>
<p>Lastly, let&#x27;s trigger a mouse click event and verify that the list element containing our images move from right to the left and also verify that the new &quot;active&quot; indicator is the second. Here&#x27;s the code for that:</p>
<pre><code class="hljs language-tsx">
  ...

  it(<span class="hljs-string">&#x27;should swipe items on indicator click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {

    ...

    fireEvent.click(secondIndicatorEl);

    <span class="hljs-comment">// verify should move to the left</span>
    expect(listEl).toHaveStyle({
      <span class="hljs-attr">transform</span>: <span class="hljs-string">`translate3d(<span class="hljs-subst">${-containerWidth}</span>px, 0, 0)`</span>,
    });

    <span class="hljs-comment">// verify second indicator item has an &quot;active&quot; class</span>
    expect(secondIndicatorEl).toHaveClass(<span class="hljs-string">&#x27;active&#x27;</span>);
    expect(firstIndicatorEl).not.toHaveClass(<span class="hljs-string">&#x27;active&#x27;</span>);
  });
...
</code></pre>
<div><ins class="adsbygoogle block max-w-[1200px] mx-auto adUnit_adunit__Qsm4B" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<p>Now once you save the changes, we should be able to achieve 100% coverage with our <code>Swiper</code> component:</p>
<img src="/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/test-coverage-complete-1.png" alt="Screenshot of complete React Swiper test coverage" loading="lazy"/>
<p>Awesome! And we&#x27;re done! You&#x27;ve just built your own swiper in React and TypeScript with tests! I hope you&#x27;ve learned a lot from this post, especially those who are new to TypeScript and Jest.</p>
<p>In case you need the final code of the swiper as a reference, this is the <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/dominicarrojado/react-typescript-swiper">link</a> to the GitHub repository.</p>
<p>Please don&#x27;t forget to share this post and just a heads up, I&#x27;ll be writing more of these &quot;building your own components in React and TypeScript with tests&quot; so if you&#x27;re interested, you can come back to my blog to check it out once they&#x27;re published.</p></article><div class="w-11/12 max-w-screen-3xl mx-auto lg:w-5/6"><p class="mt-16 text-gray-400">Found an issue with this post?<!-- --> <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/dominicarrojado/dominicarrojado.github.io/issues">Report it here</a>.</p><div class="mt-24 flex justify-between items-center"><a class="group relative pr-2" href="/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests-part-1"><div class=""><div class="font-normal transition-colors duration-300 group-hover:text-black motion-reduce:transition-none dark:group-hover:text-white">How to create your own swiper, carousel or slider in React and TypeScript with tests (Part 1)</div><small class="text-gray-400 transition-colors duration-300 group-hover:text-black motion-reduce:transition-none dark:group-hover:text-white">Previous Post</small></div><svg viewBox="0 0 320 512" role="img" class="absolute top-0 bottom-0 m-auto shrink-0 w-2 h-2 text-black opacity-30 dark:text-white transform transition-transform-opacity duration-300 group-hover:opacity-100 motion-reduce:transition-none sm:w-2.5 sm:h-2.5 md:w-3 md:h-3 xl:w-3.5 xl:h-3.5 -left-5 sm:-left-7 xl:-left-8 group-hover:-translate-x-1.5"><path fill="currentColor" d="M34.52 239.03L228.87 44.69c9.37-9.37 24.57-9.37 33.94 0l22.67 22.67c9.36 9.36 9.37 24.52.04 33.9L131.49 256l154.02 154.75c9.34 9.38 9.32 24.54-.04 33.9l-22.67 22.67c-9.37 9.37-24.57 9.37-33.94 0L34.52 272.97c-9.37-9.37-9.37-24.57 0-33.94z"></path></svg></a><div></div><a class="group relative pl-2" href="/posts/local-development-setup-for-nestjs-projects-with-postgresql"><div class="text-right"><div class="font-normal transition-colors duration-300 group-hover:text-black motion-reduce:transition-none dark:group-hover:text-white">Local development setup for NestJS projects with PostgreSQL</div><small class="text-gray-400 transition-colors duration-300 group-hover:text-black motion-reduce:transition-none dark:group-hover:text-white">Next Post</small></div><svg viewBox="0 0 320 512" role="img" class="absolute top-0 bottom-0 m-auto shrink-0 w-2 h-2 text-black opacity-30 dark:text-white transform transition-transform-opacity duration-300 group-hover:opacity-100 motion-reduce:transition-none sm:w-2.5 sm:h-2.5 md:w-3 md:h-3 xl:w-3.5 xl:h-3.5 -right-5 sm:-right-7 xl:-right-8 group-hover:translate-x-1.5"><path fill="currentColor" d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"></path></svg></a></div><div class="mt-16 text-center"><a class="group inline-flex items-center font-normal select-none dark:hover:text-white transition-colors duration-300 hover:text-black group-hover:text-black motion-reduce:transition-none" href="/posts">See Latest Posts<svg viewBox="0 0 320 512" role="img" class="inline-block w-2 h-2 ml-2 text-black opacity-30 dark:text-white transform transition duration-300 group-hover:translate-x-1.5 group-hover:opacity-100 motion-reduce:transition-none sm:w-2.5 sm:h-2.5 sm:ml-2.5 md:w-3 md:h-3 md:ml-3 xl:w-3.5 xl:h-3.5"><path fill="currentColor" d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"></path></svg></a></div></div><div class="w-11/12 max-w-screen-3xl -mb-8 mx-auto pt-8 sm:-mb-10 sm:pt-10 md:-mb-12 md:pt-12 lg:w-5/6"><ins class="adsbygoogle block max-w-[1200px] mx-auto adUnit_adunit__Qsm4B" data-ad-client="ca-pub-3632473845121107" data-ad-slot="6892691691" data-ad-format="auto" data-full-width-responsive="true" data-testid="ad-unit"></ins></div></section><footer class="py-20 px-6 bg-gray-100 dark:bg-gray-850 overflow-hidden lg:overflow-auto" data-testid="footer"><ul class="relative text-center overflow-hidden motion-reduce:transition-none sm:text-lg xl:text-xl" style="height:0"><li class="absolute top-0 left-0 w-full transition-opacity duration-1000 motion-reduce:transition-none"><blockquote><!-- -->If there is no struggle, there is no progress.<!-- --></blockquote><p class="mt-1 sm:mt-2"> <!-- -->Frederick Douglass</p></li><li class="absolute top-0 left-0 w-full transition-opacity duration-1000 motion-reduce:transition-none opacity-0 pointer-events-none"><blockquote><!-- -->It&#x27;s okay to figure out murder mysteries, but you shouldn&#x27;t need to figure out code. You should be able to read it.<!-- --></blockquote><p class="mt-1 sm:mt-2"> <!-- -->Steve McConnell</p></li><li class="absolute top-0 left-0 w-full transition-opacity duration-1000 motion-reduce:transition-none opacity-0 pointer-events-none"><blockquote><!-- -->If you can&#x27;t explain it simply, you don&#x27;t understand it well enough.<!-- --></blockquote><p class="mt-1 sm:mt-2"> <!-- -->Albert Einstein</p></li><li class="absolute top-0 left-0 w-full transition-opacity duration-1000 motion-reduce:transition-none opacity-0 pointer-events-none"><blockquote><!-- -->The secret of getting ahead is getting started.<!-- --></blockquote><p class="mt-1 sm:mt-2"> <!-- -->Mark Twain</p></li></ul><ul class="max-w-full mt-10 flex flex-wrap justify-center"><li><a target="_blank" rel="noopener noreferrer nofollow" tabindex="0" href="https://www.paypal.com/paypalme/DominicArrojado" class="group inline-flex p-3 cursor-pointer sm:p-4" aria-label="Show your support and donate!"><svg viewBox="0 0 512 512" role="img" class="w-7 h-7 text-gray-400 dark:text-gray-300 transition-colors group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-white sm:w-8 sm:h-8 xl:w-9 xl:h-9"><path fill="currentColor" d="M256 416c114.9 0 208-93.1 208-208S370.9 0 256 0 48 93.1 48 208s93.1 208 208 208zM233.8 97.4V80.6c0-9.2 7.4-16.6 16.6-16.6h11.1c9.2 0 16.6 7.4 16.6 16.6v17c15.5.8 30.5 6.1 43 15.4 5.6 4.1 6.2 12.3 1.2 17.1L306 145.6c-3.8 3.7-9.5 3.8-14 1-5.4-3.4-11.4-5.1-17.8-5.1h-38.9c-9 0-16.3 8.2-16.3 18.3 0 8.2 5 15.5 12.1 17.6l62.3 18.7c25.7 7.7 43.7 32.4 43.7 60.1 0 34-26.4 61.5-59.1 62.4v16.8c0 9.2-7.4 16.6-16.6 16.6h-11.1c-9.2 0-16.6-7.4-16.6-16.6v-17c-15.5-.8-30.5-6.1-43-15.4-5.6-4.1-6.2-12.3-1.2-17.1l16.3-15.5c3.8-3.7 9.5-3.8 14-1 5.4 3.4 11.4 5.1 17.8 5.1h38.9c9 0 16.3-8.2 16.3-18.3 0-8.2-5-15.5-12.1-17.6l-62.3-18.7c-25.7-7.7-43.7-32.4-43.7-60.1.1-34 26.4-61.5 59.1-62.4zM480 352h-32.5c-19.6 26-44.6 47.7-73 64h63.8c5.3 0 9.6 3.6 9.6 8v16c0 4.4-4.3 8-9.6 8H73.6c-5.3 0-9.6-3.6-9.6-8v-16c0-4.4 4.3-8 9.6-8h63.8c-28.4-16.3-53.3-38-73-64H32c-17.7 0-32 14.3-32 32v96c0 17.7 14.3 32 32 32h448c17.7 0 32-14.3 32-32v-96c0-17.7-14.3-32-32-32z"></path></svg><span id=":R26i6:" style="position:fixed"></span></a></li><li><a target="_blank" rel="noopener noreferrer nofollow" tabindex="0" href="https://www.youtube.com/channel/UCWwV__qrzg5BYCSwO91Xhxg/videos?view=0&amp;sort=dd" class="group inline-flex p-3 cursor-pointer sm:p-4" aria-label="Watch my tech videos!"><svg viewBox="0 0 576 512" role="img" class="w-7 h-7 text-gray-400 dark:text-gray-300 transition-colors group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-white sm:w-8 sm:h-8 xl:w-9 xl:h-9"><path fill="currentColor" d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z"></path></svg><span id=":R2ai6:" style="position:fixed"></span></a></li><li><a target="_blank" rel="noopener noreferrer nofollow" tabindex="0" href="https://www.linkedin.com/in/dominic-arrojado-75ba03a9/" class="group inline-flex p-3 cursor-pointer sm:p-4" aria-label="Let&#x27;s connect on LinkedIn!"><svg viewBox="0 0 448 512" role="img" class="w-7 h-7 text-gray-400 dark:text-gray-300 transition-colors group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-white sm:w-8 sm:h-8 xl:w-9 xl:h-9"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg><span id=":R2ei6:" style="position:fixed"></span></a></li><li><a target="_blank" rel="noopener noreferrer nofollow" tabindex="0" href="https://github.com/dominicarrojado/" class="group inline-flex p-3 cursor-pointer sm:p-4" aria-label="Follow me on GitHub!"><svg viewBox="0 0 496 512" role="img" class="w-7 h-7 text-gray-400 dark:text-gray-300 transition-colors group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-white sm:w-8 sm:h-8 xl:w-9 xl:h-9"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg><span id=":R2ii6:" style="position:fixed"></span></a></li><li><a target="_blank" rel="noopener noreferrer nofollow" tabindex="0" href="mailto:dominicarrojado@gmail.com" class="group inline-flex p-3 cursor-pointer sm:p-4" aria-label="Email me!"><svg viewBox="0 0 512 512" role="img" class="w-7 h-7 text-gray-400 dark:text-gray-300 transition-colors group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-white sm:w-8 sm:h-8 xl:w-9 xl:h-9"><path fill="currentColor" d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path></svg><span id=":R2mi6:" style="position:fixed"></span></a></li></ul><p class="mt-4 text-gray-400 text-sm text-center sm:text-base lg:mt-10 xl:text-lg"><span class="font-normal"><!-- -->2023<!-- --> <!-- -->Dominic Arrojado</span> <span class="block mt-1 sm:hidden"></span><span class="hidden sm:inline"></span> <a href="/privacy-policy/">Privacy Policy</a> <!-- --><!-- --> <a href="/disclaimer/">Disclaimer</a></p></footer><footer class="fixed flex items-center justify-end bottom-0 w-full z-40"><div class="absolute bottom-3.5 right-3.5 flex items-end gap-3 ml-auto sm:bottom-4 sm:right-4 md:bottom-5 md:right-5 lg:bottom-8 lg:right-8" style="padding-right:var(--scrollbar-width, 0)"><button data-command="" data-disclosure="" aria-expanded="false" class="group text-gray-400 outline-none dark:text-gray-300 hover:text-gray-500 focus-visible:text-gray-500 dark:hover:text-white dark:focus-visible:text-white" aria-label="Subscribe"><div class="flex items-center flex-col"><div class="relative w-5 h-5 transform transition-transform-opacity-color motion-reduce:transition-none md:w-7 md:h-7 duration-700 opacity-0 -translate-y-2"><svg viewBox="0 0 448 512" role="img" class="absolute inset-0 m-auto"><path fill="currentColor" d="M224 0c-17.7 0-32 14.3-32 32V51.2C119 66 64 130.6 64 208v18.8c0 47-17.3 92.4-48.5 127.6l-7.4 8.3c-8.4 9.4-10.4 22.9-5.3 34.4S19.4 416 32 416H416c12.6 0 24-7.4 29.2-18.9s3.1-25-5.3-34.4l-7.4-8.3C401.3 319.2 384 273.9 384 226.8V208c0-77.4-55-142-128-156.8V32c0-17.7-14.3-32-32-32zm45.3 493.3c12-12 18.7-28.3 18.7-45.3H224 160c0 17 6.7 33.3 18.7 45.3s28.3 18.7 45.3 18.7s33.3-6.7 45.3-18.7z"></path></svg></div><div class="mt-2 text-3xs font-normal uppercase select-none transform transition-transform-opacity-color motion-reduce:transition-none md:text-2xs xl:text-xs duration-700 opacity-0 translate-y-3">Subscribe</div></div></button></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"how-to-create-your-own-swiper-in-react-and-typescript-with-tests-part-2","content":"\n## Introduction\n\nThis is a continuation from [Part 1](/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests-part-1).\n\n## Prerequisites\n\nTo get started with testing, first install the following package:\n\n```bash\nyarn add @testing-library/react-hooks faker@5.5.3 @types/faker@5.5.9\n```\n\nSo [`@testing-library/react-hooks`](https://github.com/testing-library/react-hooks-testing-library) allows us to create a simple test harness for React hooks that handles running them within the body of a function component, as well as providing various useful utility functions for updating the inputs and retrieving the outputs of our custom hook. This library aims to provide a testing experience as close as possible to natively using your hook from within a real component. While `faker` helps us generate massive amounts of fake (but realistic) data for testing.\n\n## Write tests for SwiperItem.tsx\n\nFor test files, I like to separate them in a folder so that it's less cluttered when viewing the main files. Now, create a new folder named `__tests__` under the `src/components`. This is where we will put the test files for the components under `src/components`.\n\nAlright, the first component we would be writing test for is `SwiperItem.tsx`. Create a file under `src/components/__tests__` and name it `SwiperItem.test.tsx`.\n\nThen let's add in the structure of the test:\n\n```tsx\nimport SwiperItem, { Props } from '../SwiperItem';\n\ndescribe('\u003cSwiperItem /\u003e', () =\u003e {});\n```\n\nAside from importing the component that we will test, we also imported the type `Props`. You'll get to see later why.\n\n`describe` is one of Jest's global functions, so with the setup of Create React App, we don't need to specifically import these global functions in our code, we can just directly use them. `describe` creates a block that groups together several related tests. So ideally the description should be describing what we are testing, for this case I used the component name. Feel free to rename it according to your preference.\n\nNext we can add a test case inside the `describe` block:\n\n```tsx\nimport SwiperItem, { Props } from '../SwiperItem';\n\ndescribe('\u003cSwiperItem /\u003e', () =\u003e {\n  it('should accept imageSrc and imageAlt props', () =\u003e {});\n});\n```\n\nAnother global function by Jest, `it` (or `test`) method runs a test. This is where we can have different test cases. Let's write our first test case:\n\n```tsx\nimport { render, screen } from '@testing-library/react';\nimport faker from 'faker';\nimport SwiperItem, { Props } from '../SwiperItem';\n\ndescribe('\u003cSwiperItem /\u003e', () =\u003e {\n  const renderComponent = (props: Props) =\u003e render(\u003cSwiperItem {...props} /\u003e);\n\n  it('should accept imageSrc and imageAlt props', () =\u003e {\n    const imageSrc = faker.image.imageUrl();\n    const imageAlt = faker.lorem.sentence();\n\n    renderComponent({ imageSrc, imageAlt });\n\n    const imageEl = screen.queryByAltText(imageAlt);\n\n    expect(imageEl).toHaveAttribute('src', imageSrc);\n  });\n});\n```\n\nOkay don't panic! I'll explain the added code one by one. So first, I created a reusable function `renderComponent` inside the `describe` block, it accepts the props of our component as an argument and calls the `render()` method from Testing Library to render our component with the passed props in a test environment. Since our test files are also in TypeScript, we still need to define the type it, that's why we imported the type `Props` here too. To learn more about the `render()` method, you can go [here](https://testing-library.com/docs/react-testing-library/api/#render). Then inside the `it` block, we generated a random image source and alternative text using `faker` library which we installed earlier. We then pass these as props to our `SwiperItem` component. After that, we can do our checks to validate that the image is rendered. To do that, we did a query by its alternative text using another method of Testing Library which is `screen.queryByAltText()`. To know all the possible queries you can do with `screen`, you can go [here](https://testing-library.com/docs/queries/about). Then finally using one of Jest's global functions, we can call the `expect()` method and pass the element returned by the query, and run what we call a matcher method `.toHaveAttribute()`, it can accept two arguments, first argument being the element attribute that you want to check and second argument is what the attribute value should match. This is one of the many custom matcher methods provided by the library called [jest-dom](https://github.com/testing-library/jest-dom#custom-matchers) which are specific to the [DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction). While you can check this [documentation](https://jestjs.io/docs/expect) for the more generic matcher methods.\n\nAlright, I hoped that explained it.\n\nTo verify if this test case did pass or not, in your terminal, run the following command:\n\n```bash\nyarn test --coverage\n```\n\nThe `--coverage` parameter will show you which how many percentage you have covered in each files of your project and/or if you have missed any line to test. Once the changes are saved and the command ran successfully, the terminal should display something like this:\n\n![Screenshot of complete React Swiper Item test coverage](/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/test-coverage-incomplete-1.png)\n\nCool, first test and we immediately hit 100% for `SwiperItem.tsx`! I can't promise the same for `Swiper.tsx` though, that will have many test cases but would be good for our learning. Alright, let's move on.\n\n---\n\n## Write tests for Swiper.tsx\n\nBefore we start writing test for `Swiper.tsx`, please make sure the contents of your `Swiper.tsx` is the same as mine, since we added quite a bit of code over there, there's a high possibility we have some difference. To ensure we are looking at the same lines of code when dealing with uncovered lines upon writing tests, please copy the code below:\n\n```tsx\nimport React, { useState, useRef } from 'react';\nimport { getRefValue, useStateRef } from '../lib/hooks';\nimport { getTouchEventData } from '../lib/dom';\nimport { SwiperItemType } from '../types';\nimport SwiperItem from './SwiperItem';\n\nimport './Swiper.css';\n\nexport type Props = {\n  items: Array\u003cSwiperItemType\u003e;\n};\n\nconst MIN_SWIPE_REQUIRED = 40;\n\nfunction Swiper({ items }: Props) {\n  const containerRef = useRef\u003cHTMLUListElement\u003e(null);\n  const containerWidthRef = useRef(0);\n  const minOffsetXRef = useRef(0);\n  const currentOffsetXRef = useRef(0);\n  const startXRef = useRef(0);\n  const [offsetX, setOffsetX, offsetXRef] = useStateRef(0);\n  const [isSwiping, setIsSwiping] = useState(false);\n  const [currentIdx, setCurrentIdx] = useState(0);\n\n  const onTouchMove = (e: TouchEvent | MouseEvent) =\u003e {\n    const currentX = getTouchEventData(e).clientX;\n    const diff = getRefValue(startXRef) - currentX;\n    let newOffsetX = getRefValue(currentOffsetXRef) - diff;\n\n    const maxOffsetX = 0;\n    const minOffsetX = getRefValue(minOffsetXRef);\n\n    if (newOffsetX \u003e maxOffsetX) {\n      newOffsetX = maxOffsetX;\n    }\n\n    if (newOffsetX \u003c minOffsetX) {\n      newOffsetX = minOffsetX;\n    }\n\n    setOffsetX(newOffsetX);\n  };\n  const onTouchEnd = () =\u003e {\n    const currentOffsetX = getRefValue(currentOffsetXRef);\n    const containerWidth = getRefValue(containerWidthRef);\n    let newOffsetX = getRefValue(offsetXRef);\n\n    const diff = currentOffsetX - newOffsetX;\n\n    // we need to check difference in absolute/positive value (if diff is more than 40px)\n    if (Math.abs(diff) \u003e MIN_SWIPE_REQUIRED) {\n      if (diff \u003e 0) {\n        // swipe to the right if diff is positive\n        newOffsetX = Math.floor(newOffsetX / containerWidth) * containerWidth;\n      } else {\n        // swipe to the left if diff is negative\n        newOffsetX = Math.ceil(newOffsetX / containerWidth) * containerWidth;\n      }\n    } else {\n      // remain in the current image\n      newOffsetX = Math.round(newOffsetX / containerWidth) * containerWidth;\n    }\n\n    setIsSwiping(false);\n    setOffsetX(newOffsetX);\n    setCurrentIdx(Math.abs(newOffsetX / containerWidth));\n\n    window.removeEventListener('touchend', onTouchEnd);\n    window.removeEventListener('touchmove', onTouchMove);\n    window.removeEventListener('mouseup', onTouchEnd);\n    window.removeEventListener('mousemove', onTouchMove);\n  };\n  const onTouchStart = (\n    e: React.TouchEvent\u003cHTMLDivElement\u003e | React.MouseEvent\u003cHTMLDivElement\u003e\n  ) =\u003e {\n    setIsSwiping(true);\n\n    currentOffsetXRef.current = getRefValue(offsetXRef);\n    startXRef.current = getTouchEventData(e).clientX;\n\n    const containerEl = getRefValue(containerRef);\n    const containerWidth = containerEl.offsetWidth;\n\n    containerWidthRef.current = containerWidth;\n    minOffsetXRef.current = containerWidth - containerEl.scrollWidth;\n\n    window.addEventListener('touchmove', onTouchMove);\n    window.addEventListener('touchend', onTouchEnd);\n    window.addEventListener('mousemove', onTouchMove);\n    window.addEventListener('mouseup', onTouchEnd);\n  };\n  const indicatorOnClick = (idx: number) =\u003e {\n    const containerEl = getRefValue(containerRef);\n    const containerWidth = containerEl.offsetWidth;\n\n    setCurrentIdx(idx);\n    setOffsetX(-(containerWidth * idx));\n  };\n\n  return (\n    \u003cdiv\n      className=\"swiper-container\"\n      onTouchStart={onTouchStart}\n      onMouseDown={onTouchStart}\n    \u003e\n      \u003cul\n        ref={containerRef}\n        className={`swiper-list ${isSwiping ? 'is-swiping' : ''}`}\n        style={{ transform: `translate3d(${offsetX}px, 0, 0)` }}\n      \u003e\n        {items.map((item, idx) =\u003e (\n          \u003cSwiperItem key={idx} {...item} /\u003e\n        ))}\n      \u003c/ul\u003e\n      \u003cul className=\"swiper-indicator\"\u003e\n        {items.map((_item, idx) =\u003e (\n          \u003cli\n            key={idx}\n            className={`swiper-indicator-item ${\n              currentIdx === idx ? 'active' : ''\n            }`}\n            onClick={() =\u003e indicatorOnClick(idx)}\n            data-testid=\"indicator\"\n          /\u003e\n        ))}\n      \u003c/ul\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default Swiper;\n```\n\nAlright, don't forget to save the changes!\n\n---\n\nCreate the file - `src/components/__tests__/Swiper.test.tsx` and let's add the first test case for it which just checks whether the images are rendered:\n\n```tsx\nimport { render, screen } from '@testing-library/react';\nimport faker from 'faker';\nimport Swiper, { Props } from '../Swiper';\n\ndescribe('\u003cSwiper /\u003e', () =\u003e {\n  const renderComponent = (props: Props) =\u003e render(\u003cSwiper {...props} /\u003e);\n  const createRandomItems = (count = 3) =\u003e {\n    const items = [];\n\n    for (let i = 0; i \u003c count; i++) {\n      items.push({\n        imageSrc: faker.image.imageUrl(),\n        imageAlt: faker.lorem.sentence(),\n      });\n    }\n\n    return items;\n  };\n\n  it('should display the images', () =\u003e {\n    const items = createRandomItems();\n\n    renderComponent({ items });\n\n    items.forEach((item) =\u003e {\n      const imageEl = screen.queryByAltText(item.imageAlt);\n\n      expect(imageEl).toHaveAttribute('src', item.imageSrc);\n    });\n  });\n});\n```\n\nMost of the code here should be familiar to you based from our test case for `SwiperItem` component. The main difference is that I created a reusable function to produce 3 image items to pass as props for our `Swiper` component. I think 3 is enough but feel free to adjust the number of items if you like. After rendering the component, I then loop through the items and query them one by one using `screen.queryByAltText()` with their alternative text, then call the `expect()` method to check whether the image is rendered with the correct image source using `.toHaveAttribute()`, similar to what we did in `SwiperItem` component.\n\nAlright, save the changes above and check your terminal, it should look something like this:\n\n![Screenshot of incomplete React Swiper test coverage](/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/test-coverage-incomplete-2.png)\n\nFrom the screenshot, there's still a few lines uncovered in our `Swiper` component, lines `26` - `41`, `44` - `71`, `76` - `90`, `93` - `97` and `122`. If you go and check these lines in `Swiper.tsx` file, majority of these are from the swipe logic. Let's cover that in our next test case. It would be slightly more complicated, we need to verify that our swipe logic works when we fire mouse or touch events.\n\nBefore we move into writing the code for the test case. We need to create a helper function for this test case. Let me explain why we need so. In a test environment, when you try to access an element property values such as `offsetWidth` and `scrollHeight` it will return you `0`. That's because these values are computed in a browser environment with a dependency on the CSS styles. Our test case in verifying the swipe logic would fail because it depends on these values. We need to change the value of these properties from `0` to any number we would want or expect. It could have been easy though if we can just do something like this `element.offsetWidth = 123` but because these values are _read-only_, we cannot simply do that. So here's where my helper function comes in to the rescue, create a file `src/lib/test-helpers.ts` and add the following code:\n\n```ts\nexport function setReadOnlyProperty\u003c\n  O extends Record\u003cstring, any\u003e,\n  K extends keyof O,\n  V extends any\n\u003e(object: O, property: K, value: V) {\n  Object.defineProperty(object, property, {\n    value,\n    configurable: true,\n  });\n}\n```\n\n---\n\nIf you're new to TypeScript, you already know Generics from when we created the `getRefValue` but you might be new to `extends` and `keyof`. Just like a [Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes) in JavaScript, you can also [extend types](https://www.typescriptlang.org/docs/handbook/2/objects.html#extending-types). While [`keyof`](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html) type operator takes an object type and produces a string or numeric literal union of its keys. In combination with Generics, I can then extend `O` and expect it to be an object (`Record\u003cstring, any`\u003e), then extend `K` to be a key (or property) of `O`, while `V` could be `any` which literally means it could be anything. With this type definition, when you use the function pass an object and a key, the key you have given must exist in the object, otherwise TypeScript would complain.\n\nAlright. Then let's write the code for our next test case, render the component and override the list element that contains the images:\n\n```tsx\n...\nimport { setReadOnlyProperty } from '../../lib/test-helpers';\n\n  ...\n\n  it('should swipe items on mouse move', () =\u003e {\n    const items = createRandomItems();\n\n    renderComponent({ items });\n\n    const containerWidth = faker.datatype.number({ min: 1 });\n    const containerScrollWidth = containerWidth * items.length;\n\n    const listEl = screen.queryAllByRole('list')[0];\n\n    // override list element's read-only properties\n    setReadOnlyProperty(listEl, 'offsetWidth', containerWidth);\n    setReadOnlyProperty(listEl, 'scrollWidth', containerScrollWidth);\n  });\n...\n```\n\nHere, we generated a random number using `faker` for the `containerWidth` (note that it should be minimum of `1` to make our test case reliable) then multiplied it by the number of images we have for the `containerScrollWidth`.\n\nThen, we used `screen.queryAllByRole()` to query an array of elements that has a role of `list`, elements declared as `\u003cul\u003e` automatically gets an role of `list`. We couldn't use `screen.queryByRole()` because we have another `\u003cul\u003e` which is the list element that contains our indicators. In case you need it, you can check ther [list of roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques#roles) you could use for this query other than `list` for your future test cases.\n\nAfter getting the list element, we then override its `offsetWidth` and `containerScrollWidth`.\n\nWe can now call some `expect()` method to verify a few things:\n\n- It should display first image by default (`offsetX` == `0`)\n- Then do a mouse drag (fire events, `difference` of `x` \u003e `40`)\n- It should display second image (`offsetX` == `(negative) containerWidth`)\n\nTo write that in code, see below:\n\n```tsx\n...\nimport { fireEvent, render, screen } from '@testing-library/react';\n\n  ...\n\n  it('should swipe items on mouse move', () =\u003e {\n    ...\n\n    // verify start position is 0\n    expect(listEl).toHaveStyle({\n      transform: 'translate3d(0px, 0, 0)',\n    });\n\n    let startX = 0;\n    let endX = -41;\n\n    fireEvent.mouseDown(listEl, { clientX: startX });\n    fireEvent.mouseMove(listEl, { clientX: endX });\n    fireEvent.mouseUp(listEl);\n\n    // verify should move to the left\n    expect(listEl).toHaveStyle({\n      transform: `translate3d(${-containerWidth}px, 0, 0)`,\n    });\n  });\n...\n```\n\nWe verify that the starting `offsetX` position should be `0`. We can use `.toHaveStyle()` matcher method which accepts an object that contains the style property and value we want to expect or verify.\n\nWe trigger the mouse events in the correct chronological order, we defined the starting `x` position, for simplicity, we can just define it as `0` and set the ending `x` position which should be negative (since we're moving from right to left) and difference should be more than `40` (based from `MIN_SWIPE_REQUIRED`) in order for it to auto-swipe to the next image. To fire mouse events in a test environment, we can use `fireEvent` which is also from Testing Library. To fire other DOM events, you can check out the [documentation](https://testing-library.com/docs/dom-testing-library/api-events/). First argument it accepts is the element you want the event to get fired to while optionally, you can pass a second argument to provide event data or details related to the event such as `clientX` which what I did above. After the `mouseUp` event is fired, we then verify that the the list element containing our images is displaying the second image.\n\nSave the changes above and let's check our terminal to see if it passed:\n\n![Screenshot of incomplete React Swiper test coverage](/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/test-coverage-incomplete-3.png)\n\nAnd yes it did, it also reduced the uncovered lines. We still have a few uncovered lines to cover. Let's cover line `57` which is swiping from left to right.\n\nOkay. Normally I would create another test case for this because we should try not to have a lot of `expect` functions called in a single test case, that reduces the complexity of a test case, but I think this is a reasonable special case since after we move from right to the left, we should be able to go back from left to the right without duplicating too much code in our test files.\n\nSo just right below the previous code we worked on, add the following code:\n\n```tsx\n...\n\n  it('should swipe items on mouse move', () =\u003e {\n\n    ...\n\n    // verify should move to the right\n    startX = 0;\n    endX = 41;\n\n    fireEvent.mouseDown(listEl, { clientX: startX });\n    fireEvent.mouseMove(listEl, { clientX: endX });\n    fireEvent.mouseUp(listEl);\n\n    expect(listEl).toHaveStyle({\n      transform: `translate3d(0px, 0, 0)`,\n    });\n  });\n...\n```\n\nThe current test case should still pass once we save the changes and if we check our terminal, our uncovered lines further reduces:\n\n![Screenshot of incomplete React Swiper test coverage](/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/test-coverage-incomplete-4.png)\n\n---\n\nAlright. Let's move on to cover line `61` which is not to auto-swipe to the next or previous image if the `x` offset difference is less than or equal to `40`. Add the following code below in the same test case:\n\n```tsx\n...\n\n  it('should swipe items on mouse move', () =\u003e {\n\n    ...\n\n    // verify should stay in position if less than minimum move\n    startX = 0;\n    endX = -faker.datatype.number({ min: 0, max: 40 });\n\n    fireEvent.mouseDown(listEl, { clientX: startX });\n    fireEvent.mouseMove(listEl, { clientX: endX });\n    fireEvent.mouseUp(listEl);\n\n    expect(listEl).toHaveStyle({\n      transform: `translate3d(0px, 0, 0)`,\n    });\n  });\n...\n```\n\nHere I used `faker` to generate a random number from `0` to `40` for the ending `x` position. The current `offsetX` of our list element is at `0` and after firing the mouse events that will drag less than `40` in difference, we will expect that the `offsetX` should still be at `0`. In case you might missed it, I added a negative sign (`-`) before the random number it as we're trying to move the images to the left so it should be of negative value.\n\nOnce you saved the changes, your terminal should display something like this:\n\n![Screenshot of incomplete React Swiper test coverage](/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/test-coverage-incomplete-5.png)\n\nPass again! We're almost there. Let's try to cover two lines this time, which is `34` and `38`. These two lines cover the logic of preventing our `Swiper` component from swiping if it's already at both ends. Currently the position of the list element is displaying the first image, it should not allow to swipe from left to the right since there's already no image to display before our first image. Respectively, if we swipe from right all the way to the left, it will stop at the last image. Here's the following code for that:\n\n```tsx\n...\n\n  it('should swipe items on mouse move', () =\u003e {\n\n    ...\n\n    // verify shouldn't move further right if already at the start\n    startX = 0;\n    endX = 1;\n\n    fireEvent.mouseDown(listEl, { clientX: startX });\n    fireEvent.mouseMove(listEl, { clientX: endX });\n    fireEvent.mouseUp(listEl);\n\n    expect(listEl).toHaveStyle({\n      transform: `translate3d(0px, 0, 0)`,\n    });\n\n    // calculate the offset needed to show the last image\n    const minOffsetX = containerScrollWidth - containerWidth;\n\n    // verify shouldn't move further left if already at the end\n    startX = 0;\n    endX = -(minOffsetX + 1);\n\n    fireEvent.mouseDown(listEl, { clientX: startX });\n    fireEvent.mouseMove(listEl, { clientX: endX });\n    fireEvent.mouseUp(listEl);\n\n    expect(listEl).toHaveStyle({\n      transform: `translate3d(${-minOffsetX}px, 0, 0)`,\n    });\n  });\n});\n...\n```\n\nSave the changes and let's look at our current test coverage:\n\n![Screenshot of incomplete React Swiper test coverage](/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/test-coverage-incomplete-6.png)\n\n---\n\nWe're left with lines `93` - `97` and `122` which are the logic when clicking one of the indicators. Before that, I just want to remind you we only covered mouse events, but I still have the touch events. I'm not sure why `Jest` is not displaying line `103` as uncovered though. Anyway, they work very similarly hence, we can just copy the codes from our second test case - `should swipe items on mouse move`, create a new test case - `should swipe items on touch move`, paste the copied codes and simply replace the fired events like this:\n\n```tsx\n  ...\n\n  it('should swipe items on touch move', () =\u003e {\n    const items = createRandomItems();\n\n    renderComponent({ items });\n\n    const containerWidth = faker.datatype.number({ min: 1 });\n    const containerScrollWidth = containerWidth * items.length;\n\n    const listEl = screen.queryAllByRole('list')[0];\n\n    // override list element's read-only properties\n    setReadOnlyProperty(listEl, 'offsetWidth', containerWidth);\n    setReadOnlyProperty(listEl, 'scrollWidth', containerScrollWidth);\n\n    // verify start position is 0\n    expect(listEl).toHaveStyle({\n      transform: 'translate3d(0px, 0, 0)',\n    });\n\n    // verify should move to the left\n    let startX = 0;\n    let endX = -41;\n\n    fireEvent.touchStart(listEl, { changedTouches: [{ clientX: startX }] });\n    fireEvent.touchMove(listEl, { changedTouches: [{ clientX: endX }] });\n    fireEvent.touchEnd(listEl);\n\n    expect(listEl).toHaveStyle({\n      transform: `translate3d(${-containerWidth}px, 0, 0)`,\n    });\n\n    // verify should move to the right\n    startX = 0;\n    endX = 41;\n\n    fireEvent.touchStart(listEl, { changedTouches: [{ clientX: startX }] });\n    fireEvent.touchMove(listEl, { changedTouches: [{ clientX: endX }] });\n    fireEvent.touchEnd(listEl);\n\n    expect(listEl).toHaveStyle({\n      transform: `translate3d(0px, 0, 0)`,\n    });\n\n    // verify should stay in position if less than minimum move\n    startX = 0;\n    endX = faker.datatype.number({ min: 0, max: 40 });\n\n    fireEvent.touchStart(listEl, { changedTouches: [{ clientX: startX }] });\n    fireEvent.touchMove(listEl, { changedTouches: [{ clientX: endX }] });\n    fireEvent.touchEnd(listEl);\n\n    expect(listEl).toHaveStyle({\n      transform: `translate3d(0px, 0, 0)`,\n    });\n\n    // verify shouldn't move further right if already at the start\n    startX = 0;\n    endX = 1;\n\n    fireEvent.touchStart(listEl, { changedTouches: [{ clientX: startX }] });\n    fireEvent.touchMove(listEl, { changedTouches: [{ clientX: endX }] });\n    fireEvent.touchEnd(listEl);\n\n    expect(listEl).toHaveStyle({\n      transform: `translate3d(0px, 0, 0)`,\n    });\n\n    // verify shouldn't move further left if already at the end\n    const minOffsetX = containerScrollWidth - containerWidth;\n\n    startX = 0;\n    endX = -(minOffsetX + 1);\n\n    fireEvent.touchStart(listEl, { changedTouches: [{ clientX: startX }] });\n    fireEvent.touchMove(listEl, { changedTouches: [{ clientX: endX }] });\n    fireEvent.touchEnd(listEl);\n\n    expect(listEl).toHaveStyle({\n      transform: `translate3d(${-minOffsetX}px, 0, 0)`,\n    });\n  });\n...\n```\n\nAnd once you save the changes, our new test case would also pass.\n\nCool! We're at our last test case for our `Swiper` component, let's start by copying the top part of our previous test case since we can reuse that:\n\n```tsx\n\n  ...\n\n  it('should swipe items on indicator click', () =\u003e {\n    const items = createRandomItems();\n\n    renderComponent({ items });\n\n    const containerWidth = faker.datatype.number({ min: 1 });\n    const containerScrollWidth = containerWidth * items.length;\n\n    const listEl = screen.queryAllByRole('list')[0];\n\n    // override list element's read-only properties\n    setReadOnlyProperty(listEl, 'offsetWidth', containerWidth);\n    setReadOnlyProperty(listEl, 'scrollWidth', containerScrollWidth);\n\n    // verify start position is 0\n    expect(listEl).toHaveStyle({\n      transform: 'translate3d(0px, 0, 0)',\n    });\n  });\n...\n```\n\n---\n\nNext, let's verify that the current \"active\" indicator is the first indicator since we are initially displaying the first image. We determine an indicator is active by adding an `active` class into it. To do that, we can use another matcher function `.toHaveClass()` from the Testing Library. But first, how do we query for the first indicator? We can't simply use `screen.queryAllByRole('listitem')` because it would return the images with it. Remember we added an attribute to our indicator, this one `data-testid=\"indicator\"`? Yes, with that attribute, we can use the query `screen.queryAllByTestId('indicator')` and that would return an array of the indicator list items. To write it in code, it would be like this:\n\n```tsx\n\n  ...\n\n  it('should swipe items on indicator click', () =\u003e {\n    ...\n\n    const firstIndicatorEl = screen.queryAllByTestId('indicator')[0];\n\n    // verify first indicator item has an \"active\" class\n    expect(firstIndicatorEl).toHaveClass('active');\n  });\n...\n```\n\nYes, that's how simple it is!\n\nNow, we need to verify that once we click on the second indicator, it should display the second image. But before that, let's first verify the second indicator is not \"active\" with the following code:\n\n```tsx\n\n  ...\n\n  it('should swipe items on indicator click', () =\u003e {\n\n    ...\n\n    const secondIndicatorEl = screen.queryAllByTestId('indicator')[1];\n\n    expect(secondIndicatorEl).not.toHaveClass('active');\n  });\n...\n```\n\nLastly, let's trigger a mouse click event and verify that the list element containing our images move from right to the left and also verify that the new \"active\" indicator is the second. Here's the code for that:\n\n```tsx\n\n  ...\n\n  it('should swipe items on indicator click', () =\u003e {\n\n    ...\n\n    fireEvent.click(secondIndicatorEl);\n\n    // verify should move to the left\n    expect(listEl).toHaveStyle({\n      transform: `translate3d(${-containerWidth}px, 0, 0)`,\n    });\n\n    // verify second indicator item has an \"active\" class\n    expect(secondIndicatorEl).toHaveClass('active');\n    expect(firstIndicatorEl).not.toHaveClass('active');\n  });\n...\n```\n\n---\n\nNow once you save the changes, we should be able to achieve 100% coverage with our `Swiper` component:\n\n![Screenshot of complete React Swiper test coverage](/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/test-coverage-complete-1.png)\n\nAwesome! And we're done! You've just built your own swiper in React and TypeScript with tests! I hope you've learned a lot from this post, especially those who are new to TypeScript and Jest.\n\nIn case you need the final code of the swiper as a reference, this is the [link](https://github.com/dominicarrojado/react-typescript-swiper) to the GitHub repository.\n\nPlease don't forget to share this post and just a heads up, I'll be writing more of these \"building your own components in React and TypeScript with tests\" so if you're interested, you can come back to my blog to check it out once they're published.\n","previousPost":{"id":"how-to-create-your-own-swiper-in-react-and-typescript-with-tests-part-1","title":"How to create your own swiper, carousel or slider in React and TypeScript with tests (Part 1)","date":"2022-02-11","excerpt":"Learn how to build a modern mobile touch swiper in a reactive and reusable way","category":"technology","videoUrl":"https://youtu.be/V0dfhBc2lj8"},"nextPost":{"id":"local-development-setup-for-nestjs-projects-with-postgresql","title":"Local development setup for NestJS projects with PostgreSQL","date":"2022-04-15","excerpt":"A quick way to get started with NestJS integrated with TypeScript, PostgreSQL and pgAdmin4 using Docker Compose","category":"technology","videoUrl":"https://youtu.be/pZNE1YMdbio"},"title":"How to create your own swiper, carousel or slider in React and TypeScript with tests (Part 2)","date":"2022-02-11","excerpt":"Learn how to build a modern mobile touch swiper in a reactive and reusable way","category":"technology","videoUrl":"https://youtu.be/V0dfhBc2lj8"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"how-to-create-your-own-swiper-in-react-and-typescript-with-tests-part-2"},"buildId":"t3qDNQ3q0ssjJDc3XqCZC","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>