<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#2c2c34"/><link rel="icon" href="https://dominicarrojado.com/favicon.ico"/><link rel="manifest" href="https://dominicarrojado.com/manifest.json"/><meta name="twitter:card" content="summary_large_image"/><meta property="og:image" content="https://dominicarrojado.com/images/pages/guides-tips-and-tricks-to-web-development.png"/><meta property="og:image:alt" content="Dominic Arrojado | Guides, Tips and Tricks to Web Development"/><meta property="og:image:type" content="image/png"/><meta property="og:image:width" content="2400"/><meta property="og:image:height" content="1254"/><meta property="og:site_name" content="Dominic Arrojado"/><link rel="preload" href="/fonts/Roboto-Light.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Light.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-LightItalic.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-LightItalic.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Regular.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Italic.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Medium.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-MediumItalic.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-MediumItalic.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-Bold.woff" as="font" type="font/woff" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-BoldItalic.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/Roboto-BoldItalic.woff" as="font" type="font/woff" crossorigin="anonymous"/><title>Building a URL shortener API with NestJS and PostgreSQL with tests (Part 2) | Dominic Arrojado</title><meta name="robots" content="index,follow"/><meta name="description" content="Learn how to build server-side applications in an efficient, reliable and scalable way"/><meta property="og:title" content="Building a URL shortener API with NestJS and PostgreSQL with tests (Part 2) | Dominic Arrojado"/><meta property="og:description" content="Learn how to build server-side applications in an efficient, reliable and scalable way"/><meta property="og:url" content="https://dominicarrojado.com/posts/building-a-link-shortener-api-with-nestjs-and-postgresql-with-tests-part-2/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2022-05-18T14:00:00Z"/><meta property="article:modified_time" content="2022-05-18T14:00:00Z"/><meta property="article:author" content="https://dominicarrojado.com/about/"/><link rel="canonical" href="https://dominicarrojado.com/posts/building-a-link-shortener-api-with-nestjs-and-postgresql-with-tests-part-2/"/><meta name="next-head-count" content="39"/><link rel="preload" href="/_next/static/css/8ec4db6d26dcc119.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8ec4db6d26dcc119.css" data-n-g=""/><link rel="preload" href="/_next/static/css/82d01f71dc75279c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/82d01f71dc75279c.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-e738bc457d1f17c7.js" defer=""></script><script src="/_next/static/chunks/framework-433e73989db4e225.js" defer=""></script><script src="/_next/static/chunks/main-c51b0b3c89045435.js" defer=""></script><script src="/_next/static/chunks/pages/_app-40efb448410a8d01.js" defer=""></script><script src="/_next/static/chunks/216-1077b041778ead2e.js" defer=""></script><script src="/_next/static/chunks/466-2aafae0e90314603.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-d86f7f746a7ea853.js" defer=""></script><script src="/_next/static/XyjuqPrSwmbsTVWRqCwV0/_buildManifest.js" defer=""></script><script src="/_next/static/XyjuqPrSwmbsTVWRqCwV0/_ssgManifest.js" defer=""></script><script src="/_next/static/XyjuqPrSwmbsTVWRqCwV0/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><noscript>
            <iframe
              src="https://www.googletagmanager.com/ns.html?id=GTM-TSMLTPT"
              height="0"
              width="0"
              style="display: none; visibility: hidden"
            ></iframe>
          </noscript><div tabindex="-1" class="h-full outline-none"><header class="fixed flex items-center top-0 w-full z-50"><a href="#main" tabindex="0" class="absolute -top-96 -left-96 w-px h-px text-center text-white overflow-hidden -z-50 focus:top-4 focus:inset-x-0 focus:m-auto focus:w-44 focus:h-auto focus:z-50 focus:sm:w-52 focus:xl:w-56">Skip to main content</a><a class="absolute top-3.5 left-3.5 flex shadow-3xl border border-white bg-gray-750 bg-opacity-90 p-1.5 z-50 transform transition ease-in-out duration-500 hover:shadow-md hover:bg-opacity-100 motion-reduce:transition-none sm:top-4 sm:left-4 md:top-5 md:left-5 md:border-2 lg:top-8 lg:left-8 opacity-0 -translate-y-full" aria-label="Dominic Arrojado logo" href="/"><svg viewBox="0 0 25750 29700" role="img" class="w-7 h-7 text-white transition-colors duration-300 sm:w-8 sm:h-8 md:w-10 md:h-10 xl:w-11 xl:h-11"><path fill="currentColor" d="M4850 19266H1025V2039l4600-129c2511 0 4500 735 5970 2206 1470 1470 2206 3423 2206 5854 0 6199-2985 9296-8951 9296zM4086 4719v11751c494 48 1025 72 1599 72 1543 0 2752-558 3624-1679s1310-2688 1310-4705c0-3684-1712-5524-5135-5524-329 0-795 28-1398 85zm17656 21711l-1437-3969h-6721l974-2655h4730l-2242-6854 1518-4167 7010 17645zM17826 435h3307L10351 29313H7044l4243-11322c1982-1513 2973-4055 2973-7627 0-171-4-340-11-506l3577-9423z"></path></svg></a><div class="absolute top-3.5 right-3.5 flex items-end gap-3 ml-auto sm:top-4 sm:right-4 sm:gap-4 md:top-5 md:right-5 md:gap-5 lg:top-8 lg:right-8 lg:gap-6" style="padding-right:0px" data-testid="header-buttons"><button type="button" aria-expanded="false" aria-controls="dialog-menu" aria-haspopup="dialog" class="group flex items-center flex-col min-w-8 outline-none md:min-w-10 xl:min-w-11" aria-label="Toggle menu"><div class="w-6 h-0.5 bg-gray-400 rounded dark:bg-gray-300 transform transition group-hover:bg-gray-500 group-focus-visible:bg-gray-500 motion-reduce:transition-none dark:group-hover:bg-white dark:group-focus-visible:bg-white md:w-7 md:h-1 xl:w-8 duration-700 opacity-0 translate-x-1/2" style="transition-delay:0ms" data-testid="menu-stack"></div><div class="w-6 h-0.5 bg-gray-400 rounded dark:bg-gray-300 transform transition group-hover:bg-gray-500 group-focus-visible:bg-gray-500 motion-reduce:transition-none dark:group-hover:bg-white dark:group-focus-visible:bg-white md:w-7 md:h-1 xl:w-8 mt-1.5 duration-700 opacity-0 -translate-x-1/2" style="transition-delay:100ms" data-testid="menu-stack"></div><div class="w-6 h-0.5 bg-gray-400 rounded dark:bg-gray-300 transform transition group-hover:bg-gray-500 group-focus-visible:bg-gray-500 motion-reduce:transition-none dark:group-hover:bg-white dark:group-focus-visible:bg-white md:w-7 md:h-1 xl:w-8 mt-1.5 duration-700 opacity-0 translate-x-1/2" style="transition-delay:200ms" data-testid="menu-stack"></div><div class="mt-1.5 text-gray-400 text-3xs font-normal uppercase select-none dark:text-gray-300 transform transition-transform-opacity-color group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-gray-100 md:mt-2 md:text-2xs xl:text-xs duration-700 opacity-0 -translate-y-3">Menu</div></button></div></header><div id="main"></div><section class="relative flex flex-col justify-center bg-gray-550 py-28 px-6 text-center overflow-hidden dark:bg-gray-750 sm:px-20 lg:px-32 min-h-96" data-testid="container"><div class="absolute top-0 left-0 w-full h-full bg-repeat bg-center invert-[.1] dark:invert-0 motion-safe:animate-slide transition-opacity duration-1250 motion-reduce:transition-none opacity-0" style="background-image:url(&#x27;/images/bg/pattern.png&#x27;)" data-testid="background"></div><div class="overflow-hidden py-2" style="opacity:1"><h1 class="text-3xl font-bold text-white leading-tight transform transition duration-700 motion-reduce:transition-none sm:text-4xl md:text-5xl lg:text-6xl xl:text-7xl opacity-0 translate-y-full">Building a URL shortener API with NestJS and PostgreSQL with tests (Part 2)</h1></div><div class="overflow-hidden" style="opacity:1"><p class="font-light text-white transform transition duration-700 motion-reduce:transition-none xl:text-2xl opacity-0 translate-y-full">Learn how to build server-side applications in an efficient, reliable and scalable way</p></div></section><section class="pt-16 pb-20 px-6 sm:pt-20 sm:pb-24 sm:px-8 md:pt-24 md:pb-28 lg:px-10 xl:pt-28 xl:pb-32 transform transition-transform-opacity duration-700 motion-reduce:transition-none opacity-0" data-testid="section"><div class="w-11/12 max-w-screen-3xl -mt-8 mx-auto pb-8 sm:-mt-10 sm:pb-10 md:-mt-12 md:pb-12 lg:w-5/6"><ins class="adsbygoogle block max-w-[1200px] mx-auto adUnit_adunit__Qsm4B" data-ad-client="ca-pub-3632473845121107" data-ad-slot="4984498713" data-ad-format="auto" data-full-width-responsive="true" data-testid="ad-unit"></ins></div><div class="flex justify-between items-center w-11/12 max-w-screen-3xl mx-auto lg:w-5/6"><div class="mr-4 text-sm text-gray-400 sm:text-base xl:text-lg">Last Updated: <time dateTime="2022-05-18">May 18, 2022</time></div><div class="rounded py-0.5 px-1.5 bg-gray-200 text-2xs capitalize dark:bg-gray-600 md:py-1 md:px-2 md:text-xs xl:text-sm">technology</div></div><div class="w-11/12 max-w-screen-3xl mt-4 mx-auto lg:w-5/6"><a class="group inline-flex items-center font-normal select-none dark:hover:text-white transition-colors duration-300 hover:text-black group-hover:text-black motion-reduce:transition-none" target="_blank" rel="noopener noreferrer nofollow" href="https://youtu.be/ysvUh_z7wjc"><svg viewBox="0 0 576 512" role="img" class="w-6 h-6 mr-2 text-gray-400 transition-colors duration-300 group-hover:text-red motion-reduce:transition-none dark:group-hover:text-white sm:w-7 sm:h-7 sm:mr-3 xl:w-8 xl:h-8"><path fill="currentColor" d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z"></path></svg> <!-- -->Watch it on YouTube<svg viewBox="0 0 320 512" role="img" class="inline-block w-2 h-2 ml-2 text-black opacity-30 dark:text-white transform transition duration-300 group-hover:translate-x-1.5 group-hover:opacity-100 motion-reduce:transition-none sm:w-2.5 sm:h-2.5 sm:ml-2.5 md:w-3 md:h-3 md:ml-3 xl:w-3.5 xl:h-3.5"><path fill="currentColor" d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"></path></svg></a></div><article class="w-11/12 max-w-screen-3xl mx-auto prose dark:prose-dark sm:prose-lg lg:w-5/6 xl:prose-xl mt-8 sm:mt-10 xl:mt-14" data-clarity-region="article" data-testid="content"><h2>Introduction</h2>
<p>This is a continuation from <a href="/posts/building-a-link-shortener-api-with-nestjs-and-postgresql-with-tests-part-1">Part 1</a>.</p>
<h2>Prerequisites for testing</h2>
<p>To get started with testing, first install the required packages:</p>
<pre><code class="hljs language-bash">yarn add -D @nestjs/testing supertest @faker-js/faker
</code></pre>
<p>The <code>@nestjs/testing</code> package provides a set of utilities that enable a more robust testing process, <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/faker-js/faker"><code>@faker-js/faker</code></a> helps us generate massive amounts of fake (but realistic) data for testing, while <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/visionmedia/supertest"><code>supertest</code></a> provides a high-level abstraction for testing and simulating HTTP requests.</p>
<h2>Test utilities</h2>
<p>There are two utility functions we would like to create and reuse when we write our test cases. First is creating the Nest application in a test environment that we could use for each test case. Second is to clear the TypeORM repositories (tables or collections) in our database before running each test case to keep any overflowing data that might affect the test results.</p>
<p>To start, create a file <code>src/test-helpers.ts</code> and add the following code for the first utility function:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { Test, TestingModule } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/testing&#x27;</span>;
<span class="hljs-keyword">import</span> { AppModule } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app.module&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createNestApplication</span>(<span class="hljs-params">{
  onBeforeInit,
}: {
  onBeforeInit: (moduleRef: TestingModule) =&gt; <span class="hljs-built_in">void</span>;
}</span>) </span>{
  <span class="hljs-keyword">const</span> moduleRef = <span class="hljs-keyword">await</span> Test.createTestingModule({
    <span class="hljs-attr">imports</span>: [AppModule],
  }).compile();

  <span class="hljs-keyword">const</span> app = moduleRef.createNestApplication();

  app.useGlobalPipes(<span class="hljs-keyword">new</span> ValidationPipe());

  onBeforeInit(moduleRef);

  <span class="hljs-keyword">await</span> app.init();

  <span class="hljs-keyword">return</span> app;
}
</code></pre>
<p>The <code>Test</code> class from <code>@nestjs/testing</code> provides an application execution context that essentially mocks the full Nest runtime, but gives you hooks that make it easy to manage class instances, including mocking and overriding. The <code>Test</code> class has a <code>createTestingModule()</code> method that takes a module metadata object as its argument (the same object you pass to the <code>@Module()</code> decorator). This method returns a <code>TestingModule</code> instance which in turn provides a few methods. For unit tests, the important one is the <code>compile()</code> method. This method bootstraps a module with its dependencies (similar to the way an application is bootstrapped in the conventional <code>main.ts</code> file using <code>NestFactory.create()</code>), and returns a module that is ready for testing. Do note that if we want to test the validation errors we will need to call <code>useGlobalPipes()</code> after creating the Nest application.</p>
<p>We won&#x27;t be doing <a target="_blank" rel="noopener noreferrer nofollow" href="https://docs.nestjs.com/fundamentals/testing#unit-testing">unit testing</a> which involves mocking and overriding. What I like to do is write <a target="_blank" rel="noopener noreferrer nofollow" href="https://docs.nestjs.com/fundamentals/testing#end-to-end-testing">end-to-end tests</a> because it covers the interaction of classes and modules at a more aggregate level - closer to the kind of interaction that end-users will have with the production system. As an application grows, it becomes hard to manually test the end-to-end behavior of each API endpoint. Automated end-to-end tests help us ensure that the overall behavior of the system is correct and meets project requirements.</p>
<p>We also added <code>onBeforeInit()</code> function which comes from the argument so that we could get modules such as the database connection and repositories depending on the features we would be testing.</p>
<p>In the same file <code>src/test-helpers.ts</code>, add the following code for the second utility function:</p>
<pre><code class="hljs language-ts">...
<span class="hljs-keyword">import</span> { Connection } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;typeorm&#x27;</span>;

...

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearRepositories</span>(<span class="hljs-params">dbConnection: Connection</span>) </span>{
  <span class="hljs-keyword">const</span> entities = dbConnection.entityMetadatas;
  <span class="hljs-keyword">const</span> promises: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;&gt; = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entity <span class="hljs-keyword">of</span> entities) {
    <span class="hljs-keyword">const</span> repository = dbConnection.getRepository(entity.name);
    promises.push(repository.clear());
  }

  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(promises);
}
</code></pre>
<p>This just iterates all the entities from the database connection, get their repository and clear it. We are accepting <code>dbConnection</code> as an argument because we could only get this once the Nest application is created, using the <code>onBeforeInit()</code>. You&#x27;ll get to see this in a bit.</p>
<div><ins class="adsbygoogle block max-w-[1200px] mx-auto adUnit_adunit__Qsm4B" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<h2>Write tests for get all the links feature</h2>
<p>Now that the utility functions are created, let&#x27;s use them and set up the tests. Create a file <code>src/links/links.spec.ts</code> and add the following code:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { INestApplication } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;
<span class="hljs-keyword">import</span> { Connection } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;typeorm&#x27;</span>;
<span class="hljs-keyword">import</span> { clearRepositories, createNestApplication } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../test-helpers&#x27;</span>;

describe(<span class="hljs-string">&#x27;Links&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">let</span> app: INestApplication;
  <span class="hljs-keyword">let</span> dbConnection: Connection;

  beforeAll(<span class="hljs-keyword">async</span> () =&gt; {
    app = <span class="hljs-keyword">await</span> createNestApplication({
      <span class="hljs-attr">onBeforeInit</span>: <span class="hljs-function">(<span class="hljs-params">moduleRef</span>) =&gt;</span> {
        dbConnection = moduleRef.get(Connection);
      },
    });
  });

  beforeEach(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> clearRepositories(dbConnection);
  });

  afterAll(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> app.close();
  });
});
</code></pre>
<p>Remember this setup as it will look similar when we create another spec (short for specification) file for other features. If you could focus on the <code>onBeforeInit()</code> function, this is how easily we could get the module, in this case <code>dbConnection</code>, from the Nest application by just passing the <code>Connection</code> class from <code>typeorm</code>. We then pass it to the <code>clearRepositories()</code> function to clear all the repositories in our database.</p>
<p>Now for the first test case, we can test the feature of getting all the links. This is how we can do it:</p>
<pre><code class="hljs language-ts">...
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;supertest&#x27;</span>;

describe(<span class="hljs-string">&#x27;Links&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  ...

  describe(<span class="hljs-string">&#x27;/links (GET)&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    it(<span class="hljs-string">&#x27;should handle without data&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request(app.getHttpServer()).get(<span class="hljs-string">&#x27;/links&#x27;</span>);

      expect(res.status).toBe(<span class="hljs-number">200</span>);
      expect(res.body).toEqual([]);
    });
  });
</code></pre>
<p>We started simple, we simulated an <a target="_blank" rel="noopener noreferrer nofollow" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET">HTTP GET method</a> request using <code>supertest</code> by executing the <code>.get()</code> function with the path, waited for the response and checked whether the <code>status</code> and <code>body</code> is what we expected. Since there&#x27;s no data in the database, we expected it to return an empty array <code>[]</code>.</p>
<p>Let&#x27;s run our application in test <strong>watch</strong> mode by executing the terminal command below:</p>
<pre><code class="hljs language-bash">yarn docker-compose:<span class="hljs-built_in">test</span>:watch
</code></pre>
<p>The test case should pass and log something like this:</p>
<pre><code class="hljs language-bash">app_1      | PASS src/links/links.spec.ts
app_1      |   Links
app_1      |     /links (GET)
app_1      |       ✓ should handle without data (74 ms)
</code></pre>
<p>Okay. Before we move to the next test case where there&#x27;s data in the database, we need to get the <code>LinksRepository</code> so we could make direct calls to the database to simulate our tests. To do that, simple update the file <code>src/links/links.spec.ts</code> with the following code below:</p>
<pre><code class="hljs language-ts">...
<span class="hljs-keyword">import</span> { LinksRepository } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./links.repository&#x27;</span>;

describe(<span class="hljs-string">&#x27;Links&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  ...
  <span class="hljs-keyword">let</span> linksRepository: LinksRepository;

  beforeAll(<span class="hljs-keyword">async</span> () =&gt; {
    app = <span class="hljs-keyword">await</span> createNestApplication({
      <span class="hljs-attr">onBeforeInit</span>: <span class="hljs-function">(<span class="hljs-params">moduleRef</span>) =&gt;</span> {
        dbConnection = moduleRef.get(Connection);
        linksRepository = moduleRef.get(LinksRepository);
      },
    });
  });
});
</code></pre>
<p>Here, we got the instance of the links repository using the <code>onBeforeInit()</code> function by passing the <code>LinksRepository</code> class in the <code>moduleRef.get()</code>. Simple, isn&#x27;t it?</p>
<p>Next, we want to create a function that creates a link in the database with random data generated from <code>faker</code> library, let&#x27;s add it in the <code>Links</code> describe block since I anticipate we&#x27;ll be going to reuse it a couple of times, update <code>src/links/links.spec.ts</code> with the following code below:</p>
<pre><code class="hljs language-ts">...
<span class="hljs-keyword">import</span> faker <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@faker-js/faker&#x27;</span>;

describe(<span class="hljs-string">&#x27;Links&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  ...
  <span class="hljs-keyword">let</span> linksRepository: LinksRepository;
  <span class="hljs-keyword">const</span> createLinkItem = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">return</span> linksRepository.createLink({
      <span class="hljs-attr">name</span>: faker.word.noun(),
      <span class="hljs-attr">url</span>: faker.internet.url(),
    });
  };

  ...
});
</code></pre>
<p>Let&#x27;s now create the second test case and update the spec file <code>src/links/links.spec.ts</code>:</p>
<pre><code class="hljs language-ts">...
<span class="hljs-keyword">import</span> { Link } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./link.entity&#x27;</span>;

describe(<span class="hljs-string">&#x27;Links&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  ...

  describe(<span class="hljs-string">&#x27;/links (GET)&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    ...

    it(<span class="hljs-string">&#x27;should handle with data&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> promises: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">Promise</span>&lt;Link&gt;&gt; = [];
      <span class="hljs-keyword">const</span> linksCount = <span class="hljs-number">3</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; linksCount; i++) {
        promises.push(createLinkItem());
      }

      <span class="hljs-keyword">const</span> links = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(promises);
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request(app.getHttpServer()).get(<span class="hljs-string">&#x27;/links&#x27;</span>);
      <span class="hljs-keyword">const</span> resBody = res.body;

      expect(res.status).toBe(<span class="hljs-number">200</span>);
      expect(resBody).toEqual(expect.arrayContaining(links));
      expect(resBody).toHaveLength(linksCount);
    });
  });
});
</code></pre>
<p>You might wonder why we didn&#x27;t just do <code>expect(res.body).toEqual(links)</code>, that&#x27;s because the order of the links in the array might be different once it is created in the database, so we used <code>arrayContaining()</code> instead to check that each items are in the expected array and we also checked that the number of items are the same using <code>toHaveLength()</code>.</p>
<p>Once we save the changes, it will automatically rerun all the tests as it is in <strong>watch</strong> mode and log the following:</p>
<pre><code class="hljs language-bash">app_1      | PASS src/links/links.spec.ts (8.539 s)
app_1      |   Links
app_1      |     /links (GET)
app_1      |       ✓ should handle without data (85 ms)
app_1      |       ✓ should handle with data (472 ms)
</code></pre>
<p>Great, we&#x27;re done with testing this feature. Let&#x27;s move to the next one ~</p>
<div><ins class="adsbygoogle block max-w-[1200px] mx-auto adUnit_adunit__Qsm4B" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<h2>Write tests for create a link feature</h2>
<p>For the next test case, we will be testing the feature to create a link. It would be something similar to our first test case, but in this case it will be the other way around. So instead of creating the link directly to the database, we create the link by calling the API first then check the database whether it was created.</p>
<p>Let&#x27;s write the test case where we pass <strong>invalid</strong> data, such as empty <code>name</code>, non-string <code>url</code>, etc. We will create a utility function that can generate a set of invalid data or payloads to be passed to the API since I anticipate we will also use it for the update a link feature:</p>
<pre><code class="hljs language-ts">...

describe(<span class="hljs-string">&#x27;Links&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  ...
  <span class="hljs-keyword">let</span> linksRepository: LinksRepository;
  <span class="hljs-keyword">const</span> createLinkBody = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">name</span>: faker.word.noun(),
      <span class="hljs-attr">url</span>: faker.internet.url(),
    };
  };
  <span class="hljs-keyword">const</span> createInvalidLinkBodies = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> validLink = createLinkBody();

    <span class="hljs-keyword">return</span> [
      <span class="hljs-comment">// invalid payload</span>
      <span class="hljs-literal">undefined</span>,
      {},

      <span class="hljs-comment">// invalid name</span>
      { <span class="hljs-attr">name</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">url</span>: validLink.url },
      { <span class="hljs-attr">name</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">url</span>: validLink.url },
      { <span class="hljs-attr">name</span>: faker.datatype.boolean(), <span class="hljs-attr">url</span>: validLink.url },
      { <span class="hljs-attr">name</span>: faker.datatype.number(), <span class="hljs-attr">url</span>: validLink.url },
      { <span class="hljs-attr">name</span>: <span class="hljs-built_in">JSON</span>.parse(faker.datatype.json()), <span class="hljs-attr">url</span>: validLink.url },
      { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">url</span>: validLink.url },

      <span class="hljs-comment">// invalid url</span>
      { <span class="hljs-attr">name</span>: validLink.name, <span class="hljs-attr">url</span>: <span class="hljs-literal">undefined</span> },
      { <span class="hljs-attr">name</span>: validLink.name, <span class="hljs-attr">url</span>: <span class="hljs-literal">null</span> },
      { <span class="hljs-attr">name</span>: validLink.name, <span class="hljs-attr">url</span>: faker.datatype.boolean() },
      { <span class="hljs-attr">name</span>: validLink.name, <span class="hljs-attr">url</span>: faker.datatype.number() },
      { <span class="hljs-attr">name</span>: validLink.name, <span class="hljs-attr">url</span>: <span class="hljs-built_in">JSON</span>.parse(faker.datatype.json()) },
      { <span class="hljs-attr">name</span>: validLink.name, <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;&#x27;</span> },
      { <span class="hljs-attr">name</span>: validLink.name, <span class="hljs-attr">url</span>: faker.word.noun() },
    ];
  };
  <span class="hljs-keyword">const</span> createLinkItem = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> linkBody = createLinkBody();

    <span class="hljs-keyword">return</span> linksRepository.createLink(linkBody);
  };

  ...

  describe(<span class="hljs-string">&#x27;/links (POST)&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    it(<span class="hljs-string">&#x27;should NOT accept invalid data&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> invalidData = createInvalidLinkBodies();
      <span class="hljs-keyword">const</span> promises: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;&gt; = [];

      invalidData.forEach(<span class="hljs-function">(<span class="hljs-params">payload</span>) =&gt;</span> {
        promises.push(
          (<span class="hljs-keyword">async</span> () =&gt; {
            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request(app.getHttpServer())
              .post(<span class="hljs-string">&#x27;/links&#x27;</span>)
              .send(payload);
            <span class="hljs-keyword">const</span> resBody = res.body;

            expect(res.status).toBe(<span class="hljs-number">400</span>);
            expect(resBody.error).toBe(<span class="hljs-string">&#x27;Bad Request&#x27;</span>);
            expect(resBody.message).toEqual(
              expect.arrayContaining([expect.any(<span class="hljs-built_in">String</span>)]),
            );
          })(),
        );
      });

      <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(promises);
    });
  });
});
</code></pre>
<p>So here, we iterated through the array of invalid data and created a <a target="_blank" rel="noopener noreferrer nofollow" href="https://developer.mozilla.org/en-US/docs/Glossary/Self-Executing_Anonymous_Function">self-invoking function</a> that is asynchronous to verify each payload and check whether we received that expected response. For the <code>message</code> inside the response body, we just check whether it is an <code>array</code> containing values of type <code>string</code> since we just use the default error messages from <code>class-validator</code> and therefore I don&#x27;t think it&#x27;s necessary to check the exact <code>string</code> value.</p>
<p>Once we save the changes, it should log something like this:</p>
<pre><code class="hljs language-bash">app_1      | PASS src/links/links.spec.ts (12.215 s)
...
app_1      |     /links (POST)
app_1      |       ✓ should NOT accept invalid data (94 ms)
</code></pre>
<p>Great, it passed as well!</p>
<p>Let&#x27;s now validate where we now pass <strong>valid</strong> data to the API. Update the file <code>src/links/links.spec.ts</code> with the following code below:</p>
<pre><code class="hljs language-ts">...

describe(<span class="hljs-string">&#x27;Links&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  ...

  describe(<span class="hljs-string">&#x27;/links (POST)&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    ...

    it(<span class="hljs-string">&#x27;should accept valid data&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> linkBody = createLinkBody();

      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request(app.getHttpServer())
        .post(<span class="hljs-string">&#x27;/links&#x27;</span>)
        .send(linkBody);
      <span class="hljs-keyword">const</span> resBody = res.body;

      expect(res.status).toBe(<span class="hljs-number">201</span>);
      expect(resBody).toEqual({
        ...linkBody,
        <span class="hljs-attr">id</span>: expect.any(<span class="hljs-built_in">String</span>),
      });

      <span class="hljs-keyword">const</span> linkId = resBody.id;
      <span class="hljs-keyword">const</span> link = <span class="hljs-keyword">await</span> linksRepository.findOne({ <span class="hljs-attr">id</span>: linkId });

      expect(link).toEqual(resBody);
    });
  });
});
</code></pre>
<p>So here, we used one of the utility functions called <code>createLinkBody()</code> that we created earlier to get a valid link body or data, passed that to the API and wait for the response, then checked whether we got the expected response. We then took the <code>id</code> from the response body and checked the database directly whether the link was created and has the same data. Cool ~</p>
<p>Of course, it should pass as well:</p>
<pre><code class="hljs language-bash">app_1      | PASS src/links/links.spec.ts (12.948 s)
...
app_1      |     /links (POST)
app_1      |       ✓ should NOT accept invalid data (133 ms)
app_1      |       ✓ should accept valid data (49 ms)
</code></pre>
<p>There&#x27;s another case we need to cover. Remember that we don&#x27;t allow link creation if the (short) <code>name</code> already exists? Let&#x27;s write the test case to validate that. Update the file <code>src/links/links.spec.ts</code> with the following code below:</p>
<pre><code class="hljs language-ts">...

describe(<span class="hljs-string">&#x27;Links&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  ...

  describe(<span class="hljs-string">&#x27;/links (POST)&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    ...

    it(<span class="hljs-string">&#x27;should handle already exists&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> existingLink = <span class="hljs-keyword">await</span> createLinkItem();
      <span class="hljs-keyword">const</span> linkBody = createLinkBody();

      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request(app.getHttpServer()).post(<span class="hljs-string">&#x27;/links&#x27;</span>).send({
        <span class="hljs-attr">name</span>: existingLink.name,
        <span class="hljs-attr">url</span>: linkBody.url,
      });
      <span class="hljs-keyword">const</span> resBody = res.body;

      expect(res.status).toBe(<span class="hljs-number">409</span>);
      expect(resBody.error).toBe(<span class="hljs-string">&#x27;Conflict&#x27;</span>);
      expect(resBody.message).toBe(<span class="hljs-string">&#x27;Short name already exists&#x27;</span>);
    });
  });
});
</code></pre>
<p>Once the changes are saved, this test case validation should be successful:</p>
<pre><code class="hljs language-bash">app_1      | PASS src/links/links.spec.ts (13.512 s)
...
app_1      |     /links (POST)
...
app_1      |       ✓ should handle already exists (26 ms)
</code></pre>
<p>Since we have an <code>if/else</code> conditional statement where the <code>if</code> condition will handle the &quot;already exists&quot; error which we have just validated in the previous test case, we will also need to validate the <code>else</code> condition to achieve complete test coverage for this feature. To do that, we can mock the <code>linksRepository.save()</code> function with the help of <code>jest.spyOn()</code> and throw an error using <code>.mockRejectedValue()</code> and pass an empty object <code>{}</code> so that <code>err.code</code> will be <code>undefined</code> - this will be handled by the <code>else</code> condition. Do note that if we mock a function, it will affect other test cases unless we restore it back to its original state using <code>.mockRestore()</code>. To write that in code, update the file <code>src/links/links.spec.ts</code> with the following below:</p>
<pre><code class="hljs language-ts">...

describe(<span class="hljs-string">&#x27;Links&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  ...

  describe(<span class="hljs-string">&#x27;/links (POST)&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    ...

    it(<span class="hljs-string">&#x27;should handle unexpected error&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> linksRepositorySaveMock = jest
        .spyOn(linksRepository, <span class="hljs-string">&#x27;save&#x27;</span>)
        .mockRejectedValue({});

      <span class="hljs-keyword">const</span> linkBody = createLinkBody();

      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request(app.getHttpServer())
        .post(<span class="hljs-string">&#x27;/links&#x27;</span>)
        .send(linkBody);
      <span class="hljs-keyword">const</span> resBody = res.body;

      expect(res.status).toBe(<span class="hljs-number">500</span>);
      expect(resBody.message).toBe(<span class="hljs-string">&#x27;Internal Server Error&#x27;</span>);

      linksRepositorySaveMock.mockRestore();
    });
  });
});
</code></pre>
<p>After saving the changes, the test case should pass:</p>
<pre><code class="hljs language-bash">app_1      | PASS src/links/links.spec.ts (13.422 s)
...
app_1      |     /links (POST)
...
app_1      |       ✓ should handle unexpected error (14 ms)
</code></pre>
<p>I hope that you&#x27;re slowly getting the hang of it and let&#x27;s move to the next feature!</p>
<div><ins class="adsbygoogle block max-w-[1200px] mx-auto adUnit_adunit__Qsm4B" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<h2>Write tests for delete a link feature</h2>
<p>Next feature to write tests for is when we delete a link. Do note that for this feature, you&#x27;ll always get a <code>string</code> for the <code>id</code> since it is part of the URL, though it might not be in a valid <code>uuid</code> format. So for the first test case of this feature, let&#x27;s validate that. And yes, you might have guessed it, we will create a utility function that generates a set of invalid <code>id</code> so we could reuse it later for the update a link feature:</p>
<pre><code class="hljs language-ts">...

describe(<span class="hljs-string">&#x27;Links&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  ...
  <span class="hljs-keyword">const</span> createInvalidLinkIds = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> [faker.datatype.number(), faker.word.noun()];
  };

  ...

  describe(<span class="hljs-string">&#x27;/links/:id (DELETE)&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    it(<span class="hljs-string">&#x27;should NOT accept invalid id&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> invalidData = createInvalidLinkIds();
      <span class="hljs-keyword">const</span> promises: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;&gt; = [];

      invalidData.forEach(<span class="hljs-function">(<span class="hljs-params">linkId</span>) =&gt;</span> {
        promises.push(
          (<span class="hljs-keyword">async</span> () =&gt; {
            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request(app.getHttpServer()).delete(
              <span class="hljs-string">`/links/<span class="hljs-subst">${linkId}</span>`</span>,
            );
            <span class="hljs-keyword">const</span> resBody = res.body;

            expect(res.status).toBe(<span class="hljs-number">400</span>);
            expect(resBody.error).toBe(<span class="hljs-string">&#x27;Bad Request&#x27;</span>);
            expect(resBody.message).toEqual(
              expect.arrayContaining([expect.any(<span class="hljs-built_in">String</span>)]),
            );
          })(),
        );
      });

      <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(promises);
    });
  });
});
</code></pre>
<p>Once we save the changes, that should pass as expected:</p>
<pre><code class="hljs language-bash">app_1      | PASS src/links/links.spec.ts (5.652 s)
...
app_1      |     /links/:id (DELETE)
app_1      |       ✓ should NOT accept invalid id (20 ms)
</code></pre>
<p>For the next test case, it should be quite easy to write. Just to refresh our memory, every test case starts with an empty database due to the <code>clearRepositories()</code> function run before each test case. So any <code>id</code> will not exist by default. We just need to generate a random <code>id</code>, call the API with that and expect to get a &quot;not found&quot; error in the response. To do that, make the following code changes:</p>
<pre><code class="hljs language-ts">...

describe(<span class="hljs-string">&#x27;Links&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  ...

  describe(<span class="hljs-string">&#x27;/links/:id (DELETE)&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    ...

    it(<span class="hljs-string">&#x27;should handle not found&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> linkId = faker.datatype.uuid();
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request(app.getHttpServer()).delete(<span class="hljs-string">`/links/<span class="hljs-subst">${linkId}</span>`</span>);
      <span class="hljs-keyword">const</span> resBody = res.body;

      expect(res.status).toBe(<span class="hljs-number">404</span>);
      expect(resBody.error).toBe(<span class="hljs-string">&#x27;Not Found&#x27;</span>);
      expect(resBody.message).toBe(<span class="hljs-string">`Link with ID: &quot;<span class="hljs-subst">${linkId}</span>&quot; not found`</span>);
    });
  });
});
</code></pre>
<p>You should be familiar with what was done here, but something new that we did though is that for the <code>message</code> in the response body, we did an exact check of the <code>string</code> value instead of just type checking, that&#x27;s because we did define that by ourselves earlier.</p>
<p>Once again this test case should pass:</p>
<pre><code class="hljs language-bash">app_1      | PASS src/links/links.spec.ts (11.199 s)
...
app_1      |     /links/:id (DELETE)
app_1      |       ✓ should NOT accept invalid id (13 ms)
app_1      |       ✓ should handle not found (11 ms)
</code></pre>
<p>For the last test case of this feature, let&#x27;s create a link directly to the database (using <code>createLinkItem()</code> function), get the <code>id</code> of it, call the API with that and expect a successful response, and as an additional check, we will also verify from the database directly whether the link is deleted. Let&#x27;s update the code with the following:</p>
<pre><code class="hljs language-ts">...

describe(<span class="hljs-string">&#x27;Links&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  ...

  describe(<span class="hljs-string">&#x27;/links/:id (DELETE)&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    ...

    it(<span class="hljs-string">&#x27;should handle delete&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> link = <span class="hljs-keyword">await</span> createLinkItem();
      <span class="hljs-keyword">const</span> linkId = link.id;

      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request(app.getHttpServer()).delete(<span class="hljs-string">`/links/<span class="hljs-subst">${linkId}</span>`</span>);

      expect(res.status).toBe(<span class="hljs-number">200</span>);

      <span class="hljs-keyword">const</span> deletedLink = <span class="hljs-keyword">await</span> linksRepository.findOne({ <span class="hljs-attr">id</span>: linkId });

      expect(deletedLink).toBeUndefined();
    });
  });
});
</code></pre>
<p>And once we save the changes, it will pass this test case as expected:</p>
<pre><code class="hljs language-bash">app_1      | PASS src/links/links.spec.ts (12.325 s)
...
app_1      |     /links/:id (DELETE)
...
app_1      |       ✓ should handle delete (39 ms)
</code></pre>
<p>Let&#x27;s move to the next feature to be tested ~</p>
<div><ins class="adsbygoogle block max-w-[1200px] mx-auto adUnit_adunit__Qsm4B" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<h2>Write tests for update a link feature</h2>
<p>For updating a link feature, all test cases except one are a combination of what we have already done for the previous features. We just have to replace the method to use <code>.put()</code>. Let&#x27;s settle those first and add the following code:</p>
<pre><code class="hljs language-ts">...

describe(<span class="hljs-string">&#x27;Links&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  ...

  describe(<span class="hljs-string">&#x27;/links/:id (PUT)&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    it(<span class="hljs-string">&#x27;should NOT accept invalid id&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> invalidData = createInvalidLinkIds();
      <span class="hljs-keyword">const</span> promises: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;&gt; = [];

      invalidData.forEach(<span class="hljs-function">(<span class="hljs-params">linkId</span>) =&gt;</span> {
        promises.push(
          (<span class="hljs-keyword">async</span> () =&gt; {
            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request(app.getHttpServer()).put(
              <span class="hljs-string">`/links/<span class="hljs-subst">${linkId}</span>`</span>,
            );
            <span class="hljs-keyword">const</span> resBody = res.body;

            expect(res.status).toBe(<span class="hljs-number">400</span>);
            expect(resBody.error).toBe(<span class="hljs-string">&#x27;Bad Request&#x27;</span>);
            expect(resBody.message).toEqual(
              expect.arrayContaining([expect.any(<span class="hljs-built_in">String</span>)]),
            );
          })(),
        );
      });

      <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(promises);
    });

    it(<span class="hljs-string">&#x27;should NOT accept invalid data&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> linkId = faker.datatype.uuid();
      <span class="hljs-keyword">const</span> invalidData = createInvalidLinkBodies();
      <span class="hljs-keyword">const</span> promises: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;&gt; = [];

      invalidData.forEach(<span class="hljs-function">(<span class="hljs-params">payload</span>) =&gt;</span> {
        promises.push(
          (<span class="hljs-keyword">async</span> () =&gt; {
            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request(app.getHttpServer())
              .put(<span class="hljs-string">`/links/<span class="hljs-subst">${linkId}</span>`</span>)
              .send(payload);
            <span class="hljs-keyword">const</span> resBody = res.body;

            expect(res.status).toBe(<span class="hljs-number">400</span>);
            expect(resBody.error).toBe(<span class="hljs-string">&#x27;Bad Request&#x27;</span>);
            expect(resBody.message).toEqual(
              expect.arrayContaining([expect.any(<span class="hljs-built_in">String</span>)]),
            );
          })(),
        );
      });

      <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(promises);
    });

    it(<span class="hljs-string">&#x27;should handle not found&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> linkId = faker.datatype.uuid();
      <span class="hljs-keyword">const</span> linkBody = createLinkBody();
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request(app.getHttpServer())
        .put(<span class="hljs-string">`/links/<span class="hljs-subst">${linkId}</span>`</span>)
        .send(linkBody);

      expect(res.status).toBe(<span class="hljs-number">404</span>);
      expect(res.body.message).toBe(<span class="hljs-string">&#x27;Not Found&#x27;</span>);
    });
  });
});
</code></pre>
<p>Save the changes and these test cases will <code>PASS</code> ✓:</p>
<pre><code class="hljs language-bash">app_1      | PASS src/links/links.spec.ts (12.076 s)
...
app_1      |     /links/:id (PUT)
app_1      |       ✓ should NOT accept invalid id (12 ms)
app_1      |       ✓ should NOT accept invalid data (45 ms)
app_1      |       ✓ should handle not found (11 ms)
</code></pre>
<p>Great. And for that one test case I mentioned earlier that we haven&#x27;t done previously is the feature itself and check whether it can update an existing link with new data, let&#x27;s write it and update with the following code below:</p>
<pre><code class="hljs language-ts">...

describe(<span class="hljs-string">&#x27;Links&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  ...

  describe(<span class="hljs-string">&#x27;/links/:id (PUT)&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    ...

    it(<span class="hljs-string">&#x27;should handle update&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> link = <span class="hljs-keyword">await</span> createLinkItem();
      <span class="hljs-keyword">const</span> linkId = link.id;
      <span class="hljs-keyword">const</span> newLinkBody = createLinkBody();

      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request(app.getHttpServer())
        .put(<span class="hljs-string">`/links/<span class="hljs-subst">${linkId}</span>`</span>)
        .send(newLinkBody);
      <span class="hljs-keyword">const</span> resBody = res.body;

      expect(res.status).toBe(<span class="hljs-number">200</span>);
      expect(resBody).toEqual({
        ...newLinkBody,
        <span class="hljs-attr">id</span>: linkId,
      });

      <span class="hljs-keyword">const</span> updatedLink = <span class="hljs-keyword">await</span> linksRepository.findOne({ <span class="hljs-attr">id</span>: linkId });

      expect(updatedLink).toEqual(resBody);
    });
  });
});
</code></pre>
<p>With the changes above, it should pass and the terminal logs should be like this:</p>
<pre><code class="hljs language-bash">app_1      | PASS src/links/links.spec.ts (12.185 s)
...
app_1      |       ✓ should handle update (30 ms)
</code></pre>
<div><ins class="adsbygoogle block max-w-[1200px] mx-auto adUnit_adunit__Qsm4B" data-ad-client="ca-pub-3632473845121107" data-ad-slot="3748487753" data-ad-format="fluid" data-ad-layout="in-article" data-full-width-responsive="true" data-testid="ad-unit"></ins></div>
<h2>Write tests for redirect to URL by name feature</h2>
<p>For the final feature we need to write tests for is the redirect to the URL by its (short) name. Since this feature is located in another module (<code>WildcardModule</code>), let&#x27;s create a new file <code>src/wildcard/wildcard.spec.ts</code> and add the same code we did for the setup earlier, let&#x27;s also keep <code>createLinkItem()</code> function and <code>linksRepository</code> as we will be needing it here too:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { INestApplication } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;supertest&#x27;</span>;
<span class="hljs-keyword">import</span> { Connection } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;typeorm&#x27;</span>;
<span class="hljs-keyword">import</span> faker <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@faker-js/faker&#x27;</span>;
<span class="hljs-keyword">import</span> { clearRepositories, createNestApplication } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../test-helpers&#x27;</span>;
<span class="hljs-keyword">import</span> { LinksRepository } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../links/links.repository&#x27;</span>;

describe(<span class="hljs-string">&#x27;Wildcard&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">let</span> app: INestApplication;
  <span class="hljs-keyword">let</span> dbConnection: Connection;
  <span class="hljs-keyword">let</span> linksRepository: LinksRepository;
  <span class="hljs-keyword">const</span> createLinkItem = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">return</span> linksRepository.createLink({
      <span class="hljs-attr">name</span>: faker.word.noun(),
      <span class="hljs-attr">url</span>: faker.internet.url(),
    });
  };

  beforeAll(<span class="hljs-keyword">async</span> () =&gt; {
    app = <span class="hljs-keyword">await</span> createNestApplication({
      <span class="hljs-attr">onBeforeInit</span>: <span class="hljs-function">(<span class="hljs-params">moduleRef</span>) =&gt;</span> {
        dbConnection = moduleRef.get(Connection);
        linksRepository = moduleRef.get(LinksRepository);
      },
    });
  });

  beforeEach(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> clearRepositories(dbConnection);
  });

  afterAll(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> app.close();
  });
});
</code></pre>
<p>Alright, for the first test case of this feature, we should get a &quot;not found&quot; error if we simulate a GET request to a non-existing name. Since you should have quite an experience now with writing tests. That should be easy, right? Try it on your own before looking at the code below:</p>
<pre><code class="hljs language-ts">...

describe(<span class="hljs-string">&#x27;Wildcard&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  ...

  describe(<span class="hljs-string">&#x27;/:name (GET)&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    it(<span class="hljs-string">&#x27;should handle not found&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> shortName = faker.word.noun();
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request(app.getHttpServer()).get(<span class="hljs-string">`/<span class="hljs-subst">${shortName}</span>`</span>);

      expect(res.status).toBe(<span class="hljs-number">404</span>);
      expect(res.body.message).toBe(<span class="hljs-string">&#x27;Not Found&#x27;</span>);
    });
  });
});
</code></pre>
<p>Did you do it on your own? I hope so! But if not, that&#x27;s fine because reaching this stage is still an achievement!</p>
<p>Once we save the changes, it should log something like this:</p>
<pre><code class="hljs language-apache"><span class="hljs-attribute">app_1</span>      | PASS src/wildcard/wildcard.spec.ts (<span class="hljs-number">16</span>.<span class="hljs-number">214</span> s)
<span class="hljs-attribute">app_1</span>      | PASS src/links/links.spec.ts (<span class="hljs-number">17</span>.<span class="hljs-number">044</span> s)
</code></pre>
<p>Great, we are down to the very last test case. Try it on your own again, I&#x27;ll explain here in text what you need to do, first create a link by making a direct call to the database, then simulate a GET request to the API with the link&#x27;s <code>name</code>, and check that the expected status code should be <code>301</code> and that it is redirecting to the URL, you can check <code>res.headers.location</code> for this.</p>
<p>Go ahead and try it ~</p>
<p>Once you&#x27;re done, verify that we have the same changes here:</p>
<pre><code class="hljs language-ts">...

describe(<span class="hljs-string">&#x27;Wildcard&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  ...

  describe(<span class="hljs-string">&#x27;/:name (GET)&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    ...

    it(<span class="hljs-string">&#x27;should handle redirect&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> link = <span class="hljs-keyword">await</span> createLinkItem();
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request(app.getHttpServer()).get(<span class="hljs-string">`/<span class="hljs-subst">${link.name}</span>`</span>);

      expect(res.status).toBe(<span class="hljs-number">301</span>);
      expect(res.headers.location).toBe(link.url);
    });
  });
});
</code></pre>
<p>And that should pass the test case as well:</p>
<pre><code class="hljs language-apache"><span class="hljs-attribute">app_1</span>      | PASS src/wildcard/wildcard.spec.ts (<span class="hljs-number">14</span>.<span class="hljs-number">112</span> s)
<span class="hljs-attribute">app_1</span>      | PASS src/links/links.spec.ts (<span class="hljs-number">18</span>.<span class="hljs-number">044</span> s)
</code></pre>
<p>If you&#x27;re curious about the code coverage from our end-to-end tests. Try running the command below in your terminal:</p>
<pre><code class="hljs language-bash">yarn docker-compose:<span class="hljs-built_in">test</span>:cov
</code></pre>
<p>You should see that we have achieved 100% coverage for both <code>LinksModule</code> and <code>WildcardModule</code>. That&#x27;s awesome!</p>
<p>And we are done! To be honest, I&#x27;m quite new in building applications with NestJS and writing this post was my way of sharpening my knowledge with this framework. So I hope you have learned a lot from this post as I have. Please don&#x27;t forget to share this post if you found it helpful, share it with your friends and colleagues who might find this helpful too.</p>
<p>In case you need the final code of the URL shortener application as a reference, here&#x27;s the <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/dominicarrojado/nestjs-postgres-url-shortener">GitHub repository</a>.</p>
<p>I&#x27;ll probably extend this post in the future and try to implement caching using <a target="_blank" rel="noopener noreferrer nofollow" href="https://redis.io/">Redis</a> or how to deploy this application to production so if you&#x27;re interested, you can come back to my blog and check it out once it is published. You can also subscribe to my <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.youtube.com/channel/UCWwV__qrzg5BYCSwO91Xhxg/videos?view=0&amp;sort=dd">YouTube channel</a> and hit that notification button. Hope to see you here again!</p></article><div class="w-11/12 max-w-screen-3xl mx-auto lg:w-5/6"><p class="mt-16 text-gray-400">Found an issue with this post?<!-- --> <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/dominicarrojado/dominicarrojado.github.io/issues">Report it here</a>.</p><div class="mt-24 flex justify-between items-center"><a class="group relative pr-2" href="/posts/building-a-link-shortener-api-with-nestjs-and-postgresql-with-tests-part-1"><div class=""><div class="font-normal transition-colors duration-300 group-hover:text-black motion-reduce:transition-none dark:group-hover:text-white">Building a URL shortener API with NestJS and PostgreSQL with tests (Part 1)</div><small class="text-gray-400 transition-colors duration-300 group-hover:text-black motion-reduce:transition-none dark:group-hover:text-white">Previous Post</small></div><svg viewBox="0 0 320 512" role="img" class="absolute top-0 bottom-0 m-auto shrink-0 w-2 h-2 text-black opacity-30 dark:text-white transform transition-transform-opacity duration-300 group-hover:opacity-100 motion-reduce:transition-none sm:w-2.5 sm:h-2.5 md:w-3 md:h-3 xl:w-3.5 xl:h-3.5 -left-5 sm:-left-7 xl:-left-8 group-hover:-translate-x-1.5"><path fill="currentColor" d="M34.52 239.03L228.87 44.69c9.37-9.37 24.57-9.37 33.94 0l22.67 22.67c9.36 9.36 9.37 24.52.04 33.9L131.49 256l154.02 154.75c9.34 9.38 9.32 24.54-.04 33.9l-22.67 22.67c-9.37 9.37-24.57 9.37-33.94 0L34.52 272.97c-9.37-9.37-9.37-24.57 0-33.94z"></path></svg></a><div></div><a class="group relative pl-2" href="/posts/local-development-setup-for-nestjs-projects-with-mongodb"><div class="text-right"><div class="font-normal transition-colors duration-300 group-hover:text-black motion-reduce:transition-none dark:group-hover:text-white">Local development setup for NestJS projects with MongoDB</div><small class="text-gray-400 transition-colors duration-300 group-hover:text-black motion-reduce:transition-none dark:group-hover:text-white">Next Post</small></div><svg viewBox="0 0 320 512" role="img" class="absolute top-0 bottom-0 m-auto shrink-0 w-2 h-2 text-black opacity-30 dark:text-white transform transition-transform-opacity duration-300 group-hover:opacity-100 motion-reduce:transition-none sm:w-2.5 sm:h-2.5 md:w-3 md:h-3 xl:w-3.5 xl:h-3.5 -right-5 sm:-right-7 xl:-right-8 group-hover:translate-x-1.5"><path fill="currentColor" d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"></path></svg></a></div><div class="mt-16 text-center"><a class="group inline-flex items-center font-normal select-none dark:hover:text-white transition-colors duration-300 hover:text-black group-hover:text-black motion-reduce:transition-none" href="/posts">See Latest Posts<svg viewBox="0 0 320 512" role="img" class="inline-block w-2 h-2 ml-2 text-black opacity-30 dark:text-white transform transition duration-300 group-hover:translate-x-1.5 group-hover:opacity-100 motion-reduce:transition-none sm:w-2.5 sm:h-2.5 sm:ml-2.5 md:w-3 md:h-3 md:ml-3 xl:w-3.5 xl:h-3.5"><path fill="currentColor" d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"></path></svg></a></div></div><div class="w-11/12 max-w-screen-3xl -mb-8 mx-auto pt-8 sm:-mb-10 sm:pt-10 md:-mb-12 md:pt-12 lg:w-5/6"><ins class="adsbygoogle block max-w-[1200px] mx-auto adUnit_adunit__Qsm4B" data-ad-client="ca-pub-3632473845121107" data-ad-slot="6892691691" data-ad-format="auto" data-full-width-responsive="true" data-testid="ad-unit"></ins></div></section><footer class="py-20 px-6 bg-gray-100 dark:bg-gray-850 overflow-hidden lg:overflow-auto" data-testid="footer"><ul class="relative text-center overflow-hidden motion-reduce:transition-none sm:text-lg xl:text-xl" style="height:0"><li class="absolute top-0 left-0 w-full transition-opacity duration-1000 motion-reduce:transition-none"><blockquote>“<!-- -->If there is no struggle, there is no progress.<!-- -->”</blockquote><p class="mt-1 sm:mt-2">— <!-- -->Frederick Douglass</p></li><li class="absolute top-0 left-0 w-full transition-opacity duration-1000 motion-reduce:transition-none opacity-0 pointer-events-none"><blockquote>“<!-- -->It&#x27;s okay to figure out murder mysteries, but you shouldn&#x27;t need to figure out code. You should be able to read it.<!-- -->”</blockquote><p class="mt-1 sm:mt-2">— <!-- -->Steve McConnell</p></li><li class="absolute top-0 left-0 w-full transition-opacity duration-1000 motion-reduce:transition-none opacity-0 pointer-events-none"><blockquote>“<!-- -->If you can&#x27;t explain it simply, you don&#x27;t understand it well enough.<!-- -->”</blockquote><p class="mt-1 sm:mt-2">— <!-- -->Albert Einstein</p></li><li class="absolute top-0 left-0 w-full transition-opacity duration-1000 motion-reduce:transition-none opacity-0 pointer-events-none"><blockquote>“<!-- -->The secret of getting ahead is getting started.<!-- -->”</blockquote><p class="mt-1 sm:mt-2">— <!-- -->Mark Twain</p></li></ul><ul class="max-w-full mt-10 flex flex-wrap justify-center"><li><a target="_blank" rel="noopener noreferrer nofollow" tabindex="0" aria-describedby="tooltip-donate" href="https://www.paypal.com/paypalme/DominicArrojado" class="group inline-flex p-3 cursor-pointer sm:p-4" aria-label="Show your support and donate!"><svg viewBox="0 0 512 512" role="img" class="w-7 h-7 text-gray-400 dark:text-gray-300 transition-colors group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-white sm:w-8 sm:h-8 xl:w-9 xl:h-9"><path fill="currentColor" d="M256 416c114.9 0 208-93.1 208-208S370.9 0 256 0 48 93.1 48 208s93.1 208 208 208zM233.8 97.4V80.6c0-9.2 7.4-16.6 16.6-16.6h11.1c9.2 0 16.6 7.4 16.6 16.6v17c15.5.8 30.5 6.1 43 15.4 5.6 4.1 6.2 12.3 1.2 17.1L306 145.6c-3.8 3.7-9.5 3.8-14 1-5.4-3.4-11.4-5.1-17.8-5.1h-38.9c-9 0-16.3 8.2-16.3 18.3 0 8.2 5 15.5 12.1 17.6l62.3 18.7c25.7 7.7 43.7 32.4 43.7 60.1 0 34-26.4 61.5-59.1 62.4v16.8c0 9.2-7.4 16.6-16.6 16.6h-11.1c-9.2 0-16.6-7.4-16.6-16.6v-17c-15.5-.8-30.5-6.1-43-15.4-5.6-4.1-6.2-12.3-1.2-17.1l16.3-15.5c3.8-3.7 9.5-3.8 14-1 5.4 3.4 11.4 5.1 17.8 5.1h38.9c9 0 16.3-8.2 16.3-18.3 0-8.2-5-15.5-12.1-17.6l-62.3-18.7c-25.7-7.7-43.7-32.4-43.7-60.1.1-34 26.4-61.5 59.1-62.4zM480 352h-32.5c-19.6 26-44.6 47.7-73 64h63.8c5.3 0 9.6 3.6 9.6 8v16c0 4.4-4.3 8-9.6 8H73.6c-5.3 0-9.6-3.6-9.6-8v-16c0-4.4 4.3-8 9.6-8h63.8c-28.4-16.3-53.3-38-73-64H32c-17.7 0-32 14.3-32 32v96c0 17.7 14.3 32 32 32h448c17.7 0 32-14.3 32-32v-96c0-17.7-14.3-32-32-32z"></path></svg></a></li><li><a target="_blank" rel="noopener noreferrer nofollow" tabindex="0" aria-describedby="tooltip-youtube" href="https://www.youtube.com/channel/UCWwV__qrzg5BYCSwO91Xhxg/videos?view=0&amp;sort=dd" class="group inline-flex p-3 cursor-pointer sm:p-4" aria-label="Watch my tech videos!"><svg viewBox="0 0 576 512" role="img" class="w-7 h-7 text-gray-400 dark:text-gray-300 transition-colors group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-white sm:w-8 sm:h-8 xl:w-9 xl:h-9"><path fill="currentColor" d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z"></path></svg></a></li><li><a target="_blank" rel="noopener noreferrer nofollow" tabindex="0" aria-describedby="tooltip-linkedin" href="https://www.linkedin.com/in/dominic-arrojado-75ba03a9/" class="group inline-flex p-3 cursor-pointer sm:p-4" aria-label="Let&#x27;s connect on LinkedIn!"><svg viewBox="0 0 448 512" role="img" class="w-7 h-7 text-gray-400 dark:text-gray-300 transition-colors group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-white sm:w-8 sm:h-8 xl:w-9 xl:h-9"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a></li><li><a target="_blank" rel="noopener noreferrer nofollow" tabindex="0" aria-describedby="tooltip-github" href="https://github.com/dominicarrojado/" class="group inline-flex p-3 cursor-pointer sm:p-4" aria-label="Follow me on GitHub!"><svg viewBox="0 0 496 512" role="img" class="w-7 h-7 text-gray-400 dark:text-gray-300 transition-colors group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-white sm:w-8 sm:h-8 xl:w-9 xl:h-9"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a></li><li><a target="_blank" rel="noopener noreferrer nofollow" tabindex="0" aria-describedby="tooltip-email" href="mailto:dominicarrojado@gmail.com" class="group inline-flex p-3 cursor-pointer sm:p-4" aria-label="Email me!"><svg viewBox="0 0 512 512" role="img" class="w-7 h-7 text-gray-400 dark:text-gray-300 transition-colors group-hover:text-gray-500 motion-reduce:transition-none dark:group-hover:text-white sm:w-8 sm:h-8 xl:w-9 xl:h-9"><path fill="currentColor" d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path></svg></a></li></ul><p class="mt-4 text-gray-400 text-sm text-center sm:text-base lg:mt-10 xl:text-lg"><span class="font-normal">©<!-- -->2023<!-- --> <!-- -->Dominic Arrojado</span> <span class="block mt-1 sm:hidden"></span><span class="hidden sm:inline">·</span> <a href="/privacy-policy/">Privacy Policy</a> <!-- -->·<!-- --> <a href="/disclaimer/">Disclaimer</a></p></footer><footer class="fixed flex items-center justify-end bottom-0 w-full z-50"><div class="absolute bottom-3.5 right-3.5 flex items-end gap-3 ml-auto sm:bottom-4 sm:right-4 md:bottom-5 md:right-5 lg:bottom-8 lg:right-8" style="padding-right:0px"><button type="button" aria-expanded="false" aria-controls="dialog-subscribe" aria-haspopup="dialog" class="group text-gray-400 outline-none dark:text-gray-300 hover:text-gray-500 focus-visible:text-gray-500 dark:hover:text-white dark:focus-visible:text-white" aria-label="Subscribe"><div class="flex items-center flex-col"><div class="relative w-5 h-5 transform transition-transform-opacity-color motion-reduce:transition-none md:w-7 md:h-7 duration-700 opacity-0 -translate-y-2"><svg viewBox="0 0 448 512" role="img" class="absolute inset-0 m-auto"><path fill="currentColor" d="M224 0c-17.7 0-32 14.3-32 32V51.2C119 66 64 130.6 64 208v18.8c0 47-17.3 92.4-48.5 127.6l-7.4 8.3c-8.4 9.4-10.4 22.9-5.3 34.4S19.4 416 32 416H416c12.6 0 24-7.4 29.2-18.9s3.1-25-5.3-34.4l-7.4-8.3C401.3 319.2 384 273.9 384 226.8V208c0-77.4-55-142-128-156.8V32c0-17.7-14.3-32-32-32zm45.3 493.3c12-12 18.7-28.3 18.7-45.3H224 160c0 17 6.7 33.3 18.7 45.3s28.3 18.7 45.3 18.7s33.3-6.7 45.3-18.7z"></path></svg></div><div class="mt-2 text-3xs font-normal uppercase select-none transform transition-transform-opacity-color motion-reduce:transition-none md:text-2xs xl:text-xs duration-700 opacity-0 translate-y-3">Subscribe</div></div></button></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"building-a-link-shortener-api-with-nestjs-and-postgresql-with-tests-part-2","content":"\n## Introduction\n\nThis is a continuation from [Part 1](/posts/building-a-link-shortener-api-with-nestjs-and-postgresql-with-tests-part-1).\n\n## Prerequisites for testing\n\nTo get started with testing, first install the required packages:\n\n```bash\nyarn add -D @nestjs/testing supertest @faker-js/faker\n```\n\nThe `@nestjs/testing` package provides a set of utilities that enable a more robust testing process, [`@faker-js/faker`](https://github.com/faker-js/faker) helps us generate massive amounts of fake (but realistic) data for testing, while [`supertest`](https://github.com/visionmedia/supertest) provides a high-level abstraction for testing and simulating HTTP requests.\n\n## Test utilities\n\nThere are two utility functions we would like to create and reuse when we write our test cases. First is creating the Nest application in a test environment that we could use for each test case. Second is to clear the TypeORM repositories (tables or collections) in our database before running each test case to keep any overflowing data that might affect the test results.\n\nTo start, create a file `src/test-helpers.ts` and add the following code for the first utility function:\n\n```ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { AppModule } from './app.module';\n\nexport async function createNestApplication({\n  onBeforeInit,\n}: {\n  onBeforeInit: (moduleRef: TestingModule) =\u003e void;\n}) {\n  const moduleRef = await Test.createTestingModule({\n    imports: [AppModule],\n  }).compile();\n\n  const app = moduleRef.createNestApplication();\n\n  app.useGlobalPipes(new ValidationPipe());\n\n  onBeforeInit(moduleRef);\n\n  await app.init();\n\n  return app;\n}\n```\n\nThe `Test` class from `@nestjs/testing` provides an application execution context that essentially mocks the full Nest runtime, but gives you hooks that make it easy to manage class instances, including mocking and overriding. The `Test` class has a `createTestingModule()` method that takes a module metadata object as its argument (the same object you pass to the `@Module()` decorator). This method returns a `TestingModule` instance which in turn provides a few methods. For unit tests, the important one is the `compile()` method. This method bootstraps a module with its dependencies (similar to the way an application is bootstrapped in the conventional `main.ts` file using `NestFactory.create()`), and returns a module that is ready for testing. Do note that if we want to test the validation errors we will need to call `useGlobalPipes()` after creating the Nest application.\n\nWe won't be doing [unit testing](https://docs.nestjs.com/fundamentals/testing#unit-testing) which involves mocking and overriding. What I like to do is write [end-to-end tests](https://docs.nestjs.com/fundamentals/testing#end-to-end-testing) because it covers the interaction of classes and modules at a more aggregate level - closer to the kind of interaction that end-users will have with the production system. As an application grows, it becomes hard to manually test the end-to-end behavior of each API endpoint. Automated end-to-end tests help us ensure that the overall behavior of the system is correct and meets project requirements.\n\nWe also added `onBeforeInit()` function which comes from the argument so that we could get modules such as the database connection and repositories depending on the features we would be testing.\n\nIn the same file `src/test-helpers.ts`, add the following code for the second utility function:\n\n```ts\n...\nimport { Connection } from 'typeorm';\n\n...\n\nexport async function clearRepositories(dbConnection: Connection) {\n  const entities = dbConnection.entityMetadatas;\n  const promises: Array\u003cPromise\u003cvoid\u003e\u003e = [];\n\n  for (const entity of entities) {\n    const repository = dbConnection.getRepository(entity.name);\n    promises.push(repository.clear());\n  }\n\n  await Promise.all(promises);\n}\n```\n\nThis just iterates all the entities from the database connection, get their repository and clear it. We are accepting `dbConnection` as an argument because we could only get this once the Nest application is created, using the `onBeforeInit()`. You'll get to see this in a bit.\n\n---\n\n## Write tests for get all the links feature\n\nNow that the utility functions are created, let's use them and set up the tests. Create a file `src/links/links.spec.ts` and add the following code:\n\n```ts\nimport { INestApplication } from '@nestjs/common';\nimport { Connection } from 'typeorm';\nimport { clearRepositories, createNestApplication } from '../test-helpers';\n\ndescribe('Links', () =\u003e {\n  let app: INestApplication;\n  let dbConnection: Connection;\n\n  beforeAll(async () =\u003e {\n    app = await createNestApplication({\n      onBeforeInit: (moduleRef) =\u003e {\n        dbConnection = moduleRef.get(Connection);\n      },\n    });\n  });\n\n  beforeEach(async () =\u003e {\n    await clearRepositories(dbConnection);\n  });\n\n  afterAll(async () =\u003e {\n    await app.close();\n  });\n});\n```\n\nRemember this setup as it will look similar when we create another spec (short for specification) file for other features. If you could focus on the `onBeforeInit()` function, this is how easily we could get the module, in this case `dbConnection`, from the Nest application by just passing the `Connection` class from `typeorm`. We then pass it to the `clearRepositories()` function to clear all the repositories in our database.\n\nNow for the first test case, we can test the feature of getting all the links. This is how we can do it:\n\n```ts\n...\nimport * as request from 'supertest';\n\ndescribe('Links', () =\u003e {\n  ...\n\n  describe('/links (GET)', () =\u003e {\n    it('should handle without data', async () =\u003e {\n      const res = await request(app.getHttpServer()).get('/links');\n\n      expect(res.status).toBe(200);\n      expect(res.body).toEqual([]);\n    });\n  });\n```\n\nWe started simple, we simulated an [HTTP GET method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET) request using `supertest` by executing the `.get()` function with the path, waited for the response and checked whether the `status` and `body` is what we expected. Since there's no data in the database, we expected it to return an empty array `[]`.\n\nLet's run our application in test **watch** mode by executing the terminal command below:\n\n```bash\nyarn docker-compose:test:watch\n```\n\nThe test case should pass and log something like this:\n\n```bash\napp_1      | PASS src/links/links.spec.ts\napp_1      |   Links\napp_1      |     /links (GET)\napp_1      |       ✓ should handle without data (74 ms)\n```\n\nOkay. Before we move to the next test case where there's data in the database, we need to get the `LinksRepository` so we could make direct calls to the database to simulate our tests. To do that, simple update the file `src/links/links.spec.ts` with the following code below:\n\n```ts\n...\nimport { LinksRepository } from './links.repository';\n\ndescribe('Links', () =\u003e {\n  ...\n  let linksRepository: LinksRepository;\n\n  beforeAll(async () =\u003e {\n    app = await createNestApplication({\n      onBeforeInit: (moduleRef) =\u003e {\n        dbConnection = moduleRef.get(Connection);\n        linksRepository = moduleRef.get(LinksRepository);\n      },\n    });\n  });\n});\n```\n\nHere, we got the instance of the links repository using the `onBeforeInit()` function by passing the `LinksRepository` class in the `moduleRef.get()`. Simple, isn't it?\n\nNext, we want to create a function that creates a link in the database with random data generated from `faker` library, let's add it in the `Links` describe block since I anticipate we'll be going to reuse it a couple of times, update `src/links/links.spec.ts` with the following code below:\n\n```ts\n...\nimport faker from '@faker-js/faker';\n\ndescribe('Links', () =\u003e {\n  ...\n  let linksRepository: LinksRepository;\n  const createLinkItem = async () =\u003e {\n    return linksRepository.createLink({\n      name: faker.word.noun(),\n      url: faker.internet.url(),\n    });\n  };\n\n  ...\n});\n```\n\nLet's now create the second test case and update the spec file `src/links/links.spec.ts`:\n\n```ts\n...\nimport { Link } from './link.entity';\n\ndescribe('Links', () =\u003e {\n  ...\n\n  describe('/links (GET)', () =\u003e {\n    ...\n\n    it('should handle with data', async () =\u003e {\n      const promises: Array\u003cPromise\u003cLink\u003e\u003e = [];\n      const linksCount = 3;\n\n      for (let i = 0; i \u003c linksCount; i++) {\n        promises.push(createLinkItem());\n      }\n\n      const links = await Promise.all(promises);\n      const res = await request(app.getHttpServer()).get('/links');\n      const resBody = res.body;\n\n      expect(res.status).toBe(200);\n      expect(resBody).toEqual(expect.arrayContaining(links));\n      expect(resBody).toHaveLength(linksCount);\n    });\n  });\n});\n```\n\nYou might wonder why we didn't just do `expect(res.body).toEqual(links)`, that's because the order of the links in the array might be different once it is created in the database, so we used `arrayContaining()` instead to check that each items are in the expected array and we also checked that the number of items are the same using `toHaveLength()`.\n\nOnce we save the changes, it will automatically rerun all the tests as it is in **watch** mode and log the following:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (8.539 s)\napp_1      |   Links\napp_1      |     /links (GET)\napp_1      |       ✓ should handle without data (85 ms)\napp_1      |       ✓ should handle with data (472 ms)\n```\n\nGreat, we're done with testing this feature. Let's move to the next one ~\n\n---\n\n## Write tests for create a link feature\n\nFor the next test case, we will be testing the feature to create a link. It would be something similar to our first test case, but in this case it will be the other way around. So instead of creating the link directly to the database, we create the link by calling the API first then check the database whether it was created.\n\nLet's write the test case where we pass **invalid** data, such as empty `name`, non-string `url`, etc. We will create a utility function that can generate a set of invalid data or payloads to be passed to the API since I anticipate we will also use it for the update a link feature:\n\n```ts\n...\n\ndescribe('Links', () =\u003e {\n  ...\n  let linksRepository: LinksRepository;\n  const createLinkBody = () =\u003e {\n    return {\n      name: faker.word.noun(),\n      url: faker.internet.url(),\n    };\n  };\n  const createInvalidLinkBodies = () =\u003e {\n    const validLink = createLinkBody();\n\n    return [\n      // invalid payload\n      undefined,\n      {},\n\n      // invalid name\n      { name: undefined, url: validLink.url },\n      { name: null, url: validLink.url },\n      { name: faker.datatype.boolean(), url: validLink.url },\n      { name: faker.datatype.number(), url: validLink.url },\n      { name: JSON.parse(faker.datatype.json()), url: validLink.url },\n      { name: '', url: validLink.url },\n\n      // invalid url\n      { name: validLink.name, url: undefined },\n      { name: validLink.name, url: null },\n      { name: validLink.name, url: faker.datatype.boolean() },\n      { name: validLink.name, url: faker.datatype.number() },\n      { name: validLink.name, url: JSON.parse(faker.datatype.json()) },\n      { name: validLink.name, url: '' },\n      { name: validLink.name, url: faker.word.noun() },\n    ];\n  };\n  const createLinkItem = async () =\u003e {\n    const linkBody = createLinkBody();\n\n    return linksRepository.createLink(linkBody);\n  };\n\n  ...\n\n  describe('/links (POST)', () =\u003e {\n    it('should NOT accept invalid data', async () =\u003e {\n      const invalidData = createInvalidLinkBodies();\n      const promises: Array\u003cPromise\u003cvoid\u003e\u003e = [];\n\n      invalidData.forEach((payload) =\u003e {\n        promises.push(\n          (async () =\u003e {\n            const res = await request(app.getHttpServer())\n              .post('/links')\n              .send(payload);\n            const resBody = res.body;\n\n            expect(res.status).toBe(400);\n            expect(resBody.error).toBe('Bad Request');\n            expect(resBody.message).toEqual(\n              expect.arrayContaining([expect.any(String)]),\n            );\n          })(),\n        );\n      });\n\n      await Promise.all(promises);\n    });\n  });\n});\n```\n\nSo here, we iterated through the array of invalid data and created a [self-invoking function](https://developer.mozilla.org/en-US/docs/Glossary/Self-Executing_Anonymous_Function) that is asynchronous to verify each payload and check whether we received that expected response. For the `message` inside the response body, we just check whether it is an `array` containing values of type `string` since we just use the default error messages from `class-validator` and therefore I don't think it's necessary to check the exact `string` value.\n\nOnce we save the changes, it should log something like this:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (12.215 s)\n...\napp_1      |     /links (POST)\napp_1      |       ✓ should NOT accept invalid data (94 ms)\n```\n\nGreat, it passed as well!\n\nLet's now validate where we now pass **valid** data to the API. Update the file `src/links/links.spec.ts` with the following code below:\n\n```ts\n...\n\ndescribe('Links', () =\u003e {\n  ...\n\n  describe('/links (POST)', () =\u003e {\n    ...\n\n    it('should accept valid data', async () =\u003e {\n      const linkBody = createLinkBody();\n\n      const res = await request(app.getHttpServer())\n        .post('/links')\n        .send(linkBody);\n      const resBody = res.body;\n\n      expect(res.status).toBe(201);\n      expect(resBody).toEqual({\n        ...linkBody,\n        id: expect.any(String),\n      });\n\n      const linkId = resBody.id;\n      const link = await linksRepository.findOne({ id: linkId });\n\n      expect(link).toEqual(resBody);\n    });\n  });\n});\n```\n\nSo here, we used one of the utility functions called `createLinkBody()` that we created earlier to get a valid link body or data, passed that to the API and wait for the response, then checked whether we got the expected response. We then took the `id` from the response body and checked the database directly whether the link was created and has the same data. Cool ~\n\nOf course, it should pass as well:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (12.948 s)\n...\napp_1      |     /links (POST)\napp_1      |       ✓ should NOT accept invalid data (133 ms)\napp_1      |       ✓ should accept valid data (49 ms)\n```\n\nThere's another case we need to cover. Remember that we don't allow link creation if the (short) `name` already exists? Let's write the test case to validate that. Update the file `src/links/links.spec.ts` with the following code below:\n\n```ts\n...\n\ndescribe('Links', () =\u003e {\n  ...\n\n  describe('/links (POST)', () =\u003e {\n    ...\n\n    it('should handle already exists', async () =\u003e {\n      const existingLink = await createLinkItem();\n      const linkBody = createLinkBody();\n\n      const res = await request(app.getHttpServer()).post('/links').send({\n        name: existingLink.name,\n        url: linkBody.url,\n      });\n      const resBody = res.body;\n\n      expect(res.status).toBe(409);\n      expect(resBody.error).toBe('Conflict');\n      expect(resBody.message).toBe('Short name already exists');\n    });\n  });\n});\n```\n\nOnce the changes are saved, this test case validation should be successful:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (13.512 s)\n...\napp_1      |     /links (POST)\n...\napp_1      |       ✓ should handle already exists (26 ms)\n```\n\nSince we have an `if/else` conditional statement where the `if` condition will handle the \"already exists\" error which we have just validated in the previous test case, we will also need to validate the `else` condition to achieve complete test coverage for this feature. To do that, we can mock the `linksRepository.save()` function with the help of `jest.spyOn()` and throw an error using `.mockRejectedValue()` and pass an empty object `{}` so that `err.code` will be `undefined` - this will be handled by the `else` condition. Do note that if we mock a function, it will affect other test cases unless we restore it back to its original state using `.mockRestore()`. To write that in code, update the file `src/links/links.spec.ts` with the following below:\n\n```ts\n...\n\ndescribe('Links', () =\u003e {\n  ...\n\n  describe('/links (POST)', () =\u003e {\n    ...\n\n    it('should handle unexpected error', async () =\u003e {\n      const linksRepositorySaveMock = jest\n        .spyOn(linksRepository, 'save')\n        .mockRejectedValue({});\n\n      const linkBody = createLinkBody();\n\n      const res = await request(app.getHttpServer())\n        .post('/links')\n        .send(linkBody);\n      const resBody = res.body;\n\n      expect(res.status).toBe(500);\n      expect(resBody.message).toBe('Internal Server Error');\n\n      linksRepositorySaveMock.mockRestore();\n    });\n  });\n});\n```\n\nAfter saving the changes, the test case should pass:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (13.422 s)\n...\napp_1      |     /links (POST)\n...\napp_1      |       ✓ should handle unexpected error (14 ms)\n```\n\nI hope that you're slowly getting the hang of it and let's move to the next feature!\n\n---\n\n## Write tests for delete a link feature\n\nNext feature to write tests for is when we delete a link. Do note that for this feature, you'll always get a `string` for the `id` since it is part of the URL, though it might not be in a valid `uuid` format. So for the first test case of this feature, let's validate that. And yes, you might have guessed it, we will create a utility function that generates a set of invalid `id` so we could reuse it later for the update a link feature:\n\n```ts\n...\n\ndescribe('Links', () =\u003e {\n  ...\n  const createInvalidLinkIds = () =\u003e {\n    return [faker.datatype.number(), faker.word.noun()];\n  };\n\n  ...\n\n  describe('/links/:id (DELETE)', () =\u003e {\n    it('should NOT accept invalid id', async () =\u003e {\n      const invalidData = createInvalidLinkIds();\n      const promises: Array\u003cPromise\u003cvoid\u003e\u003e = [];\n\n      invalidData.forEach((linkId) =\u003e {\n        promises.push(\n          (async () =\u003e {\n            const res = await request(app.getHttpServer()).delete(\n              `/links/${linkId}`,\n            );\n            const resBody = res.body;\n\n            expect(res.status).toBe(400);\n            expect(resBody.error).toBe('Bad Request');\n            expect(resBody.message).toEqual(\n              expect.arrayContaining([expect.any(String)]),\n            );\n          })(),\n        );\n      });\n\n      await Promise.all(promises);\n    });\n  });\n});\n```\n\nOnce we save the changes, that should pass as expected:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (5.652 s)\n...\napp_1      |     /links/:id (DELETE)\napp_1      |       ✓ should NOT accept invalid id (20 ms)\n```\n\nFor the next test case, it should be quite easy to write. Just to refresh our memory, every test case starts with an empty database due to the `clearRepositories()` function run before each test case. So any `id` will not exist by default. We just need to generate a random `id`, call the API with that and expect to get a \"not found\" error in the response. To do that, make the following code changes:\n\n```ts\n...\n\ndescribe('Links', () =\u003e {\n  ...\n\n  describe('/links/:id (DELETE)', () =\u003e {\n    ...\n\n    it('should handle not found', async () =\u003e {\n      const linkId = faker.datatype.uuid();\n      const res = await request(app.getHttpServer()).delete(`/links/${linkId}`);\n      const resBody = res.body;\n\n      expect(res.status).toBe(404);\n      expect(resBody.error).toBe('Not Found');\n      expect(resBody.message).toBe(`Link with ID: \"${linkId}\" not found`);\n    });\n  });\n});\n```\n\nYou should be familiar with what was done here, but something new that we did though is that for the `message` in the response body, we did an exact check of the `string` value instead of just type checking, that's because we did define that by ourselves earlier.\n\nOnce again this test case should pass:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (11.199 s)\n...\napp_1      |     /links/:id (DELETE)\napp_1      |       ✓ should NOT accept invalid id (13 ms)\napp_1      |       ✓ should handle not found (11 ms)\n```\n\nFor the last test case of this feature, let's create a link directly to the database (using `createLinkItem()` function), get the `id` of it, call the API with that and expect a successful response, and as an additional check, we will also verify from the database directly whether the link is deleted. Let's update the code with the following:\n\n```ts\n...\n\ndescribe('Links', () =\u003e {\n  ...\n\n  describe('/links/:id (DELETE)', () =\u003e {\n    ...\n\n    it('should handle delete', async () =\u003e {\n      const link = await createLinkItem();\n      const linkId = link.id;\n\n      const res = await request(app.getHttpServer()).delete(`/links/${linkId}`);\n\n      expect(res.status).toBe(200);\n\n      const deletedLink = await linksRepository.findOne({ id: linkId });\n\n      expect(deletedLink).toBeUndefined();\n    });\n  });\n});\n```\n\nAnd once we save the changes, it will pass this test case as expected:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (12.325 s)\n...\napp_1      |     /links/:id (DELETE)\n...\napp_1      |       ✓ should handle delete (39 ms)\n```\n\nLet's move to the next feature to be tested ~\n\n---\n\n## Write tests for update a link feature\n\nFor updating a link feature, all test cases except one are a combination of what we have already done for the previous features. We just have to replace the method to use `.put()`. Let's settle those first and add the following code:\n\n```ts\n...\n\ndescribe('Links', () =\u003e {\n  ...\n\n  describe('/links/:id (PUT)', () =\u003e {\n    it('should NOT accept invalid id', async () =\u003e {\n      const invalidData = createInvalidLinkIds();\n      const promises: Array\u003cPromise\u003cvoid\u003e\u003e = [];\n\n      invalidData.forEach((linkId) =\u003e {\n        promises.push(\n          (async () =\u003e {\n            const res = await request(app.getHttpServer()).put(\n              `/links/${linkId}`,\n            );\n            const resBody = res.body;\n\n            expect(res.status).toBe(400);\n            expect(resBody.error).toBe('Bad Request');\n            expect(resBody.message).toEqual(\n              expect.arrayContaining([expect.any(String)]),\n            );\n          })(),\n        );\n      });\n\n      await Promise.all(promises);\n    });\n\n    it('should NOT accept invalid data', async () =\u003e {\n      const linkId = faker.datatype.uuid();\n      const invalidData = createInvalidLinkBodies();\n      const promises: Array\u003cPromise\u003cvoid\u003e\u003e = [];\n\n      invalidData.forEach((payload) =\u003e {\n        promises.push(\n          (async () =\u003e {\n            const res = await request(app.getHttpServer())\n              .put(`/links/${linkId}`)\n              .send(payload);\n            const resBody = res.body;\n\n            expect(res.status).toBe(400);\n            expect(resBody.error).toBe('Bad Request');\n            expect(resBody.message).toEqual(\n              expect.arrayContaining([expect.any(String)]),\n            );\n          })(),\n        );\n      });\n\n      await Promise.all(promises);\n    });\n\n    it('should handle not found', async () =\u003e {\n      const linkId = faker.datatype.uuid();\n      const linkBody = createLinkBody();\n      const res = await request(app.getHttpServer())\n        .put(`/links/${linkId}`)\n        .send(linkBody);\n\n      expect(res.status).toBe(404);\n      expect(res.body.message).toBe('Not Found');\n    });\n  });\n});\n```\n\nSave the changes and these test cases will `PASS` ✓:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (12.076 s)\n...\napp_1      |     /links/:id (PUT)\napp_1      |       ✓ should NOT accept invalid id (12 ms)\napp_1      |       ✓ should NOT accept invalid data (45 ms)\napp_1      |       ✓ should handle not found (11 ms)\n```\n\nGreat. And for that one test case I mentioned earlier that we haven't done previously is the feature itself and check whether it can update an existing link with new data, let's write it and update with the following code below:\n\n```ts\n...\n\ndescribe('Links', () =\u003e {\n  ...\n\n  describe('/links/:id (PUT)', () =\u003e {\n    ...\n\n    it('should handle update', async () =\u003e {\n      const link = await createLinkItem();\n      const linkId = link.id;\n      const newLinkBody = createLinkBody();\n\n      const res = await request(app.getHttpServer())\n        .put(`/links/${linkId}`)\n        .send(newLinkBody);\n      const resBody = res.body;\n\n      expect(res.status).toBe(200);\n      expect(resBody).toEqual({\n        ...newLinkBody,\n        id: linkId,\n      });\n\n      const updatedLink = await linksRepository.findOne({ id: linkId });\n\n      expect(updatedLink).toEqual(resBody);\n    });\n  });\n});\n```\n\nWith the changes above, it should pass and the terminal logs should be like this:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (12.185 s)\n...\napp_1      |       ✓ should handle update (30 ms)\n```\n\n---\n\n## Write tests for redirect to URL by name feature\n\nFor the final feature we need to write tests for is the redirect to the URL by its (short) name. Since this feature is located in another module (`WildcardModule`), let's create a new file `src/wildcard/wildcard.spec.ts` and add the same code we did for the setup earlier, let's also keep `createLinkItem()` function and `linksRepository` as we will be needing it here too:\n\n```ts\nimport { INestApplication } from '@nestjs/common';\nimport * as request from 'supertest';\nimport { Connection } from 'typeorm';\nimport faker from '@faker-js/faker';\nimport { clearRepositories, createNestApplication } from '../test-helpers';\nimport { LinksRepository } from '../links/links.repository';\n\ndescribe('Wildcard', () =\u003e {\n  let app: INestApplication;\n  let dbConnection: Connection;\n  let linksRepository: LinksRepository;\n  const createLinkItem = async () =\u003e {\n    return linksRepository.createLink({\n      name: faker.word.noun(),\n      url: faker.internet.url(),\n    });\n  };\n\n  beforeAll(async () =\u003e {\n    app = await createNestApplication({\n      onBeforeInit: (moduleRef) =\u003e {\n        dbConnection = moduleRef.get(Connection);\n        linksRepository = moduleRef.get(LinksRepository);\n      },\n    });\n  });\n\n  beforeEach(async () =\u003e {\n    await clearRepositories(dbConnection);\n  });\n\n  afterAll(async () =\u003e {\n    await app.close();\n  });\n});\n```\n\nAlright, for the first test case of this feature, we should get a \"not found\" error if we simulate a GET request to a non-existing name. Since you should have quite an experience now with writing tests. That should be easy, right? Try it on your own before looking at the code below:\n\n```ts\n...\n\ndescribe('Wildcard', () =\u003e {\n  ...\n\n  describe('/:name (GET)', () =\u003e {\n    it('should handle not found', async () =\u003e {\n      const shortName = faker.word.noun();\n      const res = await request(app.getHttpServer()).get(`/${shortName}`);\n\n      expect(res.status).toBe(404);\n      expect(res.body.message).toBe('Not Found');\n    });\n  });\n});\n```\n\nDid you do it on your own? I hope so! But if not, that's fine because reaching this stage is still an achievement!\n\nOnce we save the changes, it should log something like this:\n\n```\napp_1      | PASS src/wildcard/wildcard.spec.ts (16.214 s)\napp_1      | PASS src/links/links.spec.ts (17.044 s)\n```\n\nGreat, we are down to the very last test case. Try it on your own again, I'll explain here in text what you need to do, first create a link by making a direct call to the database, then simulate a GET request to the API with the link's `name`, and check that the expected status code should be `301` and that it is redirecting to the URL, you can check `res.headers.location` for this.\n\nGo ahead and try it ~\n\nOnce you're done, verify that we have the same changes here:\n\n```ts\n...\n\ndescribe('Wildcard', () =\u003e {\n  ...\n\n  describe('/:name (GET)', () =\u003e {\n    ...\n\n    it('should handle redirect', async () =\u003e {\n      const link = await createLinkItem();\n      const res = await request(app.getHttpServer()).get(`/${link.name}`);\n\n      expect(res.status).toBe(301);\n      expect(res.headers.location).toBe(link.url);\n    });\n  });\n});\n```\n\nAnd that should pass the test case as well:\n\n```\napp_1      | PASS src/wildcard/wildcard.spec.ts (14.112 s)\napp_1      | PASS src/links/links.spec.ts (18.044 s)\n```\n\nIf you're curious about the code coverage from our end-to-end tests. Try running the command below in your terminal:\n\n```\nyarn docker-compose:test:cov\n```\n\nYou should see that we have achieved 100% coverage for both `LinksModule` and `WildcardModule`. That's awesome!\n\nAnd we are done! To be honest, I'm quite new in building applications with NestJS and writing this post was my way of sharpening my knowledge with this framework. So I hope you have learned a lot from this post as I have. Please don't forget to share this post if you found it helpful, share it with your friends and colleagues who might find this helpful too.\n\nIn case you need the final code of the URL shortener application as a reference, here's the [GitHub repository](https://github.com/dominicarrojado/nestjs-postgres-url-shortener).\n\nI'll probably extend this post in the future and try to implement caching using [Redis](https://redis.io/) or how to deploy this application to production so if you're interested, you can come back to my blog and check it out once it is published. You can also subscribe to my [YouTube channel](https://www.youtube.com/channel/UCWwV__qrzg5BYCSwO91Xhxg/videos?view=0\u0026sort=dd) and hit that notification button. Hope to see you here again!\n","previousPost":{"id":"building-a-link-shortener-api-with-nestjs-and-postgresql-with-tests-part-1","title":"Building a URL shortener API with NestJS and PostgreSQL with tests (Part 1)","date":"2022-05-18","excerpt":"Learn how to build server-side applications in an efficient, reliable and scalable way","category":"technology","videoUrl":"https://youtu.be/c81MhWCuHbI"},"nextPost":{"id":"local-development-setup-for-nestjs-projects-with-mongodb","title":"Local development setup for NestJS projects with MongoDB","date":"2022-06-06","excerpt":"A quick way to get started with NestJS integrated with TypeScript, MongoDB and mongo-express using Docker Compose","category":"technology","videoUrl":""},"title":"Building a URL shortener API with NestJS and PostgreSQL with tests (Part 2)","date":"2022-05-18","excerpt":"Learn how to build server-side applications in an efficient, reliable and scalable way","category":"technology","videoUrl":"https://youtu.be/ysvUh_z7wjc"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"building-a-link-shortener-api-with-nestjs-and-postgresql-with-tests-part-2"},"buildId":"XyjuqPrSwmbsTVWRqCwV0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>