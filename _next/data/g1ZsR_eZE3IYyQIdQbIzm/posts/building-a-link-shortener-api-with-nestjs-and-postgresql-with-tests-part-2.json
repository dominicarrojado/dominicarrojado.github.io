{"pageProps":{"postData":{"id":"building-a-link-shortener-api-with-nestjs-and-postgresql-with-tests-part-2","content":"\n## Introduction\n\nThis is a continuation from [Part 1](/posts/building-a-link-shortener-api-with-nestjs-and-postgresql-with-tests-part-1).\n\n## Prerequisites for testing\n\nTo get started with testing, first install the required packages:\n\n```bash\nyarn add -D @nestjs/testing supertest @faker-js/faker\n```\n\nThe `@nestjs/testing` package provides a set of utilities that enable a more robust testing process, [`@faker-js/faker`](https://github.com/faker-js/faker) helps us generate massive amounts of fake (but realistic) data for testing, while [`supertest`](https://github.com/visionmedia/supertest) provides a high-level abstraction for testing and simulating HTTP requests.\n\n## Test utilities\n\nThere are two utility functions we would like to create and reuse when we write our test cases. First is creating the Nest application in a test environment that we could use for each test cases. Second is to clear the TypeORM repositories (tables or collections) in our database before running each test cases to keep any overflowing data that might affect the test results.\n\nTo start, create a file `src/test-helpers.ts` and add the following code for the first utility function:\n\n```ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { AppModule } from './app.module';\n\nexport async function createNestApplication({\n  onBeforeInit,\n}: {\n  onBeforeInit: (moduleRef: TestingModule) => void;\n}) {\n  const moduleRef = await Test.createTestingModule({\n    imports: [AppModule],\n  }).compile();\n\n  const app = moduleRef.createNestApplication();\n\n  app.useGlobalPipes(new ValidationPipe());\n\n  onBeforeInit(moduleRef);\n\n  await app.init();\n\n  return app;\n}\n```\n\nThe `Test` class from `@nestjs/testing` provides an application execution context that essentially mocks the full Nest runtime, but gives you hooks that make it easy to manage class instances, including mocking and overriding. The `Test` class has a `createTestingModule()` method that takes a module metadata object as its argument (the same object you pass to the `@Module()` decorator). This method returns a `TestingModule` instance which in turn provides a few methods. For unit tests, the important one is the `compile()` method. This method bootstraps a module with its dependencies (similar to the way an application is bootstrapped in the conventional `main.ts` file using `NestFactory.create()`), and returns a module that is ready for testing. Do note that if we want to test the validation errors we will need to call `useGlobalPipes()` after creating the Nest application.\n\nWe won't be doing [unit testing](https://docs.nestjs.com/fundamentals/testing#unit-testing) which involves mocking and overriding. What I like to do is write [end-to-end tests](https://docs.nestjs.com/fundamentals/testing#end-to-end-testing) because it covers the interaction of classes and modules at a more aggregate level - closer to the kind of interaction that end-users will have with the production system. As an application grows, it becomes hard to manually test the end-to-end behavior of each API endpoint. Automated end-to-end tests help us ensure that the overall behavior of the system is correct and meets project requirements.\n\nWe also added `onBeforeInit()` function which comes from the argument so that we could get modules such as the database connection and repositories depending on the features we would be testing.\n\nIn the same file `src/test-helpers.ts`, add the following code for the second utility function:\n\n```ts\n...\n\nexport async function clearRepositories(dbConnection: Connection) {\n  const entities = dbConnection.entityMetadatas;\n  const promises: Array<Promise<void>> = [];\n\n  for (const entity of entities) {\n    const repository = dbConnection.getRepository(entity.name);\n    promises.push(repository.clear());\n  }\n\n  await Promise.all(promises);\n}\n```\n\nThis just iterates all the entities from the database connection, get their repository and clear it. We are accepting `dbConnection` as an argument because we could only get this once the Nest application is created, using the `onBeforeInit()`. You'll get to see this in a bit.\n\n---\n\n## Write tests for get all the links feature\n\nNow that the utility functions are created, let's use them and setup the tests. Create a file `src/links/links.spec.ts` and add the following code:\n\n```ts\nimport { INestApplication } from '@nestjs/common';\nimport { Connection } from 'typeorm';\nimport { clearRepositories, createNestApplication } from '../test-helpers';\nimport { LinksRepository } from './links.repository';\n\ndescribe('Links', () => {\n  let app: INestApplication;\n  let dbConnection: Connection;\n\n  beforeAll(async () => {\n    app = await createNestApplication({\n      onBeforeInit: (moduleRef) => {\n        dbConnection = moduleRef.get(Connection);\n      },\n    });\n  });\n\n  beforeEach(async () => {\n    await clearRepositories(dbConnection);\n  });\n\n  afterAll(async () => {\n    await app.close();\n  });\n});\n```\n\nRemember this setup as it will look similar when we create another spec (short for specification) file for other features. If you could focus on the `onBeforeInit()` function, this is how easily we could get the module, in this case `dbConnection`, from the Nest application by just passing the `Connection` class from `typeorm`. We then pass it to the `clearRepositories()` function to clear all the repositories in our database.\n\nNow for the first test case, we can to test the feature of getting all the links. This is how we can do it:\n\n```ts\n...\nimport * as request from 'supertest';\n\ndescribe('Links', () => {\n  ...\n\n  describe('/links (GET)', () => {\n    it('should handle without data', async () => {\n      const res = await request(app.getHttpServer()).get('/links');\n\n      expect(res.status).toBe(200);\n      expect(res.body).toEqual([]);\n    });\n  });\n```\n\nWe started simple, we simulated an [HTTP GET method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET) request using `supertest` by executing `.get()` function with the path, waited for the response and check whether the `status` and `body` is what we expected. Since there's no data in the database, we expected it to return an empty array `[]`.\n\nLet's run our application in test **watch** mode by executing the terminal command below:\n\n```bash\nyarn docker-compose:test:watch\n```\n\nThe test case should pass and log something like this:\n\n```bash\napp_1      | PASS src/links/links.spec.ts\napp_1      |   Links\napp_1      |     /links (GET)\napp_1      |       ✓ should handle without data (74 ms)\n```\n\nOkay. Before we move to the next test case where there's data in the database, we need to get the `LinksRepository` so we could make direct calls to the database to simulate our tests. To do that, simple update the file `src/links/links.spec.ts` with the following code below:\n\n```ts\n...\nimport { LinksRepository } from './links.repository';\n\ndescribe('Links', () => {\n  ...\n  let linksRepository: LinksRepository;\n\n  beforeAll(async () => {\n    app = await createNestApplication({\n      onBeforeInit: (moduleRef) => {\n        dbConnection = moduleRef.get(Connection);\n        linksRepository = moduleRef.get(LinksRepository);\n      },\n    });\n  });\n});\n```\n\nHere, we got the instance of the links repository using the `onBeforeInit()` function by passing the `LinksRepository` class in the `moduleRef.get()`. Simple, isn't it?\n\nNext, we want to create a function that creates a link in the database with random data generated from `faker` library, let's add it in the `Links` describe block since I anticipate we'll be going to reuse it a couple of times, update `src/links/links.spec.ts` with the following code below:\n\n```ts\n...\nimport faker from '@faker-js/faker';\n\ndescribe('Links', () => {\n  ...\n  let linksRepository: LinksRepository;\n  const createLinkItem = async () => {\n    return linksRepository.createLink({\n      name: faker.word.noun(),\n      url: faker.internet.url(),\n    });\n  };\n\n  ...\n});\n```\n\nLet's now create the second test case and update the spec file `src/links/links.spec.ts`:\n\n```ts\n...\nimport { Link } from './link.entity';\n\ndescribe('Links', () => {\n  ...\n\n  describe('/links (GET)', () => {\n    ...\n\n    it('should handle with data', async () => {\n      const promises: Array<Promise<Link>> = [];\n      const linksCount = 3;\n\n      for (let i = 0; i < linksCount; i++) {\n        promises.push(createLinkItem());\n      }\n\n      const links = await Promise.all(promises);\n      const res = await request(app.getHttpServer()).get('/links');\n      const resBody = res.body;\n\n      expect(res.status).toBe(200);\n      expect(resBody).toEqual(expect.arrayContaining(links));\n      expect(resBody).toHaveLength(linksCount);\n    });\n  });\n});\n```\n\nYou might wonder why we didn't just do `expect(res.body).toEqual(links)`, that's because the order of the links in the array might be different once it is created in the database, so we used `arrayContaining()` instead to check that each items are in the expected array and we also checked that the number of items are the same using `toHaveLength()`.\n\nOnce we save the changes, it will automatically rerun all the tests as it is in **watch** mode and log the following:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (8.539 s)\napp_1      |   Links\napp_1      |     /links (GET)\napp_1      |       ✓ should handle without data (85 ms)\napp_1      |       ✓ should handle with data (472 ms)\n```\n\nGreat, we're done with testing this feature. Let's move to the next one ~\n\n---\n\n## Write tests for create a link feature\n\nFor the next test case, we will be testing the feature to create a link. It would be something similar to our first test case, but in this case it will be the other way around. So instead of creating the link directly to the database, we create the link by calling the API first then check the database whether it was created.\n\nLet's write the test case where we pass **invalid** data, such as empty `name`, non-string `url`, etc. We will create a utility function that can generate a set of invalid data or payloads to be passed to the API since I anticipate we will also use it for the update a link feature:\n\n```ts\n...\n\ndescribe('Links', () => {\n  ...\n  const createLinkBody = () => {\n    return {\n      name: faker.word.noun(),\n      url: faker.internet.url(),\n    };\n  };\n  const createInvalidLinkBodies = () => {\n    const validLink = createLinkBody();\n\n    return [\n      // invalid payload\n      undefined,\n      {},\n\n      // invalid name\n      { name: undefined, url: validLink.url },\n      { name: null, url: validLink.url },\n      { name: faker.datatype.boolean(), url: validLink.url },\n      { name: faker.datatype.number(), url: validLink.url },\n      { name: JSON.parse(faker.datatype.json()), url: validLink.url },\n      { name: '', url: validLink.url },\n\n      // invalid url\n      { name: validLink.name, url: undefined },\n      { name: validLink.name, url: null },\n      { name: validLink.name, url: faker.datatype.boolean() },\n      { name: validLink.name, url: faker.datatype.number() },\n      { name: validLink.name, url: JSON.parse(faker.datatype.json()) },\n      { name: validLink.name, url: '' },\n      { name: validLink.name, url: faker.word.noun() },\n    ];\n  };\n  const createLinkItem = async () => {\n    const linkBody = createLinkBody();\n\n    return linksRepository.createLink(linkBody);\n  };\n\n  ...\n\n  describe('/links (POST)', () => {\n    it('should NOT accept invalid data', async () => {\n      const invalidData = createInvalidLinkBodies();\n      const promises: Array<Promise<void>> = [];\n\n      invalidData.forEach((payload) => {\n        promises.push(\n          (async () => {\n            const res = await request(app.getHttpServer())\n              .post('/links')\n              .send(payload);\n            const resBody = res.body;\n\n            expect(res.status).toBe(400);\n            expect(resBody.error).toBe('Bad Request');\n            expect(resBody.message).toEqual(\n              expect.arrayContaining([expect.any(String)]),\n            );\n          })(),\n        );\n      });\n\n      await Promise.all(promises);\n    });\n  });\n});\n```\n\nSo here, we iterated through the array of invalid data and created a [self-invoking function](https://developer.mozilla.org/en-US/docs/Glossary/Self-Executing_Anonymous_Function) that is asynchronous to verify each payload and check whether we received that expected response. For the `message` inside the response body, we just check whether it is an `array` containing values of type `string` since we just use the default error messages from `class-validator` and therefore I don't think it's necessary to check the exact `string` value.\n\nOnce we save the changes, it should log something like this:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (12.215 s)\n...\napp_1      |     /links (POST)\napp_1      |       ✓ should NOT accept invalid data (94 ms)\n```\n\nGreat, it passed as well!\n\nLet's now validate where we now pass a **valid** data to the API. Update the file `src/links/links.spec.ts` with the following code below:\n\n```ts\n...\n\ndescribe('Links', () => {\n  ...\n\n  describe('/links (POST)', () => {\n    ...\n\n    it('should accept valid data', async () => {\n      const linkBody = createLinkBody();\n\n      const res = await request(app.getHttpServer())\n        .post('/links')\n        .send(linkBody);\n      const resBody = res.body;\n\n      expect(res.status).toBe(201);\n      expect(resBody).toEqual({\n        ...linkBody,\n        id: expect.any(String),\n      });\n\n      const linkId = resBody.id;\n      const link = await linksRepository.findOne({ id: linkId });\n\n      expect(link).toEqual(resBody);\n    });\n  });\n});\n```\n\nSo here, we use one of the utility function `createLinkBody()` we created earlier to get a valid link body or data, passed that to the API and waited for the response, then checked whether we got the expected response. We then took the `id` from the response body and checked the database directly whether the link was created and has the same data. Cool ~\n\nOf course, it should pass as well:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (12.948 s)\n...\napp_1      |     /links (POST)\napp_1      |       ✓ should NOT accept invalid data (133 ms)\napp_1      |       ✓ should accept valid data (49 ms)\n```\n\nThere's another case we need to cover. Remember that we don't allow link creation if the (short) `name` already exists? Let's write the test case to validate that. Update the file `src/links/links.spec.ts` with the following code below:\n\n```ts\n...\n\ndescribe('Links', () => {\n  ...\n\n  describe('/links (POST)', () => {\n    ...\n\n    it('should handle already exists', async () => {\n      const existingLink = await createLinkItem();\n      const linkBody = createLinkBody();\n\n      const res = await request(app.getHttpServer()).post('/links').send({\n        name: existingLink.name,\n        url: linkBody.url,\n      });\n      const resBody = res.body;\n\n      expect(res.status).toBe(409);\n      expect(resBody.error).toBe('Conflict');\n      expect(resBody.message).toBe('Short name already exists');\n    });\n  });\n});\n```\n\nOnce the changes are saved, this test case validation should be successful:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (13.512 s)\n...\napp_1      |     /links (POST)\n...\napp_1      |       ✓ should handle already exists (26 ms)\n```\n\nSince we have an `if/else` conditional statements where the `if` condition will handle the \"already exists\" error which we have just validated in the previous test case, we will also need to validate the `else` condition to achieve complete test coverage for this feature. To do that, we can mock the `linksRepository.save()` function with the help of `jest.spyOn()` and throw an error using `.mockRejectedValue()` and pass an empty object `{}` so that `err.code` will be `undefined` - this will be handled by the `else` condition. Do note that if we mock a function, it will affect other test cases unless we restore it back to its original state using `.mockRestore()`. To write that in code, update the file `src/links/links.spec.ts` with the following below:\n\n```ts\n...\n\ndescribe('Links', () => {\n  ...\n\n  describe('/links (POST)', () => {\n    ...\n    it('should handle unexpected error', async () => {\n      const linksRepositorySaveMock = jest\n        .spyOn(linksRepository, 'save')\n        .mockRejectedValue({});\n\n      const linkBody = createLinkBody();\n\n      const res = await request(app.getHttpServer())\n        .post('/links')\n        .send(linkBody);\n      const resBody = res.body;\n\n      expect(res.status).toBe(500);\n      expect(resBody.message).toBe('Internal Server Error');\n\n      linksRepositorySaveMock.mockRestore();\n    });\n  });\n});\n```\n\nAfter saving the changes, the test case should pass:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (13.422 s)\n...\napp_1      |     /links (POST)\n...\napp_1      |       ✓ should handle unexpected error (14 ms)\n```\n\nI hope that you're slowly getting the hang of it and let's move to the next feature!\n\n---\n\n## Write tests for delete a link feature\n\nNext feature to write tests for is when we delete a link. Do note that for this feature, you'll always get a `string` for the `id` since it is part of the URL, though it might not be in a valid `uuid` format. So for the first test case of this feature, let's validate that. And yes, you might have guessed it, we will create a utility function that generates a set of invalid `id` so we could reuse it later for the update a link feature:\n\n```ts\n...\n\ndescribe('Links', () => {\n  ...\n  const createInvalidLinkIds = () => {\n    return [faker.datatype.number(), faker.word.noun()];\n  };\n\n  ...\n\n  describe('/links/:id (DELETE)', () => {\n    it('should NOT accept invalid id', async () => {\n      const invalidData = createInvalidLinkIds();\n      const promises: Array<Promise<void>> = [];\n\n      invalidData.forEach((linkId) => {\n        promises.push(\n          (async () => {\n            const res = await request(app.getHttpServer()).delete(\n              `/links/${linkId}`,\n            );\n            const resBody = res.body;\n\n            expect(res.status).toBe(400);\n            expect(resBody.error).toBe('Bad Request');\n            expect(resBody.message).toEqual(\n              expect.arrayContaining([expect.any(String)]),\n            );\n          })(),\n        );\n      });\n\n      await Promise.all(promises);\n    });\n  });\n});\n```\n\nOnce we save the changes, that should pass as expected:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (5.652 s)\n...\napp_1      |     /links/:id (DELETE)\napp_1      |       ✓ should NOT accept invalid id (20 ms)\n```\n\nFor the next test case, it should be quite easy to write. Just to refresh our memory, every test case starts with an empty database due to the `clearRepositories()` function run before each test cases. So any `id` will not exist by default. We just need to generate a random `id`, call the API with that and expect to get a \"not found\" error in the response. To do that, make the following code changes:\n\n```ts\n...\n\ndescribe('Links', () => {\n  ...\n\n  describe('/links/:id (DELETE)', () => {\n    ...\n\n    it('should handle not found', async () => {\n      const linkId = faker.datatype.uuid();\n      const res = await request(app.getHttpServer()).delete(`/links/${linkId}`);\n      const resBody = res.body;\n\n      expect(res.status).toBe(404);\n      expect(resBody.error).toBe('Not Found');\n      expect(resBody.message).toBe(`Link with ID: \"${linkId}\" not found`);\n    });\n  });\n});\n```\n\nYou should be familiar on what was done here, but something new that we did though is that for the `message` in the response body, we did an exact check of the `string` value instead of just type checking, that's because we did defined that by ourselves earlier.\n\nOnce again this test case should pass:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (11.199 s)\n...\napp_1      |     /links/:id (DELETE)\napp_1      |       ✓ should NOT accept invalid id (13 ms)\napp_1      |       ✓ should handle not found (11 ms)\n```\n\nFor the last test case of this feature, let's create a link directly to the database (using `createLinkItem()` function), get the `id` of it, call the API with that and expect a successful response, and as an additional check, we will also verify from the database directly whether the link is deleted. Let's update the code with the following:\n\n```ts\n...\n\ndescribe('Links', () => {\n  ...\n\n  describe('/links/:id (DELETE)', () => {\n    ...\n\n    it('should handle delete', async () => {\n      const link = await createLinkItem();\n      const linkId = link.id;\n\n      const res = await request(app.getHttpServer()).delete(`/links/${linkId}`);\n\n      expect(res.status).toBe(200);\n\n      const deletedLink = await linksRepository.findOne({ id: linkId });\n\n      expect(deletedLink).toBeUndefined();\n    });\n  });\n});\n```\n\nAnd once we save the changes, it will pass this test case as expected:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (12.325 s)\n...\napp_1      |     /links/:id (DELETE)\n...\napp_1      |       ✓ should handle delete (39 ms)\n```\n\nLet's move to the next feature to be tested ~\n\n---\n\n## Write tests for update a link feature\n\nFor update a link feature, all test cases except one is a combination of what we have already done for the previous features. We just have to replace the method to use `.put()`. Let's settle those first and add the following code:\n\n```ts\n...\n\ndescribe('Links', () => {\n  ...\n\n  describe('/links/:id (PUT)', () => {\n    it('should NOT accept invalid id', async () => {\n      const invalidData = createInvalidLinkIds();\n      const promises: Array<Promise<void>> = [];\n\n      invalidData.forEach((linkId) => {\n        promises.push(\n          (async () => {\n            const res = await request(app.getHttpServer()).put(\n              `/links/${linkId}`,\n            );\n            const resBody = res.body;\n\n            expect(res.status).toBe(400);\n            expect(resBody.error).toBe('Bad Request');\n            expect(resBody.message).toEqual(\n              expect.arrayContaining([expect.any(String)]),\n            );\n          })(),\n        );\n      });\n\n      await Promise.all(promises);\n    });\n\n    it('should NOT accept invalid data', async () => {\n      const linkId = faker.datatype.uuid();\n      const invalidData = createInvalidLinkBodies();\n      const promises: Array<Promise<void>> = [];\n\n      invalidData.forEach((payload) => {\n        promises.push(\n          (async () => {\n            const res = await request(app.getHttpServer())\n              .put(`/links/${linkId}`)\n              .send(payload);\n            const resBody = res.body;\n\n            expect(res.status).toBe(400);\n            expect(resBody.error).toBe('Bad Request');\n            expect(resBody.message).toEqual(\n              expect.arrayContaining([expect.any(String)]),\n            );\n          })(),\n        );\n      });\n\n      await Promise.all(promises);\n    });\n\n    it('should handle not found', async () => {\n      const linkId = faker.datatype.uuid();\n      const linkBody = createLinkBody();\n      const res = await request(app.getHttpServer())\n        .put(`/links/${linkId}`)\n        .send(linkBody);\n\n      expect(res.status).toBe(404);\n      expect(res.body.message).toBe('Not Found');\n    });\n  });\n});\n```\n\nSave the changes and these test cases will `PASS` ✓:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (12.076 s)\n...\napp_1      |     /links/:id (PUT)\napp_1      |       ✓ should NOT accept invalid id (12 ms)\napp_1      |       ✓ should NOT accept invalid data (45 ms)\napp_1      |       ✓ should handle not found (11 ms)\n```\n\nGreat. And for that one test case I mentioned earlier that we haven't done previously is the feature itself and check whether it can update an existing link with new data, let's write it and update with the following code below:\n\n```ts\n...\n\ndescribe('Links', () => {\n  ...\n\n  describe('/links/:id (PUT)', () => {\n    ...\n\n    it('should handle update', async () => {\n      const link = await createLinkItem();\n      const linkId = link.id;\n      const newLinkBody = createLinkBody();\n\n      const res = await request(app.getHttpServer())\n        .put(`/links/${linkId}`)\n        .send(newLinkBody);\n      const resBody = res.body;\n\n      expect(res.status).toBe(200);\n      expect(resBody).toEqual({\n        ...newLinkBody,\n        id: linkId,\n      });\n\n      const updatedLink = await linksRepository.findOne({ id: linkId });\n\n      expect(updatedLink).toEqual(resBody);\n    });\n  });\n});\n```\n\nWith the changes above, it should pass and the terminal logs should be like this:\n\n```bash\napp_1      | PASS src/links/links.spec.ts (12.185 s)\n...\napp_1      |       ✓ should handle update (30 ms)\n```\n\n---\n\n## Write tests for redirect to URL by name feature\n\nFor the final feature we need to write tests for is redirect to URL by its (short) name. Since this feature is located in another module (`WildcardModule`), let's create a new file `src/wildcard/wildcard.spec.ts` and add the same code we did for the setup earlier, let's also keep `createLinkItem()` function and `linksRepository` as we will be needing it here too:\n\n```ts\nimport { INestApplication } from '@nestjs/common';\nimport * as request from 'supertest';\nimport { Connection } from 'typeorm';\nimport faker from '@faker-js/faker';\nimport { clearRepositories, createNestApplication } from '../test-helpers';\nimport { LinksRepository } from '../links/links.repository';\n\ndescribe('Wildcard', () => {\n  let app: INestApplication;\n  let dbConnection: Connection;\n  let linksRepository: LinksRepository;\n  const createLinkItem = async () => {\n    return linksRepository.createLink({\n      name: faker.word.noun(),\n      url: faker.internet.url(),\n    });\n  };\n\n  beforeAll(async () => {\n    app = await createNestApplication({\n      onBeforeInit: (moduleRef) => {\n        dbConnection = moduleRef.get(Connection);\n        linksRepository = moduleRef.get(LinksRepository);\n      },\n    });\n  });\n\n  beforeEach(async () => {\n    await clearRepositories(dbConnection);\n  });\n\n  afterAll(async () => {\n    await app.close();\n  });\n});\n```\n\nAlright, for the first test case of this feature, we should get a \"not found\" error if simulate a GET request to a non-existing name. Since you should have quite an experience now with writing tests. That should be easy, right? Try it on your own before looking at the code below:\n\n```ts\n...\n\ndescribe('Wildcard', () => {\n  ...\n\n  describe('/:name (GET)', () => {\n    it('should handle not found', async () => {\n      const shortName = faker.word.noun();\n      const res = await request(app.getHttpServer()).get(`/${shortName}`);\n\n      expect(res.status).toBe(404);\n      expect(res.body.message).toBe('Not Found');\n    });\n  });\n});\n```\n\nDid you did it on your own? I hope so! But if not, that's fine because reaching this stage is still an achievement!\n\nOnce we save the changes, it should log something like this:\n\n```\napp_1      | PASS src/wildcard/wildcard.spec.ts (16.214 s)\napp_1      | PASS src/links/links.spec.ts (17.044 s)\n```\n\nGreat, we are down to the very last test case. Try it on your own again, I'll explain here in text what you need to do, first create a link by making a direct call to the database, then simulate a GET request to the API with the link's `name`, and check that the expected status code should be `301` and that it is redirecting to the URL, you can check `res.headers.location` for this.\n\nGo ahead and try it ~\n\nOnce you're done, verify that we have the same changes here:\n\n```ts\n...\n\ndescribe('Wildcard', () => {\n  ...\n\n  describe('/:name (GET)', () => {\n    ...\n\n    it('should handle redirect', async () => {\n      const link = await createLinkItem();\n      const res = await request(app.getHttpServer()).get(`/${link.name}`);\n\n      expect(res.status).toBe(301);\n      expect(res.headers.location).toBe(link.url);\n    });\n  });\n});\n```\n\nAnd that should pass the test case as well:\n\n```\napp_1      | PASS src/wildcard/wildcard.spec.ts (14.112 s)\napp_1      | PASS src/links/links.spec.ts (18.044 s)\n```\n\nIf you're curious about the code coverage from our end-to-end tests. Try running the command below in your terminal:\n\n```\nyarn docker-compose:test:cov\n```\n\nYou should see that we have achieved 100% coverage for both `LinksModule` and `WildcardModule`. That's awesome!\n\nAnd we are done! To be honest, I'm quite new in building applications with NestJS and writing this post was my way in sharpening my knowledge with this framework. So I hope you have learned a lot from this post as I have. Please don't forget to share this post if you found it helpful, share it with your friends and colleagues who might find this helpful too.\n\nI'll probably extend this post in the future and try to implement caching using [Redis](https://redis.io/) or how to deploy this application to production so if you're interested, you can come back to my blog and check it out once it is published. You can also subscribe to my [YouTube channel](https://www.youtube.com/channel/UCWwV__qrzg5BYCSwO91Xhxg) and hit that notification button. Hope to see you here again!\n","previousPost":{"id":"building-a-link-shortener-api-with-nestjs-and-postgresql-with-tests-part-1","title":"Building a URL shortener API with NestJS and PostgreSQL with tests (Part 1)","date":"2022-05-18","excerpt":"Learn how to build server-side applications in an efficient, reliable and scalable way","category":"technology","videoUrl":"https://youtu.be/c81MhWCuHbI"},"nextPost":{"id":"local-development-setup-for-nestjs-projects-with-mongodb","title":"Local development setup for NestJS projects with MongoDB","date":"2022-06-06","excerpt":"A quick way to get started with NestJS integrated with TypeScript, MongoDB and mongo-express using Docker Compose","category":"technology","videoUrl":""},"title":"Building a URL shortener API with NestJS and PostgreSQL with tests (Part 2)","date":"2022-05-18","excerpt":"Learn how to build server-side applications in an efficient, reliable and scalable way","category":"technology","videoUrl":"https://youtu.be/ysvUh_z7wjc"}},"__N_SSG":true}