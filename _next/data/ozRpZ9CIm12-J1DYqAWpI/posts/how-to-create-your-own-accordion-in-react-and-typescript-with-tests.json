{"pageProps":{"postData":{"id":"how-to-create-your-own-accordion-in-react-and-typescript-with-tests","content":"\n## Introduction\n\nAccordions (or collapsible content) are useful for when you have large amount of content to display and allow users to toggle between showing and hiding the content. This can be seen a lot in different websites today. Learn how to build your own accordion in [React](https://reactjs.org/) and [TypeScript](https://www.typescriptlang.org/). I'll also cover how to write tests for it and achieve 100% coverage using [Jest](https://jestjs.io/) and [Testing Library](https://testing-library.com/), these two libraries are used together to test React components. If you're new to TypeScript and Jest/Testing Library, this is a good way to start learning it with simple components like this. Alright, here we go ~\n\n## Prerequisites\n\nThis is the [link](/react-typescript-accordion/) to the accordion which we'll accomplish by the end of this post, you can see and play around with it or use it as your reference throughout this tutorial.\n\nBy the way, upon writing this post, I assume that you have some web development background and basic knowledge regarding [npm](https://www.npmjs.com/), [yarn](https://classic.yarnpkg.com/lang/en/), [HTML](https://developer.mozilla.org/en-US/docs/Web/HTML), [CSS](https://developer.mozilla.org/en-US/docs/Web/CSS), [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript) and [React](https://reactjs.org/).\n\nMake sure to install [Yarn](https://classic.yarnpkg.com/lang/en/) in your system if you haven't. We use [Yarn](https://classic.yarnpkg.com/lang/en/) as our package manager, it's just like [npm](https://www.npmjs.com/) but _faster_.\n\nI've written a [separate post](/posts/local-development-setup-for-react-and-typescript-projects/) about the [IDE](https://en.wikipedia.org/wiki/Integrated_development_environment) and extensions I use to help me save time and energy when writing my code in React. I highly suggest for you to check it out if you haven't!\n\n## Initialize your project\n\nFastest way to get started with React is using [Create React App](https://create-react-app.dev/). It is an officially supported way to create single-page React applications. It offers a modern build setup with no configuration so you can focus on code, not build tools.\n\nTo create our project with React and TypeScript, run this command in your terminal:\n\n```bash\nyarn create react-app react-typescript-accordion --template typescript\n```\n\nOnce installed, let's run our project to see if everything is working fine:\n\n```bash\ncd react-typescript-accordion\nyarn start\n```\n\nThis command will open your default browser and go to `http://localhost:3000/`. If it doesn't, you can do it yourself too. The page should show something like this:\n\n![Screenshot of Create React App default page](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/create-react-app-default-page.png)\n\nThis setup comes with live-editing or hot reloading which means when we save file changes, it will automatically update the app and reload on the browser. That's great for local development!\n\n## Clean up the project\n\nNow, let's clean up our project which was created by Create React App. We won't be needing some of them. Delete or clear the contents of the following below:\n\n- src/App.css (clear contents)\n- src/App.test.tsx (delete)\n- src/logo.svg (delete)\n\nThen let's update the code of `src/App.tsx`:\n\n```tsx\nimport './App.css';\n\nfunction App() {\n  return <div className=\"container\"></div>;\n}\n\nexport default App;\n```\n\nWe will use the `App` component as the container of our accordion. So just a small update on the `src/App.css`:\n\n```css\n.container {\n  width: 600px;\n  max-width: 100%;\n  margin: 0 auto;\n  padding: 20px 15px;\n}\n```\n\nAnd update the `src/index.css` too:\n\n```css\n* {\n  box-sizing: border-box;\n}\n\nbody {\n  margin: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto',\n    'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans',\n    'Helvetica Neue', sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  line-height: 1.6;\n}\n```\n\n## Sample data + Accordion component\n\nNow, let's create a sample data that we can pass to our accordion component because we would want our accordion to be reusable, so it should accept data as props. We can initialize the data from a parent component so for our case, it would be `src/App.tsx`. I have a sample data that we can use here, update the code of it:\n\n```tsx\nimport './App.css';\nimport Accordion from './components/Accordion';\n\nfunction App() {\n  const accordionItems = [\n    {\n      title: 'Accordion Item #1',\n      content: (\n        <div>\n          <strong>This is the first item's accordion body.</strong> It is hidden\n          by default, but shown when title is clicked. It will also be hidden if\n          the title is clicked again or when another item is clicked. You can\n          pass HTML tags in the content such as <u>underline tag</u>,{' '}\n          <i>italic</i>, or even another list like this:\n          <ul>\n            <li>Bread</li>\n            <li>Eggs</li>\n            <li>Milk</li>\n          </ul>\n        </div>\n      ),\n    },\n    {\n      title: 'Accordion Item #2',\n      content: (\n        <div>\n          <strong>This is the second item's accordion body.</strong> It is\n          hidden by default, but shown when title is clicked. It will also be\n          hidden if the title is clicked again or when another item is clicked.\n          You can pass HTML tags in the content such as <u>underline tag</u>,{' '}\n          <i>italic</i>, or even another list like this:\n          <ul>\n            <li>Bread</li>\n            <li>Eggs</li>\n            <li>Milk</li>\n          </ul>\n        </div>\n      ),\n    },\n    {\n      title: 'Accordion Item #3',\n      content: (\n        <div>\n          <strong>This is the third item's accordion body.</strong> It is hidden\n          by default, but shown when title is clicked. It will also be hidden if\n          the title is clicked again or when another item is clicked. You can\n          pass HTML tags in the content such as <u>underline tag</u>,{' '}\n          <i>italic</i>, or even another list like this:\n          <ul>\n            <li>Bread</li>\n            <li>Eggs</li>\n            <li>Milk</li>\n          </ul>\n        </div>\n      ),\n    },\n  ];\n\n  return (\n    <div className=\"container\">\n      <Accordion items={accordionItems} />\n    </div>\n  );\n}\n\nexport default App;\n```\n\nIf you save the changes we would get errors in the meantime as we would still need to create the `Accordion` component. So create a folder under `src` and name it `components`. We can put our reusable components in this folder. After that, create a file named `Accordion.tsx` inside the `components` folder.\n\nThen, let's add the code for `src/components/Accordion.tsx`:\n\n```tsx\nimport { AccordionData } from '../types';\n\nfunction Accordion({ items }: { items: Array<AccordionData> }) {\n  return <ul className=\"accordion\"></ul>;\n}\n\nexport default Accordion;\n```\n\nIf you're new to TypeScript, the object besides the props will look foreign to you. It would be explained better once we do the remaining change. For now, create a new file `types.ts` inside the `src` folder and add the following code to it:\n\n```ts\nimport { ReactNode } from 'react';\n\nexport type AccordionData = {\n  title: string;\n  content: ReactNode;\n};\n```\n\nNow comes the explanation part for those of you who are new to TypeScript, feel free to skip this if you are already familiar with it. So we are defining the type for the `items` props that our `Accordion` component will accept. So we declared a `type AccordionData` which is an `object` that contains `title` that should only be a `string`, one of the [primitive types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html) in TypeScript, and `content` that should only be a `ReactNode`, a type defined by `React` library, same thing we did when we defined our type `AccordionData`. We can hover to a non-primitive type and it will show a tooltip with more information about the type like this:\n\n![Screenshot of hovering a type in Visual Studio Code](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/hovering-type-in-visual-studio-code.png)\n\nYou can also `Cmd` + `click` (`Ctrl` + `click` on Windows) to view the type with even more information.\n\n![Screenshot of checking a type in Visual Studio Code](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/checking-type-in-visual-studio-code.png)\n\nSo we created `src/types.ts` so that it can be exported and imported across different components which you will see in a bit. Since `Accordion` component accepts an array of `AccordionData`, we wrapped it in type `Array` like this - `Array<AccordionData>`. You can also wrap it like this - `AccordionData[]`, I just prefer the former as it I can read it as \"array of accordion data\".\n\nNow if we didn't pass the expected data or type for `items` props to our accordion component, our IDE would display an inline error and hovering it would show something like this:\n\n![Screenshot of inline error by TypeScript in Visual Studio Code](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/inline-error-by-typescript-in-visual-studio-code.png)\n\nThis is why TypeScript is really helpful for catching errors early while you're still writing the code.\n\n## Accordion Item component\n\nAlright, let's create a new component under `components` and name it `AccordionItem.tsx`. This will be the component used by each item in our accordion. Add the following code below to display both the title and content of each item:\n\n```tsx\nimport { AccordionData } from '../types';\n\nfunction AccordionItem({ data }: { data: AccordionData }) {\n  return (\n    <li className=\"accordion-item\">\n      <h2 className=\"accordion-item-title\">\n        <button className=\"accordion-item-btn\">{data.title}</button>\n      </h2>\n      <div className=\"accordion-item-container\">\n        <div className=\"accordion-item-content\">{data.content}</div>\n      </div>\n    </li>\n  );\n}\n\nexport default AccordionItem;\n```\n\nAs you can see here, we've also added a type for `data` which should only be `AccordionData`, this is where we reused the type we declared and exported earlier in `src/types.ts`.\n\nNow let's go back to `src/components/Accordion.tsx` and update the code to loop through the items and pass the data to the imported `AccordionItem` component:\n\n```tsx\n...\nimport AccordionItem from './AccordionItem';\n...\n    <ul className=\"accordion\">\n      {items.map((item, idx) => (\n        <AccordionItem key={idx} data={item} />\n      ))}\n    </ul>\n...\n```\n\nOnce you save the changes, our web app should be working fine now without any errors and display something like this:\n\n![Screenshot of accordion partially built in React and TypeScript](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-partial-unstyled.png)\n\n## Accordion styles\n\nYes, it doesn't look like an accordion yet. So let's create the styles and import them to their respective components. Create `Accordion.css` under `components` folder and add the following code below:\n\n```css\n.accordion {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n```\n\nThen import it in `Accordion.tsx`:\n\n```tsx\nimport { AccordionData } from '../types';\nimport AccordionItem from './AccordionItem';\nimport './Accordion.css';\n\nfunction Accordion({ items }: { items: Array<AccordionData> }) {\n...\n```\n\nNext, create `AccordionItem.css` under `components` folder and add the following code below:\n\n```css\n.accordion-item {\n  border: 1px solid #ccc;\n}\n\n.accordion-item:not(:first-of-type) {\n  border-top: 0;\n}\n\n.accordion-item-title {\n  width: 100%;\n  margin: 0;\n}\n\n.accordion-item-btn {\n  display: flex;\n  align-items: center;\n  width: 100%;\n  background-color: #fff;\n  border: 0;\n  padding: 15px 20px;\n  font-size: 18px;\n  font-weight: 400;\n  cursor: pointer;\n  user-select: none;\n}\n\n.accordion-item-btn::after {\n  content: '';\n  flex-shrink: 0;\n  width: 18px;\n  height: 18px;\n  margin-left: auto;\n  background-image: url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23212529'%3e%3cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z'/%3e%3c/svg%3e\");\n  background-repeat: no-repeat;\n  background-size: 18px;\n  transition: transform 0.2s ease-in-out;\n}\n\n.accordion-item.active .accordion-item-btn::after {\n  transform: rotate(-180deg);\n}\n\n.accordion-item-container {\n  transition: height 0.2s ease-in-out;\n  overflow: hidden;\n}\n\n.accordion-item-content {\n  border-top: 1px solid #cccccc;\n  padding: 15px 20px;\n}\n```\n\nAnd import it in `AccordionItem.tsx`:\n\n```tsx\nimport { AccordionData } from '../types';\nimport './AccordionItem.css';\n\nfunction AccordionItem({ data }: { data: AccordionData }) {\n...\n```\n\nOnce you saved the changes, our component should look like this now:\n\n![Screenshot of accordion partially built in React and TypeScript](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-partial-styled.png)\n\n## Accordion Item props\n\nThat's looking like an accordion now. We just need to make it collapsible. Let's start with the logic for `AccordionItem.tsx`. It should accept a prop `isOpen` to determine whether to display the content or not. We can simply use a conditional statement like this:\n\n```tsx\nimport { AccordionData } from '../types';\nimport './AccordionItem.css';\n\nfunction AccordionItem({\n  data,\n  isOpen,\n}: {\n  data: AccordionData;\n  isOpen: boolean;\n}) {\n  return (\n    <li className=\"accordion-item\">\n      <h2 className=\"accordion-item-title\">\n        <button className=\"accordion-item-btn\">{data.title}</button>\n      </h2>\n      <div className=\"accordion-item-container\">\n        {isOpen && <div className=\"accordion-item-content\">{data.content}</div>}\n      </div>\n    </li>\n  );\n}\n\nexport default AccordionItem;\n```\n\nAnd we would be done with this component but because we want it to have a transition, then we need to be more creative here. What can we use then? Yes, you've guessed it! We can control the height of the content's container. If `isOpen` is `false`, then we set the height of the container to `0`, and if it's `true`, then we set the height using the content's height. Since `isOpen` can change at any point of time, we can use one of the React hooks, `useEffect`, to help us with this accordion logic. Let's update the code of `AccordionItem.tsx`:\n\n```tsx\nimport { useEffect, useRef, useState } from 'react';\nimport { AccordionData } from '../types';\nimport './AccordionItem.css';\n\nfunction AccordionItem({\n  data,\n  isOpen,\n  btnOnClick,\n}: {\n  data: AccordionData;\n  isOpen: boolean;\n  btnOnClick: () => void;\n}) {\n  const contentRef = useRef<HTMLDivElement>(null);\n  const [height, setHeight] = useState(0);\n\n  useEffect(() => {\n    if (isOpen) {\n      const contentEl = contentRef.current as HTMLDivElement;\n\n      setHeight(contentEl.scrollHeight);\n    } else {\n      setHeight(0);\n    }\n  }, [isOpen]);\n\n  return (\n    <li className={`accordion-item ${isOpen ? 'active' : ''}`}>\n      <h2 className=\"accordion-item-title\">\n        <button className=\"accordion-item-btn\" onClick={btnOnClick}>\n          {data.title}\n        </button>\n      </h2>\n      <div className=\"accordion-item-container\" style={{ height }}>\n        <div ref={contentRef} className=\"accordion-item-content\">\n          {data.content}\n        </div>\n      </div>\n    </li>\n  );\n}\n\nexport default AccordionItem;\n```\n\nAnd if you're new to TypeScript, you'll notice I used `as HTMLDivElement` here. This is called a [type assertion](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions). If we remove the type assertion, the type of `contentEl.current` would be `HTMLDivElement | null`, but we know in this case it will always have a value of `HTMLDivElement` when `useEffect` is executed. That's why type assertions are done when have information about the type of a value that TypeScript can't know about.\n\nWhen `isOpen` is true, we should also add an `active` class so that the icon would rotate, it's a common transition effect whenever you toggle an accordion.\n\nI've also added a new prop `btnOnClick` which accepts a callback when the button is clicked. We'll use this later to control when to display or hide our content from the parent component.\n\n## Accordion logic (open one at a time)\n\nMoving on to the `Accordion.tsx`, this is where we'll be adding the logic for each accordion items. When an accordion button is clicked, then we should show the contents. We could store a state of which item is displayed, it should be something unique to that item, since our items doesn't have an identifier (or ID) in their data, we could use the `index` of each items. I could think of two ways an accordion behaves, the one that we'll do in this post (which is my favorite by the way!) is opening an accordion one at a time, meaning when there's an accordion that's currently opened, when I click another one, it will close or hide the previous one and display the content of what I last clicked upon. To do that logic, update the `Accordion` component with the following code below:\n\n```tsx\nimport { useState } from 'react';\nimport { AccordionData } from '../types';\nimport AccordionItem from './AccordionItem';\nimport './Accordion.css';\n\nfunction Accordion({ items }: { items: Array<AccordionData> }) {\n  const [currentIdx, setCurrentIdx] = useState(-1);\n  const btnOnClick = (idx: number) => {\n    setCurrentIdx(idx);\n  };\n\n  return (\n    <ul className=\"accordion\">\n      {items.map((item, idx) => (\n        <AccordionItem\n          key={idx}\n          data={item}\n          isOpen={idx === currentIdx}\n          btnOnClick={() => btnOnClick(idx)}\n        />\n      ))}\n    </ul>\n  );\n}\n\nexport default Accordion;\n```\n\nThe initial state value of `currentIdx` (current index) would be `-1`, which means no accordion would be open at the start. When an accordion button is clicked, we would set the `currentIdx` to that accordion's index. This makes the `isOpen` become true since `idx` and `currentIdx` values are equal.\n\nOnce you save the changes, you now have yourself an accordion!\n\n![Screenshot of accordion with one opened in React and TypeScript](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-open-one-at-a-time.png)\n\nBut wait there's one last thing you need to do. If we click on the same accordion again, it still remains open, ideally it should close. So let's do a small update to the code:\n\n```tsx\n...\n  const btnOnClick = (idx: number) => {\n    setCurrentIdx((currentValue) => (currentValue !== idx ? idx : -1));\n  };\n...\n```\n\nAnd there you go, you've just built your own accordion in React and TypeScript!\n\n## Write tests for Accordion.tsx\n\nAlright, time to write tests for the components we've built. Tests are really great as it helps us cover all the logics in our code and whenever we update the codebase, they help us determine whether we broke anything before it the changes get pushed to our repository.\n\nBefore we start, let's install a library called [faker](https://github.com/Marak/faker.js) which gives us random data. Why do we want random data? It makes our tests more reliable as opposed to hardcoding the data we use in testing. Run the command below on your terminal to install it along with its type:\n\n```bash\nyarn add -D faker @types/faker\n```\n\nSince our project uses TypeScript, when installing libraries, we would have to install their types as well, because if not TypeScript would display an error that it couldn't find the library's type declarations.\n\nThat's all we need to install because Create React App already set up and installed the necessary libraries for our testing environment such as Jest and Testing Library.\n\nFor test files, I like to separate them in a folder so that it's less cluttered when viewing main files. Now, create a new folder named `__tests__` under the `src/components`. This is where we will put the test files for components under `src/components`.\n\nAlright, the first component we would be writing test is `Accordion.tsx`. Create a file under `src/components/__tests__` and name it `Accordion.test.tsx`.\n\nThen let's add in the structure of the test:\n\n```tsx\nimport Accordion from '../Accordion';\n\ndescribe('<Accordion />', () => {});\n```\n\n`describe` creates a block that groups together several related tests. So ideally the description should be describing what we are testing, for this case I used the component name. Feel free to rename it according to your preference. `describe` is one of Jest's global functions, so with the setup of Create React App, we don't need to specifically import these global functions in our code, we can just directly use them.\n\nNext we can add a test case inside the `describe` block:\n\n```tsx\ndescribe('<Accordion />', () => {\n  it('should render items', () => {});\n});\n```\n\nAnother global function by Jest, `it` (or `test`) method runs a test. This is where we can have different test cases. Let's write our first test case:\n\n```tsx\nimport { render, screen } from '@testing-library/react';\nimport faker from 'faker';\nimport Accordion from '../Accordion';\n\ndescribe('<Accordion />', () => {\n  it('should render items', () => {\n    const items = [];\n\n    for (let i = 0; i < 3; i++) {\n      items.push({\n        title: faker.lorem.sentence(),\n        content: faker.lorem.sentences(),\n      });\n    }\n\n    render(<Accordion items={items} />);\n\n    items.forEach(({ title, content }) => {\n      const titleEl = screen.queryByText(title);\n      const contentEl = screen.queryByText(content);\n\n      expect(titleEl).toBeInTheDocument();\n      expect(contentEl).toBeInTheDocument();\n    });\n  });\n});\n```\n\nThat's a lot of new code! Don't worry, let me go through it one by one and explain it to you. So first, we created an `items` array which would contain an object of `AccordionData`. We are using `faker` library to help us generate random title and content. You can checkout their API [here](https://github.com/marak/faker.js#api) to know all the other data it can randomly generate. We've added three items which should be enough but you can increase or decrease it if you want, but do note that it should have at least two items in order to test our accordion logic. We then pass this array as a props to our `Accordion` component. Using one of the Testing Library's methods, `render`, helps to render our component in a test environment, do note this environment is not a browser, so there are some limitations and mockings we would have to do which you'll see later on. To learn more about the `render` method, you can go [here](https://testing-library.com/docs/react-testing-library/api/#render). After that, we can do our checks to validate that our items are rendered. To do that, we looped through the items and did a query by text using another method of Testing Library which is `screen.queryByText`. To know all the possible queries you can do with screen, you can go [here](https://testing-library.com/docs/queries/about). Then finally using one of Jest's global functions, we can call `expect` method and pass the elements returned by the query, and run what we call a matcher method `toBeInTheDocument()`. This is one of many custom matcher methods provided by the library called [jest-dom](https://github.com/testing-library/jest-dom#custom-matchers) which are specific to the [DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction). While you can check this [documentation](https://jestjs.io/docs/expect) for the more generic matcher methods.\n\nAlright, I hoped that explained it.\n\nNow let's check if our component passed the test by running the command below in your terminal:\n\n```bash\nyarn test --coverage\n```\n\nThe parameter `--coverage` helps to display the coverage of the tests in which you'll see in your terminal:\n\n![Screenshot of incomplete Accordion test coverage](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-test-coverage-incomplete-1.png)\n\nOur first test case passed! We also managed to cover 66.67% of lines of `Accordion.tsx`. With the `--coverage` parameter, it gives us hints of which lines are uncovered as well, that is line 9 and 19. If we check those lines in our `Accordion.tsx` file, these are related to the logic of opening an accordion item. So let's create the second test case:\n\n```tsx\nimport { fireEvent, render, screen } from '@testing-library/react';\n...\n  it('should open one at a time', () => {\n    const items = [];\n\n    for (let i = 0; i < 3; i++) {\n      items.push({\n        title: faker.lorem.sentence(),\n        content: faker.lorem.sentences(),\n      });\n    }\n\n    render(<Accordion items={items} />);\n\n    items.forEach(({ title }) => {\n      const titleEl = screen.queryByText(title) as HTMLButtonElement;\n\n      fireEvent.click(titleEl);\n\n      const currentListEl = titleEl.closest('li');\n      const activeListEls = document.querySelectorAll('li.active');\n      const activeListEl = activeListEls[0];\n\n      expect(activeListEls.length).toBe(1);\n      expect(activeListEl).toEqual(currentListEl);\n    });\n  });\n});\n```\n\nHere we did the same for generating random data for the props but inside the loop we're doing the checks differently. So first we query the element of the title and fired a click event on it using `fireEvent` which is imported from Testing Library. To fire other DOM events, you can check out the documentation [here](https://testing-library.com/docs/dom-testing-library/api-events/). Any query of element may result as `null` so we added a type assertion (`as HTMLButtonElement`) because `fireEvent` method doesn't accept `null` values, it is safe to use type assertion here because we are certain that the element is or should be in the DOM. Then we queried the list element with an `active` class and check whether it is the same element as the current item's list element, this verifies that our current item is opened. We also did an additional check to make sure that there's only one accordion that is opened at a time (or per loop) by checking that the length of all list item that has an `active` class should only be `1`.\n\nCurrently if you didn't stop the test script server, it will listen for file save changes and automatically run the tests again. This makes writing tests faster as we don't have to re-run the test script again on every change. Our test coverage should look like this now:\n\n![Screenshot of incomplete Accordion test coverage](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-test-coverage-incomplete-2.png)\n\nAwesome, our second test case passed as well! But the line 9 is still uncovered though. If we check that line in our file, it is the logic for closing an opened accordion if it the title is clicked again. So for the last test case, we can achieve the full coverage for `Accordion.tsx` by writing the code below:\n\n```tsx\n...\n  it('should close if already opened', () => {\n    const items = [];\n\n    for (let i = 0; i < 3; i++) {\n      items.push({\n        title: faker.lorem.sentence(),\n        content: faker.lorem.sentences(),\n      });\n    }\n\n    render(<Accordion items={items} />);\n\n    items.forEach(({ title }) => {\n      const titleEl = screen.queryByText(title) as HTMLButtonElement;\n\n      fireEvent.click(titleEl);\n      fireEvent.click(titleEl);\n\n      const currentListEl = titleEl.closest('li');\n\n      expect(currentListEl).not.toHaveClass('active');\n    });\n  });\n});\n```\n\nHere we fired two click events and check that the current item's list element does not contain an `active` class which is a determinator that the accordion is opened.\n\nNow once we save the changes, our coverage should look like this:\n\n![Screenshot of complete Accordion test coverage](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-test-coverage-complete.png)\n\nCool! If you look at `AccordionItem.tsx` it already has `100%` coverage as well. That's because it is also used in `Accordion.tsx` test cases. But it's always good to have each component or function to have its own test cases as well, because that will make our code more robust.\n\n## Write tests for AccordionItem.tsx\n\nCreate a file under `src/components/__tests__` and name it `AccordionItem.test.tsx`. If we want to see how much is covered in `AccordionItem.tsx` while we write tests for it and ignore `Accordion.test.tsx` test cases from running, we can do so by running the test script like this:\n\n```bash\nyarn test --coverage src/components/__tests__/AccordionItem.test.tsx\n```\n\nThis instructs Jest to only run the tests under `src/components/__tests__/AccordionItem.test.tsx`. For now it would fail because it must contain at least one test. So let's write the first test case:\n\n```tsx\nimport { render, screen } from '@testing-library/react';\nimport faker from 'faker';\nimport AccordionItem from '../AccordionItem';\n\ndescribe('<AccordionItem />', () => {\n  it('should render content', () => {\n    const title = faker.lorem.sentence();\n    const content = faker.lorem.sentences();\n\n    render(\n      <AccordionItem\n        data={{ title, content }}\n        isOpen={faker.datatype.boolean()}\n        btnOnClick={jest.fn()}\n      />\n    );\n\n    const titleEl = screen.queryByText(title);\n    const contentEl = screen.queryByText(content);\n\n    expect(titleEl).toBeInTheDocument();\n    expect(contentEl).toBeInTheDocument();\n  });\n});\n```\n\nThese should look familiar to you as we did the same for our first test case in `Accordion.test.tsx` but here we didn't have to create an array of data and loop through the items to do the checks.\n\nAfter saving the changes, the terminal should display this:\n\n![Screenshot of incomplete Accordion Item test coverage](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-item-test-coverage-incomplete.png)\n\nHere, the uncovered lines for `AccordionItem.tsx` is 19-21, but it could be line 23 on your side because we are passing a random `boolean` for `isOpen` props in our first test case. So let's create two new test cases, one for when `isOpen` is `false` and one for when `isOpen` is `true` and we can validate whether the accordion is open or not by checking if there is an `active` class in the list element or not. Write the following code below:\n\n```tsx\n...\n  it('should not display content if isOpen is false', () => {\n    const title = faker.lorem.sentence();\n    const content = faker.lorem.sentences();\n\n    render(\n      <AccordionItem\n        data={{\n          title,\n          content,\n        }}\n        isOpen={false}\n        btnOnClick={jest.fn()}\n      />\n    );\n\n    const titleEl = screen.queryByText(title);\n    const listEl = titleEl?.closest('li');\n\n    expect(listEl).not.toHaveClass('active');\n  });\n\n  it('should display content if isOpen is true', () => {\n    const title = faker.lorem.sentence();\n    const content = faker.lorem.sentences();\n\n    render(\n      <AccordionItem\n        data={{\n          title,\n          content,\n        }}\n        isOpen={true}\n        btnOnClick={jest.fn()}\n      />\n    );\n\n    const titleEl = screen.queryByText(title);\n    const listEl = titleEl?.closest('li');\n\n    expect(listEl).toHaveClass('active');\n  });\n});\n```\n\nOnce changes are saved, we would achieve `100%` test coverage for `AccordionItem.test.tsx`:\n\n![Screenshot of complete Accordion Item test coverage](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-item-test-coverage-complete-1.png)\n\nYou maybe wondering, `active` class just adds the style to rotate the arrow icon but is not really responsible for displaying or hiding the content. That is actually based on the `height` of the container. Can we test that too? Yes, but we will need to update our existing code in `AccordionItem.tsx` because in a test environment, values like `scrollHeight` is always `0` because it does not update measurements like a browser, this is the limitation that I've mentioned earlier. If that's the case, our test case for checking that the height is more than `0` when `isOpen` is `true` would fail. So what should we do?\n\nFirst, create a folder named `lib` under `src` folder. Then create a file under `src/lib` and name it `hooks.ts`. Add the following code inside the newly created file:\n\n```ts\nimport { RefObject } from 'react';\n\nexport function getRefValue<C>(ref: RefObject<C>) {\n  return ref.current as C;\n}\n```\n\nThis is a utility for getting the value of a `RefObject`. I use this a lot in my projects and it is extremely helpful when writing tests to achieve `100%` coverage, especially those components that uses `RefObject` for elements. If you're new to TypeScript, you might be wonder what is this `C` around the code? It can be any letter by the way or word if you would like, and it is called [Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html), it makes our utility function here accept the type defined when the `RefObject` is passed because it can have any type. Using Generics, our function here would be able to return the same type.\n\nThen let's update our `AccordionItem.tsx`:\n\n```tsx\n...\nimport { getRefValue } from '../lib/hooks';\n...\n      const contentEl = getRefValue(contentRef);\n```\n\nNow back to our test file `src/components/__tests__/AccordionItem.test.tsx`, let's update our two test cases and add the additional checks:\n\n```tsx\n...\nimport * as hooks from '../../lib/hooks';\n...\ndescribe('<AccordionItem />', () => {\n  beforeEach(() => {\n    jest.restoreAllMocks();\n  });\n  ...\n  it('should not display content if isOpen is false', () => {\n    const contentScrollHeight = faker.datatype.number({ min: 1 });\n\n    jest.spyOn(hooks, 'getRefValue').mockReturnValue({\n      scrollHeight: contentScrollHeight,\n    });\n\n    const title = faker.lorem.sentence();\n    const content = faker.lorem.sentences();\n\n    render(\n      <AccordionItem\n        data={{\n          title,\n          content,\n        }}\n        isOpen={false}\n        btnOnClick={jest.fn()}\n      />\n    );\n\n    const titleEl = screen.queryByText(title);\n    const listEl = titleEl?.closest('li');\n    const contentEl = screen.queryByText(content);\n    const contentContainerEl = contentEl?.parentElement;\n\n    expect(listEl).not.toHaveClass('active');\n    expect(contentContainerEl).toHaveStyle({ height: '0px' });\n  });\n\n  it('should display content if isOpen is true', () => {\n    const contentScrollHeight = faker.datatype.number({ min: 1 });\n\n    jest.spyOn(hooks, 'getRefValue').mockReturnValue({\n      scrollHeight: contentScrollHeight,\n    });\n\n    const title = faker.lorem.sentence();\n    const content = faker.lorem.sentences();\n\n    render(\n      <AccordionItem\n        data={{\n          title,\n          content,\n        }}\n        isOpen={true}\n        btnOnClick={jest.fn()}\n      />\n    );\n\n    const titleEl = screen.queryByText(title);\n    const listEl = titleEl?.closest('li');\n    const contentEl = screen.queryByText(content);\n    const contentContainerEl = contentEl?.parentElement;\n\n    expect(listEl).toHaveClass('active');\n    expect(contentContainerEl).toHaveStyle({\n      height: `${contentScrollHeight}px`,\n    });\n  });\n});\n```\n\nLet's analyse the updated code. First, we imported our `hooks` file using `* as hooks` in order to get an object of methods from `src/lib/hooks.ts`. We then use one of Jest's methods called `jest.spyOn` which tracks the calls to `object[methodName]` that you passed to it. It returns a Jest mock function which we can mock to return a different value using `.mockReturnValue()`. To see all mock functions you could do, check them out [here](https://jestjs.io/docs/mock-functions). When we do mocks in our test cases, it does not get restored back to their original value in the next test case, this might cause potential issues with the next test cases so it's good to call `jest.restoreAllMocks()` to prevent that. Instead of calling this function in the beginning of every test cases, we can put the call inside one of Jest's methods `beforeEach`, it accepts a callback which will be called before each test cases, and put it inside the `describe` call back right at the beginning before any test cases.\n\nSo we mocked the scroll height of the content element with a random generated number (minimum should be `1` because `0` means the content is hidden) and did the checks based on our accordion item logic. If the accordion item is opened, the content element's container should have the same height as the scroll height of the content element. If it's closed, then the height should be `0px`.\n\nNow if we check our test results, it should be like this:\n\n![Screenshot of complete Accordion Item test coverage](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/accordion-item-test-coverage-complete-2.png)\n\nGreat! Even though it already has `100%` test coverage, let's not forget to test the `btnOnClick` props, same reason for having each component or function having their own tests, each props you introduce, if logical, should also have their own tests. Similar to what we did in `Accordion.test.tsx`, we can fire a click event to the title of the accordion item, but in this case our verification would be to check if the function passed in the props was called. To validate that, add the following code below:\n\n```tsx\nimport { fireEvent, render, screen } from '@testing-library/react';\n...\n  it('should call btnOnClick on title click', () => {\n    const btnOnClickMock = jest.fn();\n\n    const title = faker.lorem.sentence();\n    const content = faker.lorem.sentences();\n\n    render(\n      <AccordionItem\n        data={{\n          title,\n          content,\n        }}\n        isOpen={faker.datatype.boolean()}\n        btnOnClick={btnOnClickMock}\n      />\n    );\n\n    const titleEl = screen.queryByText(title) as HTMLButtonElement;\n\n    fireEvent.click(titleEl);\n\n    expect(btnOnClickMock).toBeCalledTimes(1);\n  });\n});\n```\n\n## Write tests for hooks.ts\n\nI've mentioned it earlier that each component or function we create should have their own tests. So as a bonus, here's the test case for the hooks utility we created earlier, the code below should be added inside `src/lib/__tests__/hooks.test.ts`:\n\n```ts\nimport faker from 'faker';\nimport { getRefValue } from '../hooks';\n\ndescribe('hooks utilities', () => {\n  describe('getRefValue()', () => {\n    it('should return the value', () => {\n      const refValue = faker.lorem.sentence();\n      const refObject = { current: refValue };\n      const res = getRefValue(refObject);\n\n      expect(res).toBe(refValue);\n    });\n  });\n  a;\n});\n```\n\n## Write tests for App.tsx\n\nAnd then here's the code for testing our `App` component under `src/__tests__/App.test.tsx`:\n\n```tsx\nimport { render } from '@testing-library/react';\nimport App from '../App';\n\ndescribe('<App />', () => {\n  it('should render without errors', () => {\n    const { container } = render(<App />);\n\n    expect(container).toBeInTheDocument();\n  });\n});\n```\n\nWhen you run the all the tests again via `yarn test --coverage`, it will look very satifying as the terminal would display all green and all 100% covered:\n\n![Screenshot of complete test coverage](/images/posts/how-to-create-your-own-accordion-in-react-and-typescript-with-tests/test-coverage-complete.png)\n\nAnd there you have it! You've just built your own accordion in React and TypeScript with tests! I hope you've learned a lot from this post, especially those who are new to TypeScript and Jest.\n\nIn case you need the final code of the accordion as a reference, this is the [link](https://github.com/dominicarrojado/react-typescript-accordion) to the GitHub repository.\n\nPlease don't forget to share this post and just a heads up, I'll be writing more of these \"building your own components in React and TypeScript with tests\" so if you're interested, you can come back to my blog to check it out once they're published.\n","previousPost":{"id":"local-development-setup-for-react-and-typescript-projects","title":"Local development setup for React and TypeScript projects","date":"2021-09-26","excerpt":"A quick way to get started with React and TypeScript","category":"technology","videoUrl":""},"nextPost":null,"title":"How to create your own accordion in React and TypeScript with tests","date":"2021-09-26","excerpt":"Learn how to build a collapsible content in a reactive and reusable way","category":"technology","videoUrl":"https://youtu.be/Hn7iDjbPtVY"}},"__N_SSG":true}