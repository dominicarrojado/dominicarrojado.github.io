{"pageProps":{"postData":{"id":"how-to-create-your-own-swiper-in-react-and-typescript-with-tests-part-1","content":"\n## Introduction\n\nSwiper, carousel, slider. I bet you've heard one of these before. They can be easily seen in modern websites today. That's because they provide an interactive section for users to swipe or drag through the slide of images or content. In my early days of web development, I've used a third-party library to implement it in my web projects. But now I've learned how to build one myself and I would like to share this knowledge on how to build your own swiper in [React](https://reactjs.org/) and [TypeScript](https://www.typescriptlang.org/), as well as write tests for it using [Jest](https://jestjs.io/) and [Testing Library](https://testing-library.com/).\n\nThere's nothing wrong with using a third-party library since it saves us a lot of time but it's also not good to be too dependent on it. Sometimes there are extra features you don't need, it will add unnecessary size to your assets bundle. Sometimes customization options are not enough to achieve the expected design of the component. What if there's no third-party library that can implement the component you need? Do you just wait until someone else builds it for you? Learning how to build your own will not only help you avoid these issues but also give you the knowledge and confidence you may require in the future to extend your swiper component or even build other components.\n\nSo if you're interested to learn how to build your own swiper, swipe down (no pun intended)!\n\n## Prerequisites\n\nThis is the [link to the swiper](/react-typescript-swiper/) which we'll accomplish by the end of this post, you can see and play around with it or use it as your reference throughout this tutorial.\n\nUpon writing this post, I assume that you have some web development background and basic knowledge regarding [npm](https://www.npmjs.com/), [yarn](https://classic.yarnpkg.com/lang/en/), [HTML](https://developer.mozilla.org/en-US/docs/Web/HTML), [CSS](https://developer.mozilla.org/en-US/docs/Web/CSS), [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript) and [React](https://reactjs.org/).\n\nMake sure to install [Yarn](https://classic.yarnpkg.com/lang/en/) in your system if you haven't. We use [Yarn](https://classic.yarnpkg.com/lang/en/) as our package manager, it's just like [npm](https://www.npmjs.com/) but _faster_.\n\nI've written a [separate post](/posts/local-development-setup-for-react-and-typescript-projects/) about the [IDE](https://en.wikipedia.org/wiki/Integrated_development_environment) and extensions I use to help me save time and energy when writing my code in React. I highly suggest that you check it out if you haven't!\n\n## Initialize your project\n\nFastest way to start a new project with React is using the [Create React App](https://create-react-app.dev/). It is an officially supported way to create single-page React applications. It offers a modern build setup with no configuration so you can focus on code, not build tools.\n\nTo create our project with React and TypeScript, run this command in your terminal:\n\n```bash\nyarn create react-app react-typescript-swiper --template typescript\n```\n\nOnce project is initiated, install the additional libraries which we'll be using later on:\n\n```bash\ncd react-typescript-swiper\nyarn add @testing-library/react-hooks faker@5.5.3 @types/faker@5.5.9\n```\n\nTo run our project, execute the command below:\n\n```bash\nyarn start\n```\n\nThis command will open your default browser and go to `http://localhost:3000/`. If it doesn't, you can do it yourself too.\n\nThis setup comes with live-editing or hot reloading which means when we save file changes, it will automatically update the app and reload on the browser. That's great for local development!\n\n---\n\n## Clean up the project\n\nWe're ready to code! Let's clean up our project which was created by Create React App. We won't be needing some of them. Delete or clear the contents of the following below:\n\n- src/App.css (clear contents)\n- src/App.test.tsx (delete)\n- src/logo.svg (delete)\n\nThen let's update the code of `src/App.tsx`:\n\n```tsx\nimport './App.css';\n\nfunction App() {\n  return <div className=\"container\"></div>;\n}\n\nexport default App;\n```\n\nWe will use the `App` component as the container of our swiper. Then, add the following code to `src/App.css`:\n\n```css\n.container {\n  width: 800px;\n  max-width: 100%;\n  margin: 0 auto;\n  padding: 20px 15px;\n}\n```\n\nAnd update the `src/index.css` too:\n\n```css\n* {\n  box-sizing: border-box;\n}\n\nbody {\n  margin: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto',\n    'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans',\n    'Helvetica Neue', sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n```\n\nThat's about it. This will be the container of our Swiper component.\n\n## Swiper component\n\nNormally, I like to put all my components in a folder called `components`. Go ahead and create that folder under the `src` folder. Once you've done that, create `src/components/Swiper.tsx` and add the following code below:\n\n```tsx\nimport React from 'react';\n\nimport './Swiper.css';\n\nexport default function Swiper() {\n  return (\n    <div className=\"swiper-container\">\n      <ul className=\"swiper-list\"></ul>\n    </div>\n  );\n}\n```\n\n---\n\n## Swiper styles\n\nLet's add some style for our Swiper component by creating `src/components/Swiper.css` and add the following code below:\n\n```css\n.swiper-container {\n  width: 100%;\n  max-width: 100%;\n  overflow: auto;\n}\n\n.swiper-list {\n  min-width: 100%;\n  display: flex;\n  flex-direction: row;\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n```\n\nWhen you save these changes, you won't be seeing anything in our web application but a blank page. Don't worry, you'll get to see something very soon! For now, we'll just code it all first. Let's continue.\n\n## SwiperItem component\n\nSince our Swiper component is like a gallery of images we need a separate component for each image and we can name it `SwiperItem` component. Create a file `src/components/SwiperItem.tsx` and add the following code below:\n\n```tsx\nimport React from 'react';\n\nimport './SwiperItem.css';\n\nfunction SwiperItem() {\n  return (\n    <li className=\"swiper-item\">\n      <img src=\"\" alt=\"\" className=\"swiper-img\" />\n    </li>\n  );\n}\n\nexport default SwiperItem;\n```\n\nAnd let's add the styles for it in `src/components/SwiperItem.css`:\n\n```css\n.swiper-item {\n  width: 100%;\n  flex-shrink: 0;\n}\n\n.swiper-img {\n  width: 100%;\n  height: auto;\n  user-select: none;\n}\n```\n\nAlright, currently our `SwiperItem` component is not reusable to display different images, how do you make a component reusable? Through [component props](https://reactjs.org/docs/components-and-props.html)! For this tutorial, we just need the source URL of the image and an alternative text for each item. Both values are required and should be `string`. For those new to TypeScript, this will be your first encounter of the syntax, I'll be explaning it in a bit. Let's update `src/components/SwiperItem.tsx` first with the codes below:\n\n```tsx\nimport React from 'react';\n\nimport './SwiperItem.css';\n\nfunction SwiperItem({\n  imageSrc,\n  imageAlt,\n}: {\n  imageSrc: string;\n  imageAlt: string;\n}) {\n  return (\n    <li className=\"swiper-item\">\n      <img src={imageSrc} alt={imageAlt} className=\"swiper-img\" />\n    </li>\n  );\n}\n\nexport default SwiperItem;\n```\n\nOk, if you're new to TypeScript, this is how we can create a type for our props (or any object). If we try to use our `SwiperItem` component without passing any props, TypeScript would throw an error. Because we defined the type of the fields in our props to be _required_. Same thing would happen if you try to pass another type which is _not_ a `string`. Let's say you pass a type of a `number`, that would also throw an error. You can already see how helpful TypeScript is in catching potential issues early on.\n\nYou might ask, how do we define an _optional_ field? You can do that by adding a question mark before the `:` like this:\n\n```ts\n{\n  imageSrc?: string;\n  imageAlt?: string;\n}\n```\n\nAlright, we're not done yet. I already forsee that we would be reusing the same type in our `Swiper` component. So what I normally like to do is place reusable types in a single file. Let's go ahead and do that.\n\n---\n\n## Create the type\n\nCreate `src/types.ts`. This will be the place we could put shared types across components to reduce code duplication, although for this guide, we are only going to add one type, that would be the `SwiperItemType`. So update the file with the following code:\n\n```ts\nexport type SwiperItemType = {\n  imageSrc: string;\n  imageAlt: string;\n};\n```\n\nThis is how we can declare a type (or [type aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases)) and make it reusable by exporting it.\n\nNow go back to `SwiperItem` component and update the code to use the type alias we just created:\n\n```tsx\nimport React from 'react';\nimport { SwiperItemType } from '../types';\n\nimport './SwiperItem.css';\n\n// exported so we can use later in tests\nexport type Props = SwiperItemType;\n\nfunction SwiperItem({ imageSrc, imageAlt }: Props) {\n  return (\n    <li className=\"swiper-item\">\n      <img src={imageSrc} alt={imageAlt} className=\"swiper-img\" />\n    </li>\n  );\n}\n\nexport default SwiperItem;\n```\n\n## Swiper + SwiperItem component\n\nWe can now use `SwiperItem` component in our `Swiper` component. Since our `Swiper` component would be the main component that will be reused across our React application. It needs to accept a prop that is an array of swiper items. Remember we already created the type for that, we just need to wrap it in an `Array` to tell TypeScript that the field accepts an array of `SwiperItemType`. You can see the code below on how to do that, simply update our `Swiper` component with this:\n\n```tsx\nimport React from 'react';\nimport { SwiperItemType } from '../types';\nimport SwiperItem from './SwiperItem';\n\nimport './Swiper.css';\n\n// exported so we can use later in tests\nexport type Props = {\n  items: Array<SwiperItemType>;\n};\n\nfunction Swiper({ items }: Props) {\n  return (\n    <div className=\"swiper-container\">\n      <ul className=\"swiper-list\">\n        {items.map((item, idx) => (\n          <SwiperItem key={idx} {...item} />\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default Swiper;\n```\n\n---\n\n## Sample data\n\nWe're almost there to seeing something in our browser. We would need some sample data. I found [some images](https://mdn.github.io/learning-area/javascript/building-blocks/gallery/) we could use from [MDN Web Docs](https://developer.mozilla.org/en-US/). I don't own these images and I hope they don't mind if we use them for this tutorial, all credits goes to them. Please open the images below in another tab and download them:\n\n- [pic1.jpeg](/react-typescript-swiper/pic1.jpeg)\n- [pic2.jpeg](/react-typescript-swiper/pic2.jpeg)\n- [pic3.jpeg](/react-typescript-swiper/pic3.jpeg)\n- [pic4.jpeg](/react-typescript-swiper/pic4.jpeg)\n- [pic5.jpeg](/react-typescript-swiper/pic5.jpeg)\n\nAfter you've downloaded them all, put them in the `public` folder of your React project.\n\nThen let's update our `App` component with the code below:\n\n```tsx\nimport './App.css';\nimport Swiper from './components/Swiper';\n\nfunction App() {\n  const items = [\n    {\n      imageSrc: '/pic1.jpeg',\n      imageAlt: \"A person's eye\",\n    },\n    {\n      imageSrc: '/pic2.jpeg',\n      imageAlt: 'A rock formation',\n    },\n    {\n      imageSrc: '/pic3.jpeg',\n      imageAlt: 'Some flowers',\n    },\n    {\n      imageSrc: '/pic4.jpeg',\n      imageAlt: 'An egyptian wall painting',\n    },\n    {\n      imageSrc: '/pic5.jpeg',\n      imageAlt: 'A butterfly on a leaf',\n    },\n  ];\n\n  return (\n    <div className=\"container\">\n      <Swiper items={items} />\n    </div>\n  );\n}\n\nexport default App;\n```\n\nOnce you save the changes, you should see something like this:\n\n![Screenshot of React Swiper 1](/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/swiper-1.png)\n\nI know, there's a creepy eye looking at us! But in the bright side, that's when we know everything is working fine as expected. You could also see that there's a scroll bar below the image, you can scroll to see the other images. For the next steps, this scroll bar should be hidden and we should be able to swipe through our gallery of images by doing a drag action in desktop or swipe in mobile. So let's continue!\n\n---\n\n## Touch/Drag logic\n\nBefore we proceed to coding, I want to explain what we want to accomplish so you get a better grasp of what is being coded and why is the logic like this. To better explain it, let's do it in a step-by-step way:\n\n| #   | User actions                                   | Swiper logic                                                                                                  |\n| --- | ---------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |\n| 1   | User sees the Swiper                           | First image is displayed                                                                                      |\n| 2   | User clicks/touches the swiper                 | Position of click/touch is recorded as starting position                                                      |\n| 3   | User holds and drags/swipes from right to left | Difference between starting position and current position calculated to move image along with the user action |\n| 4   | User lets go of drag/swipe                     | New image is displayed depending on nearest position                                                          |\n\nAlright, I hope with this you get an understanding what code we need to add in our `Swiper` component.\n\nTo start, let's make a minor update of the style of our `Swiper` component to hide the scroll bar. We won't be needing it. Go to `src/components/Swiper.css` and update with the following code:\n\n```css\n.swiper-container {\n  ...\n  overflow: hidden;\n  touch-action: pan-y; /* prevent browser's default behaviour on swiping horizontally */\n}\n```\n\nIn web browsers, there's this behaviour that you can drag a link or an image to open it in a new tab, this will affect our touch/drag logic, so in order to prevent that, let's also make a minor code update in our `src/components/SwiperItem.tsx`:\n\n```tsx\n...\n\nfunction SwiperItem({ imageSrc, imageAlt }: SwiperItemType) {\n  return (\n    <li className=\"swiper-item\">\n      <img\n        ...\n        draggable={false}\n      />\n    </li>\n  );\n}\n\n...\n```\n\nNext, let's create `src/lib/hooks.ts` and create a couple of hooks utility functions:\n\n```tsx\nimport { useRef, useState, RefObject } from 'react';\n\n// to get the value of a ref from `useRef`\nexport function getRefValue<C>(ref: RefObject<C>) {\n  return ref.current as C;\n}\n\n// extension of `useState` to be able to access the state as a ref\nexport function useStateRef<S>(\n  defaultValue: S\n): [S, (value: S) => void, RefObject<S>] {\n  const ref = useRef<S>(defaultValue);\n  const [state, _setState] = useState<S>(defaultValue);\n  const setState = (value: S) => {\n    _setState(value);\n    ref.current = value;\n  };\n\n  return [state, setState, ref];\n}\n```\n\nI use these utility functions a lot in my projects and it is extremely helpful when writing tests to achieve `100%` coverage, especially those components that uses `RefObject` for elements. If you're new to TypeScript, you might be wonder what is this `C` or `S` around the code? It can be any letter by the way or word if you would like, and it is called [Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html), it makes our utility function here accept the type defined when the `RefObject` or the state is passed because it can have any type. Using Generics, our function here would be able to return the same type.\n\n```tsx\n// let's say we set the initial value with a type of `number` in `useRef`\nconst numberRef = useRef(0);\n\n// when we use `getRefValue` to get the value of the ref\n// TypeScript would then assume this would return a type of `number`\ngetRefValue(numberRef);\n```\n\n---\n\nFinally, go to `src/components/Swiper.tsx` and let's try to think how do we move the images the way we do when there was a scroll bar. If you guessed it right, we can use a transform function in CSS to move the parent element of the images. We can use [`translateX`](<https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translateX()>) or [`translate3d`](<https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate3d()>). Let's use `translate3d` instead because I've seen popular swiper libraries often use it for better performance. We need to store the value required for `translate3d` as a state. Let's call this value as `offsetX`. Let's use `useStateRef` for that instead of `useState` because we need to access the state value as a `ref` in one of our event listeners later on.\n\n```tsx\n...\nimport { useStateRef } from '../lib/hooks';\n\n...\n\nfunction Swiper({ items }: Props) {\n  const [offsetX, setOffsetX, offsetXRef] = useStateRef(0);\n\n  return (\n    <div className=\"swiper-container\">\n      <ul\n        className=\"swiper-list\"\n        style={{ transform: `translate3d(${offsetX}px, 0, 0)` }}\n      >\n        {items.map((item, idx) => (\n          <SwiperItem key={idx} {...item} />\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n...\n```\n\n`0` would be the default value for our `offsetX` state and that will display the first image. Try replacing `0` with a negative value (e.g. `-800`), if you're in a desktop viewport, it should display the second image. This is how we're going to move the images in a reactive way.\n\nNormally, I develop features or logic in a [mobile-first approach](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Responsive/Mobile_first) but I thought it would be easier to code and explain to you if we cover the mouse events first. Let's create the first mouse event, `onMouseDown` which is triggered when you click on the element that is listening to that event. Let's update `src/components/Swiper.tsx` with the code below:\n\n```tsx\n...\n\nfunction Swiper({ items }: Props) {\n  ...\n\n  const onMouseDown = (e: React.MouseEvent<HTMLDivElement>) => {};\n\n  return (\n    <div className=\"swiper-container\" onMouseDown={onMouseDown}>\n      ...\n    </div>\n  );\n}\n\n...\n```\n\nIf you're new to TypeScript, you would need to define the type of `e` (or event data). Since we attached the `onMouseDown` listener in a reactive way, it receives a custom event data from React. So instead of simply using `MouseEvent` as the type of `e`, we need to use `React.MouseEvent` which accepts an argument of what type of `Element` do we expect, in this case we expect it to be an `HTMLDivElement`.\n\nAlright, inside the listener, what we can do is save the current offset `x`. We already have `offsetX`, so why we need a separate storage for the current offset `x`? That's because we're using `offsetX` to move the images, if it's going to be changed on every mouse move event, we will lose track what was the original offset `x` value on mouse down. We need the original offset `x` so we could deduct it with the difference of starting `x` position and moving `x` position, in order to create the effect where the images follow our mouse cursor. Let's call this current offset `x` as `currentOffsetX` and we can store it in [`useRef`](https://reactjs.org/docs/hooks-reference.html#useref) so it could be access by other event listeners later on. To write this in code, it would be like this:\n\n```tsx\n...\nimport { getRefValue, useStateRef } from '../lib/hooks';\n\n...\n\nfunction Swiper({ items }: Props) {\n  const currentOffsetXRef = useRef(0);\n  const [offsetX, setOffsetX, offsetXRef] = useStateRef(0);\n\n  const onMouseDown = (e: React.MouseEvent<HTMLDivElement>) => {\n    currentOffsetXRef.current = getRefValue(offsetXRef);\n  };\n\n  ...\n}\n\n...\n```\n\n---\n\nIn our `onMouseDown` function, we can also save the starting `x` position returned from the event data. Let's name it `startX` and we could use this value later to calculate the offset required for the images to follow our mouse cursor. Update `src/components/Swiper.tsx` with the following code below:\n\n```tsx\n...\n\nfunction Swiper({ items }: Props) {\n  const currentOffsetXRef = useRef(0);\n  const startXRef = useRef(0);\n  const [offsetX, setOffsetX, offsetXRef] = useStateRef(0);\n\n  const onMouseDown = (e: React.MouseEvent<HTMLDivElement>) => {\n    currentOffsetXRef.current = getRefValue(offsetXRef);\n    startXRef.current = e.clientX;\n  };\n\n  ...\n}\n\n...\n```\n\nWe can now create the two other mouse event listeners, namely `onMouseMove` and `onMouseUp`. The sequence of a dragging using your mouse is like this:\n\nSTART -> `onMouseDown` -> `onMouseMove` -> `onMouseUp` -> END\n\nSo we only need to listen to these two events when user triggers `onMouseDown`. We can start listening to these two other events inside `onMouseDown`. Update `src/components/Swiper.tsx` with the following code below:\n\n```tsx\n...\n\nfunction Swiper({ items }: Props) {\n  ...\n\n  const onMouseMove = (e: MouseEvent) => {};\n  const onMouseUp = () => {\n    window.removeEventListener('mouseup', onMouseUp);\n    window.removeEventListener('mousemove', onMouseMove);\n  };\n  const onMouseDown = (e: React.MouseEvent<HTMLDivElement>) => {\n    ...\n\n    window.addEventListener('mousemove', onMouseMove);\n    window.addEventListener('mouseup', onMouseUp);\n  };\n\n  ...\n}\n\n...\n```\n\nWe attached these two events in the `window` so that even if the mouse cursor goes out of the list element, it will still continue to fire both the mouse move and mouse up event. You would also notice the type of `e` from `onMouseMove` is using just the `MouseEvent` which is not from React, you don't have to import it from anywhere, it can used as is. We also didn't have to define `e` from `onMouseUp` because we just need it to remove the event listeners once it is triggered and don't need anything from the event data.\n\nNow, let's then add the code inside `onMouseMove`, here it is:\n\n```tsx\n...\n\nfunction Swiper({ items }: Props) {\n  ...\n\n  const onMouseMove = (e: MouseEvent) => {\n    const currentX = e.clientX;\n    const diff = getRefValue(startXRef) - currentX;\n    const newOffsetX = getRefValue(currentOffsetXRef) - diff;\n\n    setOffsetX(newOffsetX);\n  };\n\n  ...\n}\n\n...\n```\n\nHere, we took the `x` position from the event data and named it `currentX`. We then calculated the difference between the `startX` and the `currentX`, this difference is then subtracted from `currentOffsetX`. The final difference will then be the new value for `offsetX`.\n\nOnce all of the changes are done, you should be able to drag using your mouse to move the container of images horizontally. Isn't that great? I think yes!\n\n---\n\nTo apply the same logic for mobile. Create a file `src/lib/dom.ts` and add the following code:\n\n```tsx\nimport React from 'react';\n\nexport function getTouchEventData(\n  e:\n    | TouchEvent\n    | MouseEvent\n    | React.TouchEvent<HTMLElement>\n    | React.MouseEvent<HTMLElement>\n) {\n  return 'changedTouches' in e ? e.changedTouches[0] : e;\n}\n```\n\nI created this helper function because in touch events, it doesn't return the `clientX` in the event data, it is stored in the `changedTouches` array. So if `changedTouches` exists in the event data, then we should get the `clientX` value from the first element of it. If you're new to TypeScript, we could use pipe `|` to do like an `OR` condition, so what we did here is basically defined the type of the argument `e` such that it can be a `TouchEvent` or a `MouseEvent` which are for events we attach using `.addEventListener()`. It could also be a `React.TouchEvent<HTMLElement>` or a `React.MouseEvent<HTMlElement>` which are event listeners we attach in an element as an attribute (e.g. `onTouchStart`, `onMouseDown`, etc.).\n\nAlright, let's do some renaming in `src/components/Swiper.tsx` for a mobile-first approach and make use of this new helper function:\n\n```tsx\n...\nimport { getTouchEventData } from '../lib/dom';\n\n...\n\nfunction Swiper({ items }: Props) {\n  ...\n\n  const onTouchMove = (e: TouchEvent | MouseEvent) => {\n    const currentX = getTouchEventData(e).clientX;\n\n    ...\n  };\n  const onTouchEnd = () => {\n    window.removeEventListener('touchend', onTouchEnd);\n    window.removeEventListener('touchmove', onTouchMove);\n    window.removeEventListener('mouseup', onTouchEnd);\n    window.removeEventListener('mousemove', onTouchMove);\n  };\n  const onTouchStart = (\n    e: React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>\n  ) => {\n    ...\n    window.addEventListener('touchmove', onTouchMove);\n    window.addEventListener('touchend', onTouchEnd);\n    window.addEventListener('mousemove', onTouchMove);\n    window.addEventListener('mouseup', onTouchEnd);\n  };\n\n  return (\n    <div\n      className=\"swiper-container\"\n      onTouchStart={onTouchStart}\n      onMouseDown={onTouchStart}\n    >\n      ...\n    </div>\n  );\n}\n\n...\n```\n\nIf you try dragging using your mouse, it should still work like before. If your browser supports [device toolbar](https://developer.chrome.com/docs/devtools/device-mode/), you can verify that using touch would work also work. This is how it looks like when using the device toolbar in [Google Chrome](https://www.google.com/intl/en_sg/chrome/):\n\n![Screenshot of React Swiper in device toolbar](/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/swiper-mobile.png)\n\nOkay, we're not done yet though. You might have already noticed it while testing. When you swipe or drag too far away from the first image or last image, you'll see nothing. For user experience, that's not really great. We should prevent that.\n\n---\n\n## Prevent swiping on both ends\n\nTo fix the problem, we need to understand the problem. We already know that we use `offsetX` to move the container of the image, and that it shouldn't move beyond the images. So we need to know the value of the far most left `offsetX` value and the far most right `offsetX` value. The far most left is easy, we start with 0 for `offsetX` to display the first image, there's no image before the first image, so that is already the first end. So what is the far most right `offsetX` value? That would be the width of the container. Let's name far most left `offsetX` value to be `maxOffsetX` while the far most right `offsetX` value to be `minOffsetX`.\n\nTo get into coding, let's declare the `useRef` for the container element in `/src/components/Swiper.tsx` so we could get its `offsetWidth`:\n\n```tsx\n...\n\nfunction Swiper({ items }: Props) {\n  const containerRef = useRef<HTMLUListElement>(null);\n\n  ...\n\n  return (\n    <div\n      className=\"swiper-container\"\n      ...\n    >\n      <ul\n        ref={containerRef}\n        ...\n      >\n        ...\n      </ul>\n    </div>\n  );\n}\n\n...\n```\n\nIf you're new to TypeScript, this is [how](https://github.com/typescript-cheatsheets/react#option-1-dom-element-ref) we declare a ref for an element, we provide the element type and use `null` as initial value. TypeScript expects you to give this ref to an element's ref prop or attribute.\n\nNext, let's calculate the the `minOffsetX` on mouse down event so we don't have to keep calculating it during mouse move because that would be inefficient. Let's update our `src/components/Swiper.tsx`:\n\n```tsx\n...\n\nfunction Swiper({ items }: Props) {\n  ...\n  const minOffsetXRef = useRef(0);\n\n  ...\n\n  const onTouchStart = (\n    e: React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>\n  ) => {\n    ...\n\n    const containerEl = getRefValue(containerRef);\n\n    minOffsetXRef.current = containerEl.offsetWidth - containerEl.scrollWidth;\n\n    ...\n  };\n\n  ...\n}\n\n...\n```\n\nJust in case you're wondering how we came up with this calculation. We needed to get the entire width of all the images together and that value would be the container's `scrollWidth`. Since we start from `0` to display the first image, to display the image it would not be negative value of `scrollWidth`, we need to deduct the display size of the container on to it. And in case you forget, we need a negative value to move the images from right to the left.\n\nAlright, now that we know `maxOffsetX` is `0` and we already computed `minOffsetX` on mouse down. Let's add some `if` conditions to prevent swiping from both ends. Simple update `src/components/Swiper.tsx` with the following code:\n\n```tsx\n...\n\nfunction Swiper({ items }: Props) {\n  ...\n\n  const onTouchMove = (e: TouchEvent | MouseEvent) => {\n    ...\n    let newOffsetX = getRefValue(currentOffsetXRef) - diff;\n\n    const maxOffsetX = 0;\n    const minOffsetX = getRefValue(minOffsetXRef);\n\n    if (newOffsetX > maxOffsetX) {\n      newOffsetX = maxOffsetX;\n    }\n\n    if (newOffsetX < minOffsetX) {\n      newOffsetX = minOffsetX;\n    }\n\n    setOffsetX(newOffsetX);\n  };\n\n  ...\n}\n\n...\n```\n\nAfter saving the changes, you can go back and try swiping through your swiper and you wouldn't be able to swipe if you are at either both ends. Cool!\n\nNext thing we need to solve is the difficulty in swiping through the images, our Swiper component should be able to let us swipe easily to the next image and place the next image in display properly because we want our users to do less swiping and also let them view each images in full, not in split view.\n\n---\n\n## Auto swipe to nearest image\n\nTo swipe images exactly in their position, we need to understand each `offsetX` value to display the images. Let's say in a large screen resolution, our container width would be `800px`. We know that `offsetX` starts with `0px` which displays the first image. To display the second image, you would need the `offsetX` to be `800px` which is the same as the container width. To display the third image, you would need the `offsetX` to be `1600px` which is twice the container width. And we just keep multiplying the container width until we reach the last image. With this, we can basically say that it's always the multiples of the container width because our images takes up `100%` of the container which what we have defined in the CSS style.\n\nSo the logic we need to do is basically when user stops dragging/swiping (`onMouseUp` event listener), our logic should swipe it to the nearest image. How do we get the nearest image? We can round off the last `offsetX` position to the nearest multiples of the container width. We can use [`Math.round`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round) and the formula for rounding to the nearest multiple of a number (in this case the `containerWidth`) is like this:\n\n```js\nMath.round(offsetX / containerWidth) * containerWidth;\n\n// for example, we want to round off to the nearest multiples of `5`\n// result would be 0, 5, 10, 15, and so on ...\nMath.round(1 / 5) * 5; // 0\nMath.round(2 / 5) * 5; // 0\nMath.round(4 / 5) * 5; // 5\nMath.round(5 / 5) * 5; // 5\nMath.round(8 / 5) * 5; // 10\n```\n\nLet's use this formula and update the code for `src/container/Swiper.tsx`:\n\n```tsx\n\n...\n\nfunction Swiper({ items }: Props) {\n  ...\n\n  const onTouchEnd = () => {\n    const containerWidth = getRefValue(containerWidthRef);\n    let newOffsetX = getRefValue(offsetXRef);\n    newOffsetX = Math.round(newOffsetX / containerWidth) * containerWidth;\n\n    setOffsetX(newOffsetX);\n\n    ...\n  };\n\n  ...\n}\n\n...\n```\n\nNow try dragging/swiping through the images and let go, it should show the nearest image within the container properly, what I meant by properly here is that the position is just nice to display you the image in full.\n\nIt's a little bit abrupt right now. So let's try adding some [CSS transitions](https://developer.mozilla.org/en-US/docs/Web/CSS/transition) so this logic will look more sleek. Go to `src/container/Swiper.css` and update the code with this:\n\n```css\n/* ... */\n\n.swiper-list {\n  ...\n  transition: transform 0.3s ease-out;\n}\n\n.swiper-list.is-swiping {\n  transition: none;\n}\n```\n\nAlright, and let's update `src/container/Swiper.tsx` to make use of this transition style:\n\n```tsx\nimport React, { useState, useRef } from 'react';\n\n...\n\nfunction Swiper({ items }: Props) {\n  ...\n\n  const [isSwiping, setIsSwiping] = useState(false);\n\n  ...\n\n  const onTouchEnd = () => {\n    ...\n\n    setIsSwiping(false);\n    setOffsetX(newOffsetX);\n\n    ...\n  };\n  const onTouchStart = (\n    e: React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>\n  ) => {\n    setIsSwiping(true);\n\n    ...\n  };\n\n  return (\n    <div\n      className=\"swiper-container\"\n      ...\n    >\n      <ul\n        ref={containerRef}\n        className={`swiper-list ${isSwiping ? 'is-swiping' : ''}`}\n        ...\n      >\n        ...\n      </ul>\n    </div>\n  );\n}\n\n...\n```\n\nGo try it out! Awesome! It should work as expected.\n\nWe use `Math.round` which rounds to the nearest image, this can be quite difficult to drag more than half of the current image width just to move to the next image. What if our users just do a lazy swipe or drag, it will not move to the next image at all. That can be quite frustrating for them.\n\nSo how can we improve that? First, let's define a minimum difference needed to move to the next or previous image. We'll name this `MIN_SWIPE_REQUIRED` and set the value as `40`, I think that's enough but feel free to configure this later. On mouse up event, we can check if the difference of between `currentOffsetX` and `offsetX` is more than `MIN_SWIPE_REQUIRED` then we move the images.\n\nIf in case you may ask how do we know whether to move to the left or to the right? It would be the `sign` of the difference. If the difference is _positive_, we move the images to the right. If the difference is _negative_, we move the images to the left. We can reuse the same calculation and simply replace `Math.round` to either [`Math.floor`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor) and [`Math.ceil`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil) to get the `offsetX` required for the next or previous image.\n\nTo write all of these in code, let's update `src/components/Swiper.tsx`:\n\n```tsx\n...\n\nconst MIN_SWIPE_REQUIRED = 40;\n\nfunction Swiper({ items }: Props) {\n  ...\n\n  const onTouchEnd = () => {\n    const currentOffsetX = getRefValue(currentOffsetXRef);\n    const containerWidth = getRefValue(containerWidthRef);\n    let newOffsetX = getRefValue(offsetXRef);\n\n    const diff = currentOffsetX - newOffsetX;\n\n    // we need to check difference in absolute/positive value (if diff is more than 40px)\n    if (Math.abs(diff) > MIN_SWIPE_REQUIRED) {\n      if (diff > 0) {\n        // swipe to the right if diff is positive\n        newOffsetX = Math.floor(newOffsetX / containerWidth) * containerWidth;\n      } else {\n        // swipe to the left if diff is negative\n        newOffsetX = Math.ceil(newOffsetX / containerWidth) * containerWidth;\n      }\n    } else {\n      // remain in the current image\n      newOffsetX = Math.round(newOffsetX / containerWidth) * containerWidth;\n    }\n\n    setIsSwiping(false);\n    setOffsetX(newOffsetX);\n\n    ...\n  };\n\n...\n```\n\nI hope that wasn't too difficult to understand. Once you save all the changes, try doing a lazy swipe or drag (at least 40 pixel difference!) and see that how our swiper will swipe it to the next or previous image.\n\n---\n\n## Swiper indicators\n\nOkay, before we wrap this up. There's one more feature I want to add to our swiper. We can have an indicator to let our users know how many images are in the swiper for them to see and what position the image they're currently looking at. This can also give users an option to click on the indicators to move around the images.\n\nThe number of indicators we need is simple just how many images we have. We can simply loop the images again to display the indicators. Once we loop them through using [`Array.map()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) which is how you loop an array to be displayed in React, we can get their `index`. We can create a state that stores the current index (`currentIdx`) that determines which image is currently displayed.\n\nFor setting the new `currentIdx` after user does a swipe or drag (on mouse up), we can simply divide the `offsetX` with the `containerWidth`, do note that `offsetX` becomes a negative value when moving to the left so we need to use `Math.abs`. For moving the images when we click on an indicator, we can multiply the `index` and the `containerWidth` and make it negative (to move images to the left).\n\nLet's update `src/components/Swiper.tsx` with the following code below to add in the indicators:\n\n```tsx\n...\n\nfunction Swiper({ items }: Props) {\n  ...\n  const [currentIdx, setCurrentIdx] = useState(0);\n\n  ...\n\n  const onTouchEnd = () => {\n    ...\n    setOffsetX(newOffsetX);\n    setCurrentIdx(Math.abs(newOffsetX / containerWidth));\n\n    ...\n  };\n\n  ...\n\n  const indicatorOnClick = (idx: number) => {\n    const containerEl = getRefValue(containerRef);\n    const containerWidth = containerEl.offsetWidth;\n\n    setCurrentIdx(idx);\n    setOffsetX(-(containerWidth * idx));\n  };\n\n  return (\n    <div\n      className=\"swiper-container\"\n      ...\n    >\n      <ul\n        ref={containerRef}\n        ...\n      >\n        ...\n      </ul>\n      <ul className=\"swiper-indicator\">\n        {items.map((_item, idx) => (\n          <li\n            key={idx}\n            className={`swiper-indicator-item ${\n              currentIdx === idx ? 'active' : ''\n            }`}\n            data-testid=\"incidator\" // we'll use this later on our test\n            onClick={() => indicatorOnClick(idx)}\n          />\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n...\n```\n\nThen update `src/components/Swiper.css` to add the styles for our indicators:\n\n```css\n/* ... */\n\n.swiper-indicator {\n  display: flex;\n  justify-content: center;\n  list-style: none;\n  margin: 15px 0 0 0;\n  padding: 0;\n}\n\n.swiper-indicator-item {\n  width: 12px;\n  height: 12px;\n  margin: 0 4px;\n  border-radius: 50%;\n  background-color: #cccccc;\n  cursor: pointer;\n}\n\n.swiper-indicator-item.active {\n  background-color: #777777;\n}\n```\n\n---\n\nOnce you save the changes, should be able to see the swiper with the indicator:\n\n![Screenshot of React Swiper 2](/images/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests/swiper-2.png)\n\nAwesome. Give yourself a pat in the back because you've just built your own swiper!\n\nTime to write some tests!\n\nProceed to the [next part](/posts/how-to-create-your-own-swiper-in-react-and-typescript-with-tests-part-2).\n","previousPost":{"id":"how-to-integrate-with-a-rest-api-using-react-hooks-and-typescript-with-tests","title":"How to integrate with a REST API using React Hooks and TypeScript with tests","date":"2021-12-04","excerpt":"Learn how to integrate with a REST API in a reactive and reusable way","category":"technology","videoUrl":"https://youtu.be/LkumZ2Z7bbs"},"nextPost":{"id":"how-to-create-your-own-swiper-in-react-and-typescript-with-tests-part-2","title":"How to create your own swiper, carousel or slider in React and TypeScript with tests (Part 2)","date":"2022-02-11","excerpt":"Learn how to build a modern mobile touch swiper in a reactive and reusable way","category":"technology","videoUrl":"https://youtu.be/V0dfhBc2lj8"},"title":"How to create your own swiper, carousel or slider in React and TypeScript with tests (Part 1)","date":"2022-02-11","excerpt":"Learn how to build a modern mobile touch swiper in a reactive and reusable way","category":"technology","videoUrl":"https://youtu.be/V0dfhBc2lj8"}},"__N_SSG":true}