{"pageProps":{"postData":{"id":"how-to-integrate-with-a-rest-api-using-react-hooks-and-typescript-with-tests","content":"\n## Introduction\n\nOne of my favorite features that [React](https://reactjs.org/) introduced is [React Hooks](https://reactjs.org/docs/hooks-intro.html). They let you use state and other React features without writing a class. I personally feel that it is cleaner, more readable and much easier to build React components and features with it. Using React Hooks, you can build your own custom hooks on top of it. One of the custom hooks that I usually create is the integration with a back-end server through a [REST API](https://restfulapi.net/), because when your front-end application interacts with an API, you would want to display the different states on your [UI](https://en.wikipedia.org/wiki/User_interface) for users to know when it is loading, when it is successful, or when there's an error. It is also good to separate your custom hooks from your components to make it reusable and it also makes it easier to write tests for them. Follow me along as I build a simple custom API hook using [React](https://reactjs.org/) and [TypeScript](https://www.typescriptlang.org/), as well as write tests for it using [Jest](https://jestjs.io/) and [Testing Library](https://testing-library.com/).\n\n## Prerequisites\n\nThis is the [link](/react-typescript-api-hooks/) to the web application which we'll accomplish by the end of this post, you can see and play around with it or use it as your reference throughout this tutorial.\n\nUpon writing this post, I assume that you have some web development background and basic knowledge regarding [npm](https://www.npmjs.com/), [yarn](https://classic.yarnpkg.com/lang/en/), [HTML](https://developer.mozilla.org/en-US/docs/Web/HTML), [CSS](https://developer.mozilla.org/en-US/docs/Web/CSS), [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript) and [React](https://reactjs.org/).\n\nFastest way to start a new project with React is using [Create React App](https://create-react-app.dev/). It is an officially supported way to create single-page React applications. It offers a modern build setup with no configuration so you can focus on code, not build tools.\n\nTo create our project with React and TypeScript, run this command in your terminal:\n\n```bash\nyarn create react-app react-typescript-api-hooks --template typescript\n```\n\nOnce project is initiated, install the additional libraries which we'll be using later on:\n\n```bash\ncd react-typescript-api-hooks\nyarn add axios @testing-library/react-hooks faker @types/faker\n```\n\nTo run our project, execute the command below:\n\n```bash\nyarn start\n```\n\nWe'll also be using [JSONPlaceholder - Free Fake REST API](https://jsonplaceholder.typicode.com/) for this tutorial as our back-end server.\n\n## Knowing your API\n\nBefore we start creating our custom API hook, it is good to know the details about the API that we'll be integrating with the UI.\n\nWe'll be using a simple [GET](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET) API that returns a list of posts from JSONPlaceholder. You can check it out [here](https://jsonplaceholder.typicode.com/posts) and the output would be something like this:\n\n```json\n[\n  { id: 1, title: '...' /* ... */ },\n  { id: 2, title: '...' /* ... */ },\n  { id: 3, title: '...' /* ... */ },\n  /* ... */\n  { id: 100, title: '...' /* ... */ },\n];\n```\n\n## Create the type\n\nTo get started, let's create the [enum](https://www.typescriptlang.org/docs/handbook/enums.html) for the different states our UI will go through as it fetches data from the API. `Enums` allows us to define a set of named constants. It can make it easier to document intent, or create a set of distinct cases.\n\n```ts\n// src/types.ts\n\nexport enum FetchState {\n  DEFAULT = 'DEFAULT',\n  LOADING = 'LOADING',\n  SUCCESS = 'SUCCESS',\n  ERROR = 'ERROR',\n}\n```\n\nNext, in the same file, let's also add the `type` of the data we are expecting from the API response. It is necessary to do this as TypeScript wouldn't be able to know what is the `type` of the data our API will return.\n\n```ts\n...\n\nexport type PostData = {\n  userId: number;\n  id: number;\n  title: string;\n  body: string;\n};\n```\n\n## Create the custom API hook\n\nNow, we're ready to write our custom API hook. Type the following code below:\n\n```ts\n// src/lib/api-hooks.ts\n\nimport axios from 'axios';\nimport { useState } from 'react';\nimport { FetchState, PostData } from '../types';\n\nexport function useGetPosts() {\n  const [fetchState, setFetchState] = useState(FetchState.DEFAULT);\n  const [posts, setPosts] = useState<Array<PostData>>([]);\n  const getPosts = async () => {\n    try {\n      setFetchState(FetchState.LOADING);\n\n      const res = await axios.get('https://jsonplaceholder.typicode.com/posts');\n      const resData = res.data as Array<PostData>;\n\n      setPosts(resData);\n      setFetchState(FetchState.SUCCESS);\n    } catch (err) {\n      setFetchState(FetchState.ERROR);\n    }\n  };\n\n  return [posts, fetchState, getPosts] as const;\n}\n```\n\nWe created 2 states, one is for the `FetchState`, which we can use in our React component to show different states of the UI. The other state is for storing the array of `PostData` which we can loop through and display one-by-one in the UI.\n\nYou might notice in the code we have this:\n\n```ts\n...\n  const [posts, setPosts] = useState<Array<PostData>>([]);\n...\n```\n\nThis is how we define `type` for the `useState`. In most cases, if our data is using [simple types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html) like `string`, `number` or `boolean`, we don't have to define the `type`. If you remove `<Array<PostData>>`, the type of `posts` would then be `Array<never>`, that's not really helpful for us because TypeScript doesn't know what data we expect inside the array. For complicated types such as this, we would need to define the `type` of the state.\n\nYou may ask, why didn't we do the same for `fetchState`. That's because if the initial value of the state is using an `enum`, in this case `FetchState.DEFAULT`, TypeScript would then assume that it can only accept values from `FetchState` which is often true.\n\nAnother thing to take note, we also had to do [type assertion](https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions) for the `res.data` returned from the API, we can safely do so because we have the knowledge and expectation that the API would always return an array of `PostData`. Without it, TypeScript would give it a `type` of `any` which will again not be helpful for us.\n\nAt the last part of the code, we added `as const` for the returned array to tell TypeScript that this is a read-only array.\n\n## Use the custom API hook in a component\n\nNow let's put our custom API hook into action by using it in a component. Let's update our `App.tsx` code with the following below:\n\n```tsx\n// src/App.tsx\n\nimport { useGetPosts } from './lib/api-hooks';\nimport { FetchState } from './types';\nimport './App.css';\n\nfunction App() {\n  const [posts, fetchState, getPosts] = useGetPosts();\n\n  return (\n    <div className=\"container\">\n      <h1>React TypeScript API hooks</h1>\n      {fetchState === FetchState.DEFAULT && (\n        <>\n          <p>\n            Hello there, click the button below to get the list of posts from\n            the API.\n          </p>\n          <button onClick={getPosts}>Get Posts</button>\n        </>\n      )}\n      {fetchState === FetchState.LOADING && <p>Fetching posts...</p>}\n      {fetchState === FetchState.ERROR && (\n        <>\n          <p>Oops! Something went wrong. Please try again.</p>\n          <button onClick={getPosts}>Get Posts</button>\n        </>\n      )}\n      {fetchState === FetchState.SUCCESS && (\n        <>\n          <p>Here's the list of posts:</p>\n          <ul className=\"posts-list\">\n            {posts.map((post) => (\n              <li key={post.id} className=\"post\">\n                <h3>\n                  {post.id} - {post.title}\n                </h3>\n                <p>{post.body}</p>\n              </li>\n            ))}\n          </ul>\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default App;\n```\n\nOnce you saved it, your React application should display something like this:\n\n![Screenshot of unstyled React API hook UI](/images/posts/how-to-integrate-with-a-rest-api-using-react-hooks-and-typescript-with-tests/unstyled.png)\n\nNow before we interact we it, let's update the styles to make our application slightly prettier.\n\n```css\n/* index.css */\n\n* {\n  box-sizing: border-box;\n}\n\nbody {\n  margin: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto',\n    'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans',\n    'Helvetica Neue', sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  line-height: 1.6;\n}\n```\n\n```css\n/* src/App.css */\n\n.container {\n  width: 600px;\n  max-width: 100%;\n  margin: 0 auto;\n  padding: 20px 15px;\n}\n\n.posts-list {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n\n.post {\n  margin-top: 10px;\n  padding: 0 15px;\n  border: 1px solid #ccc;\n}\n\n.post h3 {\n  color: #222;\n}\n\n.post p {\n  color: #777;\n}\n```\n\nAlright, now try clicking the \"Get Posts\" button. You should briefly see the loading state:\n\n![Screenshot of React API hook UI in loading state](/images/posts/how-to-integrate-with-a-rest-api-using-react-hooks-and-typescript-with-tests/loading.png)\n\nThen eventually the list of posts:\n\n![Screenshot of React API hook UI in success state](/images/posts/how-to-integrate-with-a-rest-api-using-react-hooks-and-typescript-with-tests/success.png)\n\nAlright, everything is working fine as expected.\n\nIf you would like to see the error state. Simple add a `throw` inside the `getPosts` function like this:\n\n```ts\n\n...\n  const getPosts = async () => {\n    try {\n      throw new Error(); // TODO: remove this after seeing the error state\n      ...\n    } catch (err) {\n      ...\n    }\n  };\n```\n\nWhen you click the \"Get Posts\" button again. It will display something like this:\n\n![Screenshot of React API hook UI in error state](/images/posts/how-to-integrate-with-a-rest-api-using-react-hooks-and-typescript-with-tests/error.png)\n\nAwesome! Remove the `throw` code and we can start writing tests.\n\n## Write tests for App component\n\nUpdate the code of `App.test.tsx` for our first test case which is to check the default state:\n\n```tsx\n// src/App.test.tsx\n\nimport { render, screen } from '@testing-library/react';\nimport App from './App';\n\ndescribe('<App />', () => {\n  const renderComponent = () => render(<App />);\n  const defaultText =\n    'Hello there, click the button below to get the list of posts from the API.';\n  const loadingText = 'Fetching posts...';\n  const errorText = 'Oops! Something went wrong. Please try again.';\n  const successText = \"Here's the list of posts:\";\n\n  it('should render default state', () => {\n    renderComponent();\n\n    const stateEl = screen.queryByText(defaultText);\n\n    expect(stateEl).toBeInTheDocument();\n  });\n});\n```\n\nHere we defined all the expected description for each states and check whether an element with a text of `defaultText` is in the document.\n\nTo see if our test case passed along with the coverage, run this command on your terminal:\n\n```bash\nyarn test --coverage\n```\n\nYou don't have to run this command again when you make changes, it will automatically re-run just like `yarn start`.\n\nFor the second test case, let's check whether the description is correct during the loading state. We will have to mock the `useGetPosts()` in order to control the state it returns and do the checks. This also ensures that we are not doing an actual fetch to the API. Mocking data fetching with \"fake\" data prevents flaky tests due to an unavailable back-end server and makes our tests run faster too.\n\n```tsx\n// src/App.test.tsx\n\n...\nimport * as apiHooks from './lib/api-hooks';\nimport { FetchState } from './types';\n\ndescribe('<App />', () => {\n  ...\n\n  afterEach(() => {\n    jest.restoreAllMocks();\n  });\n\n  ...\n\n  it('should render loading state on loading', () => {\n    const fetchState = FetchState.LOADING;\n\n    jest\n      .spyOn(apiHooks, 'useGetPosts')\n      .mockReturnValue([[], fetchState, jest.fn()]);\n\n    renderComponent();\n\n    const stateEl = screen.queryByText(loadingText);\n\n    expect(stateEl).toBeInTheDocument();\n  });\n});\n```\n\nWhen mocking functions, we would need to call `jest.restoreAllMocks()` after each tests using `afterEach` to revert it back to its original state to prevent it from affecting other test cases.\n\nLet's add the code for the third test case to check the error state, it would be similar from the previous test case:\n\n```tsx\n  ...\n\n  it('should render error state on error', () => {\n    const fetchState = FetchState.ERROR;\n\n    jest\n      .spyOn(apiHooks, 'useGetPosts')\n      .mockReturnValue([[], fetchState, jest.fn()]);\n\n    renderComponent();\n\n    const stateEl = screen.queryByText(errorText);\n\n    expect(stateEl).toBeInTheDocument();\n  });\n});\n```\n\nNext, for the fourth test case, we will check whether both the expected description is rendered as well as the post data. We can make use of the library [faker](https://github.com/marak/faker.js) to generate random data for us which makes our test more reliable.\n\n```tsx\n// src/App.test.tsx\nimport faker from 'faker';\n\n  ...\n\n  it('should render success state on success', () => {\n    const fetchState = FetchState.SUCCESS;\n    const posts = [\n      {\n        userId: faker.datatype.number(),\n        id: faker.datatype.number(),\n        title: faker.lorem.sentence(),\n        body: faker.lorem.sentences(),\n      },\n    ];\n\n    jest\n      .spyOn(apiHooks, 'useGetPosts')\n      .mockReturnValue([posts, fetchState, jest.fn()]);\n\n    renderComponent();\n\n    const stateEl = screen.queryByText(successText);\n    const post = posts[0];\n    const postTitle = `${post.id} - ${post.title}`;\n    const postEl = screen.queryByText(postTitle);\n\n    expect(stateEl).toBeInTheDocument();\n    expect(postEl).toBeInTheDocument();\n  });\n});\n```\n\nFor the last test case of `App.tsx`, we just need to check that the `getPosts` function from the custom hook is called when the \"Get Posts\" button is clicked. Add the following code below:\n\n```tsx\nimport { fireEvent, render, screen } from '@testing-library/react';\n  ...\n\n  it('should call API on button click', () => {\n    const getPostsMock = jest.fn();\n\n    jest\n      .spyOn(apiHooks, 'useGetPosts')\n      .mockReturnValue([[], FetchState.DEFAULT, getPostsMock]);\n\n    renderComponent();\n\n    const btnEl = screen.queryByText('Get Posts') as HTMLButtonElement;\n\n    fireEvent.click(btnEl);\n\n    expect(getPostsMock).toBeCalledTimes(1);\n  });\n```\n\nWe are using [fireEvent](https://testing-library.com/docs/dom-testing-library/api-events/) function by Testing Library to fire a click event. It only accepts an element so we had to do a type assertion when querying the button element.\n\nIf you check the coverage on your terminal, it should be 100% now for `App.tsx`.\n\nThat's great! Now are the done with the component tests. Let's move on to write tests for our custom API hook.\n\n## Write tests for custom API hook\n\nFor the first test case, we just need to check that it returns the expected initial values and function. Add the following code below:\n\n```ts\n// src/lib/api-hooks.test.ts\n\nimport { renderHook } from '@testing-library/react-hooks';\nimport { FetchState } from '../types';\nimport { useGetPosts } from './api-hooks';\n\ndescribe('api hooks utilities', () => {\n  describe('useGetPosts()', () => {\n    const renderCustomHook = () => renderHook(() => useGetPosts());\n\n    it('should return initial value', () => {\n      const hook = renderCustomHook();\n      const [posts, fetchState, getPosts] = hook.result.current;\n\n      expect(posts).toEqual([]);\n      expect(fetchState).toBe(FetchState.DEFAULT);\n      expect(typeof getPosts).toBe('function');\n    });\n  });\n});\n```\n\nFor the second test case, let's check whether it is calling the expected API endpoint when the function is executed.\n\n```ts\nimport { act, renderHook } from '@testing-library/react-hooks';\nimport axios from 'axios';\n\n    ...\n\n    afterEach(() => {\n      jest.restoreAllMocks();\n    });\n\n    ...\n\n    it('should have expected endpoint on api call', async () => {\n      const axiosGetSpy = jest\n        .spyOn(axios, 'get')\n        .mockResolvedValue({ data: [] });\n\n      const hook = renderCustomHook();\n      const getPosts = hook.result.current[2];\n\n      await act(async () => {\n        await getPosts();\n      });\n\n      expect(axiosGetSpy).toBeCalledTimes(1);\n      expect(axiosGetSpy).toBeCalledWith(\n        'https://jsonplaceholder.typicode.com/posts'\n      );\n    });\n  ...\n```\n\nWe are mocking the `axios` here to prevent doing an actual fetch. We also used [act](https://reactjs.org/docs/testing-recipes.html#act) function which makes sure all updates related to this action have been processed and applied to the DOM before we make any assertions. This is usually done when the function you executed in the test case makes an update on the React states. When also added `async` and `await` because `getPosts()` is an asynchronous function and ideally we should wait for it to be done before we do our checks.\n\nFor the third test case, we need to check whether we are getting the expected states on API call, we are expecting we will get a loading state while waiting for the API to return the response. Here's the code for that:\n\n```ts\n    ...\n\n    it('should have expected states on api call', async () => {\n      jest.spyOn(axios, 'get').mockResolvedValue({ data: [] });\n\n      const hook = renderCustomHook();\n      const getPosts = hook.result.current[2];\n\n      const promiseAct = act(async () => {\n        await getPosts();\n      });\n\n      const [posts, fetchState] = hook.result.current;\n\n      expect(posts).toEqual([]);\n      expect(fetchState).toBe(FetchState.LOADING);\n\n      await promiseAct;\n    });\n  ...\n```\n\nAs you would notice, we didn't do an `await` for the `act` function right away, we had to store it in a variable and do an `await` at the end because if we didn't, we would be getting `FetchState.SUCCESS` instead which is for a later test case.\n\nFor the fourth test case, we need to check whether we are getting the expected state when the API fails. Add the following code below to do so:\n\n```ts\n    ...\n\n    it('should have expected states on api error', async () => {\n      jest.spyOn(axios, 'get').mockRejectedValue({});\n\n      const hook = renderCustomHook();\n      const getPosts = hook.result.current[2];\n\n      await act(async () => {\n        await getPosts();\n      });\n\n      const [posts, fetchState] = hook.result.current;\n\n      expect(posts).toEqual([]);\n      expect(fetchState).toBe(FetchState.ERROR);\n    });\n  ...\n```\n\nHere we are mocking `axios` with `.mockRejectedValue({})` in order to throw an error when fetching the data.\n\nFor the last test case, we need to check whether we are getting the expected state when the API succeeds. This time the posts should not be an empty array. We will use `faker` library again to mock the data for us. Here's the code below:\n\n```ts\nimport faker from 'faker';\n\n    ...\n\n    it('should have expected states on api success', async () => {\n      const res = {\n        data: [\n          {\n            userId: faker.datatype.number(),\n            id: faker.datatype.number(),\n            title: faker.lorem.sentence(),\n            body: faker.lorem.sentences(),\n          },\n        ],\n      };\n\n      jest.spyOn(axios, 'get').mockResolvedValue(res);\n\n      const hook = renderCustomHook();\n      const getPosts = hook.result.current[2];\n\n      await act(async () => {\n        await getPosts();\n      });\n\n      const [posts, fetchState] = hook.result.current;\n\n      expect(posts).toEqual(res.data);\n      expect(fetchState).toBe(FetchState.SUCCESS);\n    });\n  ...\n```\n\nAnd they're you have it!\n\nBy now, you should have achieved 100% test coverage and all looking green in your terminal just like this:\n\n![Screenshot of React API hook UI 100% Test Coverage](/images/posts/how-to-integrate-with-a-rest-api-using-react-hooks-and-typescript-with-tests/test-coverage.png)\n\nIf you're up for a challenge, try creating your own custom API hook with the rest of the APIs by JSONPlaceholder [here](https://jsonplaceholder.typicode.com/guide/) using what you've learned from this post.\n\nIn case you need the final code as a reference, this is the [link](https://github.com/dominicarrojado/react-typescript-api-hooks) to the GitHub repository.\n\nPlease don't forget to share this post if you find it helpful. Thank you ~\n","previousPost":{"id":"the-turning-point","title":"The Turning Point","date":"2021-10-17","excerpt":"A critical time in your life where big decisions could lead to big change, both at work and in life","category":"personal","videoUrl":""},"nextPost":{"id":"how-to-create-your-own-swiper-in-react-and-typescript-with-tests-part-1","title":"How to create your own swiper, carousel or slider in React and TypeScript with tests (Part 1)","date":"2022-02-09","excerpt":"Learn how to build a modern mobile touch swiper in a reactive and reusable way","category":"technology","videoUrl":""},"title":"How to integrate with a REST API using React Hooks and TypeScript with tests","date":"2021-12-04","excerpt":"Learn how to integrate with a REST API in a reactive and reusable way","category":"technology","videoUrl":"https://youtu.be/LkumZ2Z7bbs"}},"__N_SSG":true}